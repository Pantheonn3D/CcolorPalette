
/* =========================================
   FILE: src/App.jsx
   ========================================= */

import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

// Import your pages
import ColorGenerator from './colorGenerator/ColorGenerator'; 
import LandingPage from './pages/LandingPage/LandingPage';

import { HelmetProvider } from 'react-helmet-async';

function App() {
  return (
    <HelmetProvider>
    <Router>
      <Routes>
        {/* URL: /home -> Shows Landing Page */}
        <Route path="/home" element={<LandingPage />} />

        {/* URL: / -> Shows Generator */}
        <Route path="/" element={<ColorGenerator />} />

        {/* URL: /1A2B3C-FFFFFF -> Shows Generator with colors */}
        <Route path="/:hexCodes" element={<ColorGenerator />} />
      </Routes>
    </Router>        
    </HelmetProvider>
  );
}

export default App;
/* =========================================
   FILE: src/colorGenerator/AccessibilityPanel.jsx
   ========================================= */

import { X, Eye, Check, AlertTriangle } from 'lucide-react';
import { hexToHsl, getContrastColor } from '../utils/colorUtils';
import '../styles/PanelStyles.css';

const getLuminance = (hex) => {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;

  const toLinear = (c) =>
    c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);

  return 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
};

const getContrastRatio = (hex1, hex2) => {
  const l1 = getLuminance(hex1);
  const l2 = getLuminance(hex2);
  const lighter = Math.max(l1, l2);
  const darker = Math.min(l1, l2);
  return (lighter + 0.05) / (darker + 0.05);
};

const getWCAGRating = (ratio) => {
  if (ratio >= 7) return { level: 'AAA', pass: true };
  if (ratio >= 4.5) return { level: 'AA', pass: true };
  if (ratio >= 3) return { level: 'AA+', pass: true };
  return { level: 'Fail', pass: false };
};

const colorBlindModes = [
  { id: 'normal', label: 'Normal Vision' },
  { id: 'protanopia', label: 'Protanopia (Red-Blind)' },
  { id: 'deuteranopia', label: 'Deuteranopia (Green-Blind)' },
  { id: 'tritanopia', label: 'Tritanopia (Blue-Blind)' },
  { id: 'achromatopsia', label: 'Achromatopsia (Monochrome)' },
];

function AccessibilityPanel({
  isOpen,
  onClose,
  colors,
  colorBlindMode,
  onColorBlindModeChange,
}) {
  return (
    <div
      className={`panel-column ${isOpen ? 'open' : ''}`}
      style={{ flexBasis: isOpen ? '280px' : '0px' }}
    >
      <div className="panel-inner" style={{ width: '280px' }}>
        <div className="panel-header">
          <div className="panel-title">
            <Eye size={18} />
            <span>Accessibility</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          <div className="panel-section">
            <label className="panel-label">Color Vision Simulation</label>
            <div className="panel-list">
              {colorBlindModes.map((mode) => (
                <button
                  key={mode.id}
                  className={`panel-list-item ${
                    colorBlindMode === mode.id ? 'selected' : ''
                  }`}
                  onClick={(e) => {
                    onColorBlindModeChange(mode.id);
                    e.currentTarget.blur();
                  }}
                >
                  <span className="panel-list-item-title">{mode.label}</span>
                  {colorBlindMode === mode.id && (
                    <div className="panel-check" />
                  )}
                </button>
              ))}
            </div>
          </div>

          <div className="panel-section">
            <label className="panel-label">Text Contrast (on each color)</label>
            <div className="panel-list">
              {colors.map((color) => {
                const whiteRatio = getContrastRatio(color.hex, '#FFFFFF');
                const blackRatio = getContrastRatio(color.hex, '#000000');
                const bestColor =
                  whiteRatio > blackRatio ? '#FFFFFF' : '#000000';
                const bestRatio = Math.max(whiteRatio, blackRatio);
                const rating = getWCAGRating(bestRatio);

                return (
                  <div key={color.id} className="panel-contrast-item">
                    <div
                      className="panel-contrast-swatch"
                      style={{ backgroundColor: color.hex, color: bestColor }}
                    >
                      Aa
                    </div>
                    <div className="panel-contrast-info">
                      <span className="panel-contrast-hex">{color.hex}</span>
                      <span className="panel-contrast-ratio">
                        {bestRatio.toFixed(1)}:1
                      </span>
                    </div>
                    <div
                      className={`panel-badge ${rating.pass ? 'pass' : 'fail'}`}
                    >
                      {rating.pass ? (
                        <Check size={12} />
                      ) : (
                        <AlertTriangle size={12} />
                      )}
                      {rating.level}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          <div className="panel-section">
            <label className="panel-label">Adjacent Color Contrast</label>
            <div className="panel-list">
              {colors.slice(0, -1).map((color, i) => {
                const nextColor = colors[i + 1];
                const ratio = getContrastRatio(color.hex, nextColor.hex);
                const pass = ratio >= 3;

                return (
                  <div key={color.id} className="panel-adjacent-item">
                    <div className="panel-adjacent-swatches">
                      <div style={{ backgroundColor: color.hex }} />
                      <div style={{ backgroundColor: nextColor.hex }} />
                    </div>
                    <span className="panel-adjacent-ratio">
                      {ratio.toFixed(1)}:1
                    </span>
                    <div className={`panel-badge ${pass ? 'pass' : 'fail'}`}>
                      {pass ? <Check size={12} /> : <AlertTriangle size={12} />}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default AccessibilityPanel;

/* =========================================
   FILE: src/colorGenerator/BookmarkPanel.jsx
   ========================================= */

import { X, Bookmark, Star, ExternalLink, Copy, Check } from 'lucide-react';
import { useState } from 'react';
import '../styles/PanelStyles.css';
import './BookmarkPanel.css';

function BookmarkPanel({ isOpen, onClose, currentUrl }) {
  const [copied, setCopied] = useState(false);
  const isMac = typeof navigator !== 'undefined' && navigator.platform.toUpperCase().indexOf('MAC') >= 0;

  const handleCopyUrl = async () => {
    try {
      await navigator.clipboard.writeText(currentUrl);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  return (
    <div 
      className={`panel-column ${isOpen ? 'open' : ''}`} 
      style={{ flexBasis: isOpen ? '280px' : '0px' }}
    >
      <div className="panel-inner" style={{ width: '280px' }}>
        <div className="panel-header">
          <div className="panel-title">
            <Bookmark size={18} />
            <span>Bookmark</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          {/* Main instruction */}
          <div className="bookmark-main">
            <div className="bookmark-icon-large">
              <Star size={32} />
            </div>
            <h3>Save this palette</h3>
            <p>Bookmark this page to quickly access your current color palette anytime.</p>
          </div>

          {/* Keyboard shortcut */}
          <div className="panel-section">
            <label className="panel-label">Keyboard Shortcut</label>
            <div className="bookmark-shortcut-box">
              <div className="bookmark-keys">
                <kbd>{isMac ? '⌘' : 'Ctrl'}</kbd>
                <span>+</span>
                <kbd>D</kbd>
              </div>
              <span className="bookmark-shortcut-label">Add to bookmarks</span>
            </div>
          </div>

          {/* Current URL preview */}
          <div className="panel-section">
            <label className="panel-label">Current Palette URL</label>
            <div className="bookmark-url-box">
              <code className="bookmark-url">{currentUrl}</code>
              <button 
                className={`bookmark-copy-btn ${copied ? 'copied' : ''}`}
                onClick={handleCopyUrl}
                title="Copy URL"
              >
                {copied ? <Check size={14} /> : <Copy size={14} />}
              </button>
            </div>
            <p className="panel-hint">
              This URL contains your exact palette. Share it or bookmark it!
            </p>
          </div>

          {/* Browser instructions */}
          <div className="panel-section">
            <label className="panel-label">Or manually</label>
            <div className="panel-list">
              <div className="bookmark-step">
                <span className="bookmark-step-num">1</span>
                <span>Click the star icon in your browser's address bar</span>
              </div>
              <div className="bookmark-step">
                <span className="bookmark-step-num">2</span>
                <span>Choose a folder and save</span>
              </div>
              <div className="bookmark-step">
                <span className="bookmark-step-num">3</span>
                <span>Access your palette anytime from bookmarks</span>
              </div>
            </div>
          </div>

          {/* Pro tip */}
          <div className="bookmark-tip">
            <strong>Pro tip:</strong> Generate a palette you love, then bookmark it. Each palette has a unique URL!
          </div>
        </div>
      </div>
    </div>
  );
}

export default BookmarkPanel;
/* =========================================
   FILE: src/colorGenerator/ColorEditorPanel.jsx
   ========================================= */

import { useState, useEffect } from 'react';
import { X, Sun, Moon, Flame, Snowflake, Pipette } from 'lucide-react';
import { hexToHsl, hslToHex } from '../utils/colorUtils';
import './ColorEditorPanel.css';

function ColorEditorPanel({ isOpen, onClose, color, onColorChange }) {
  const [hsl, setHsl] = useState({ h: 0, s: 50, l: 50 });
  const [hexInput, setHexInput] = useState('');

  useEffect(() => {
    if (color?.hex) {
      const converted = hexToHsl(color.hex);
      setHsl(converted);
      setHexInput(color.hex.replace('#', ''));
    }
  }, [color?.hex]);

  const updateColor = (newHsl) => {
    const clamped = {
      h: ((newHsl.h % 360) + 360) % 360,
      s: Math.max(0, Math.min(100, newHsl.s)),
      l: Math.max(0, Math.min(100, newHsl.l)),
    };
    setHsl(clamped);
    const newHex = hslToHex(clamped.h, clamped.s, clamped.l);
    setHexInput(newHex.replace('#', ''));
    onColorChange(color.id, newHex);
  };

  const handleHexInput = (value) => {
    setHexInput(value);
    if (/^[0-9A-Fa-f]{6}$/.test(value)) {
      const hex = `#${value.toUpperCase()}`;
      const converted = hexToHsl(hex);
      setHsl(converted);
      onColorChange(color.id, hex);
    }
  };

  const adjustments = [
    {
      icon: Sun,
      label: 'Lighter',
      action: () => updateColor({ ...hsl, l: hsl.l + 10 }),
    },
    {
      icon: Moon,
      label: 'Darker',
      action: () => updateColor({ ...hsl, l: hsl.l - 10 }),
    },
    {
      icon: Flame,
      label: 'Warmer',
      action: () => updateColor({ ...hsl, h: hsl.h - 15 }),
    },
    {
      icon: Snowflake,
      label: 'Cooler',
      action: () => updateColor({ ...hsl, h: hsl.h + 15 }),
    },
    {
      icon: Pipette,
      label: 'Saturate',
      action: () => updateColor({ ...hsl, s: hsl.s + 15 }),
    },
  ];

  if (!color) return null;

  return (
    <div className={`editor-column ${isOpen ? 'open' : ''}`}>
      <div className="editor-inner">
        <div className="editor-header">
          <span className="editor-title">Edit Color</span>
          <button className="editor-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="editor-scroll">
          {/* Color Preview */}
          <div
            className="editor-preview"
            style={{ backgroundColor: color.hex }}
          >
            <span
              className="editor-preview-hex"
              style={{ color: hsl.l > 60 ? '#000' : '#fff' }}
            >
              {color.hex}
            </span>
          </div>

          {/* Hex Input */}
          <div className="editor-field">
            <label>Hex</label>
            <div className="editor-hex-input">
              <span>#</span>
              <input
                type="text"
                value={hexInput}
                onChange={(e) => handleHexInput(e.target.value.toUpperCase())}
                maxLength={6}
                spellCheck={false}
              />
            </div>
          </div>

          {/* HSL Sliders */}
          <div className="editor-field">
            <label>
              Hue <span>{Math.round(hsl.h)}°</span>
            </label>
            <input
              type="range"
              min="0"
              max="360"
              value={hsl.h}
              onChange={(e) =>
                updateColor({ ...hsl, h: Number(e.target.value) })
              }
              className="slider slider-hue"
            />
          </div>

          <div className="editor-field">
            <label>
              Saturation <span>{Math.round(hsl.s)}%</span>
            </label>
            <input
              type="range"
              min="0"
              max="100"
              value={hsl.s}
              onChange={(e) =>
                updateColor({ ...hsl, s: Number(e.target.value) })
              }
              className="slider slider-saturation"
              style={{
                '--sat-color': hslToHex(hsl.h, 100, 50),
              }}
            />
          </div>

          <div className="editor-field">
            <label>
              Lightness <span>{Math.round(hsl.l)}%</span>
            </label>
            <input
              type="range"
              min="0"
              max="100"
              value={hsl.l}
              onChange={(e) =>
                updateColor({ ...hsl, l: Number(e.target.value) })
              }
              className="slider slider-lightness"
              style={{
                '--light-mid': hslToHex(hsl.h, hsl.s, 50),
              }}
            />
          </div>

          {/* Quick Adjustments */}
          <div className="editor-adjustments">
            <label>Quick Adjust</label>
            <div className="adjustment-buttons">
              {adjustments.map((adj) => (
                <button
                  key={adj.label}
                  className="adjustment-btn"
                  onClick={adj.action}
                  title={adj.label}
                >
                  <adj.icon size={16} />
                  <span>{adj.label}</span>
                </button>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default ColorEditorPanel;

/* =========================================
   FILE: src/colorGenerator/ColorGenerator.jsx
   ========================================= */

// src/colorGenerator/ColorGenerator.jsx

import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { Helmet } from 'react-helmet-async';
import {
  Plus,
  X,
  Copy,
  Lock,
  Unlock,
  ArrowLeftRight,
  ArrowDownUp,
  SwatchBook,
  Check,
  Undo2,
  Redo2,
  Sparkles,
  Eye,
  Clock,
  Upload,
  Bookmark,
} from 'lucide-react';
import Header from '../header/Header';
import MethodPanel from './MethodPanel';
import AccessibilityPanel from './AccessibilityPanel';
import HistoryPanel from './HistoryPanel';
import ExportPanel from './ExportPanel';
import BookmarkPanel from './BookmarkPanel';
import './ColorGenerator.css';
import {
  generateRandomPalette,
  getContrastColor,
  generateBridgeColor,
  simulateColorBlindness,
  generateShades,
  generateRichSEO,
  hexToHsl,
} from '../utils/colorUtils';

const generateId = () => Math.random().toString(36).substring(2, 11);

const createColorObjects = (hexArray) =>
  hexArray.map((hex) => ({
    id: generateId(),
    hex,
    locked: false,
  }));

const MAX_HISTORY = 50;
const MAX_COLORS = 8;
const MIN_COL_PX = 128;

const isMobileView = () => window.innerWidth <= 768;

const getMaxOpenPanels = () => {
  if (typeof window !== 'undefined' && window.innerWidth <= 768) {
    return 1;
  }
  return 3;
};

// Helper to convert hex to RGB for structured data
const hexToRgb = (hex) => {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return { r, g, b };
};

// Format content sections for display
const formatContentSections = (content) => {
  if (!content) return [];
  
  return content.split('\n\n').map((section, index) => {
    const colonIndex = section.indexOf(':');
    if (colonIndex > 0 && colonIndex < 50) {
      const title = section.substring(0, colonIndex).trim();
      const body = section.substring(colonIndex + 1).trim();
      return { id: index, title, body, hasTitle: true };
    }
    return { id: index, title: '', body: section, hasTitle: false };
  });
};

function ColorGenerator() {
  // Refs
  const containerRef = useRef(null);
  const colorsAreaRef = useRef(null);

  // State for stacked colors layout
  const [stackColors, setStackColors] = useState(false);

  // Helper function to check vertical layout
  const isVerticalLayout = useCallback(() => {
    return isMobileView() || stackColors;
  }, [stackColors]);

  const DragIcon = isVerticalLayout() ? ArrowDownUp : ArrowLeftRight;

  // History state
  const [history, setHistory] = useState(() => [
    createColorObjects(generateRandomPalette()),
  ]);
  const [historyIndex, setHistoryIndex] = useState(0);

  // Panel states
  const [openPanels, setOpenPanels] = useState([]);

  // Generation settings
  const [generationMode, setGenerationMode] = useState('auto');
  const [constraints, setConstraints] = useState({
    mood: 'any',
    minContrast: 1.5,
    darkModeFriendly: false,
  });

  // Accessibility
  const [colorBlindMode, setColorBlindMode] = useState('normal');

  // --- CORE DATA SOURCE ---
  const colors = history[historyIndex];

  // UI states
  const [newColorId, setNewColorId] = useState(null);
  const [removingId, setRemovingId] = useState(null);
  const [copiedId, setCopiedId] = useState(null);

  // Drag states
  const [dragState, setDragState] = useState(null);
  const [isSnapping, setIsSnapping] = useState(false);

  // Panel helper functions
  const isPanelOpen = (panelName) => openPanels.includes(panelName);

  const togglePanel = (panelName) => {
    setOpenPanels((prev) => {
      if (prev.includes(panelName)) {
        return prev.filter((p) => p !== panelName);
      } else {
        const maxPanels = getMaxOpenPanels();
        let newPanels = [...prev, panelName];
        if (newPanels.length > maxPanels) {
          newPanels = newPanels.slice(-maxPanels);
        }
        return newPanels;
      }
    });
  };

  const closePanel = (panelName) => {
    setOpenPanels((prev) => prev.filter((p) => p !== panelName));
  };

  const isMethodOpen = isPanelOpen('method');
  const isA11yOpen = isPanelOpen('a11y');
  const isHistoryOpen = isPanelOpen('history');
  const isExportOpen = isPanelOpen('export');
  const isBookmarkOpen = isPanelOpen('bookmark');

  const canAddMoreColors = colors.length < MAX_COLORS;

  // Get current URL for bookmark panel & SEO Canonical
  const getCurrentUrl = () => {
    if (typeof window === 'undefined') return '';
    return window.location.href;
  };

  const [activeShadeId, setActiveShadeId] = useState(null);

  // Handle Tap/Click Outside Shade Picker
  useEffect(() => {
    const handleClickOutside = (e) => {
      if (!activeShadeId) return;
      if (e.target.closest('.shade-container')) return;
      setActiveShadeId(null);
    };

    if (activeShadeId) {
      window.addEventListener('mousedown', handleClickOutside);
      window.addEventListener('touchstart', handleClickOutside);
    }

    return () => {
      window.removeEventListener('mousedown', handleClickOutside);
      window.removeEventListener('touchstart', handleClickOutside);
    };
  }, [activeShadeId]);

  // Handle Mouse Leave (Desktop)
  const handleMouseLeave = () => {
    if (window.innerWidth > 768) {
      setActiveShadeId(null);
    }
  };

  const updateColors = useCallback(
    (newColors) => {
      setHistory((prev) => {
        const newHistory = prev.slice(0, historyIndex + 1);
        newHistory.push(newColors);
        if (newHistory.length > MAX_HISTORY) {
          newHistory.shift();
          return newHistory;
        }
        return newHistory;
      });
      setHistoryIndex((prev) => Math.min(prev + 1, MAX_HISTORY - 1));
    },
    [historyIndex]
  );

  const undo = useCallback(() => {
    if (historyIndex > 0) {
      setHistoryIndex((prev) => prev - 1);
    }
  }, [historyIndex]);

  const redo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      setHistoryIndex((prev) => prev + 1);
    }
  }, [historyIndex, history.length]);

  const goToHistoryIndex = useCallback(
    (index) => {
      if (index >= 0 && index < history.length) {
        setHistoryIndex(index);
      }
    },
    [history.length]
  );

  const canUndo = historyIndex > 0;
  const canRedo = historyIndex < history.length - 1;

  // Parse URL on mount
  useEffect(() => {
    const parseUrlState = () => {
      const path = window.location.pathname.slice(1);
      const params = new URLSearchParams(window.location.search);

      if (path === 'home') return;

      const navEntries = performance.getEntriesByType('navigation');
      const isReload = navEntries.length > 0 && navEntries[0].type === 'reload';
      const wasAlreadyHere = sessionStorage.getItem('ccolorpalette_session');

      if (isReload || wasAlreadyHere) {
        window.history.replaceState({}, '', '/');
        sessionStorage.setItem('ccolorpalette_session', 'true');
        return;
      }

      sessionStorage.setItem('ccolorpalette_session', 'true');

      if (path && path.length > 0) {
        const hexCodes = path
          .split('-')
          .map((h) => {
            const cleaned = h.toUpperCase().replace(/[^0-9A-F]/g, '');
            return cleaned.length === 6 ? `#${cleaned}` : null;
          })
          .filter(Boolean);

        if (hexCodes.length >= 2) {
          const initialColors = hexCodes.map((hex) => ({
            id: generateId(),
            hex,
            locked: false,
          }));
          setHistory([initialColors]);
          setHistoryIndex(0);
        }
      }

      if (params.has('mode')) {
        const mode = params.get('mode');
        if (
          ['auto', 'mono', 'analogous', 'complementary', 'splitComplementary', 'triadic'].includes(mode)
        ) {
          setGenerationMode(mode);
        }
      }
      if (params.has('mood')) {
        const mood = params.get('mood');
        if (['any', 'muted', 'pastel', 'vibrant', 'dark'].includes(mood)) {
          setConstraints((prev) => ({ ...prev, mood }));
        }
      }
      if (params.has('contrast')) {
        const contrast = parseFloat(params.get('contrast'));
        if (!isNaN(contrast) && contrast >= 1 && contrast <= 4.5) {
          setConstraints((prev) => ({ ...prev, minContrast: contrast }));
        }
      }
      if (params.has('dark')) {
        setConstraints((prev) => ({
          ...prev,
          darkModeFriendly: params.get('dark') === '1',
        }));
      }
      if (params.has('vision')) {
        const vision = params.get('vision');
        if (['normal', 'protanopia', 'deuteranopia', 'tritanopia', 'achromatopsia'].includes(vision)) {
          setColorBlindMode(vision);
        }
      }
    };

    parseUrlState();
  }, []);

  // Update chromaAPI
  useEffect(() => {
    window.chromaAPI = {
      undo,
      redo,
      canUndo: () => canUndo,
      canRedo: () => canRedo,
      getShareUrl: () => {
        const hexes = colors.map((c) => c.hex.replace('#', '')).join('-');
        const params = new URLSearchParams();

        if (generationMode !== 'auto') params.set('mode', generationMode);
        if (constraints.mood !== 'any') params.set('mood', constraints.mood);
        if (constraints.minContrast !== 1.5)
          params.set('contrast', constraints.minContrast.toString());
        if (constraints.darkModeFriendly) params.set('dark', '1');
        if (colorBlindMode !== 'normal') params.set('vision', colorBlindMode);

        const queryString = params.toString();
        return `${window.location.origin}/${hexes}${queryString ? '?' + queryString : ''}`;
      },
    };
  }, [undo, redo, canUndo, canRedo, colors, generationMode, constraints, colorBlindMode]);

  const generatePalette = useCallback(
    (count = 5) => {
      const lockedColors = colors.filter((c) => c.locked);
      const unlockedCount = count - lockedColors.length;

      if (unlockedCount <= 0) return;

      const newPalette = generateRandomPalette(generationMode, unlockedCount, constraints);
      const newColors = newPalette.map((hex) => ({
        id: generateId(),
        hex,
        locked: false,
      }));

      if (lockedColors.length === 0) {
        updateColors(newColors);
        return;
      }

      const result = [];
      let newIndex = 0;
      colors.forEach((c) => {
        if (c.locked) {
          result.push({ ...c });
        } else if (newIndex < newColors.length) {
          result.push(newColors[newIndex]);
          newIndex++;
        }
      });
      while (newIndex < newColors.length) {
        result.push(newColors[newIndex]);
        newIndex++;
      }

      updateColors(result);
      setNewColorId(null);
    },
    [colors, generationMode, constraints, updateColors]
  );

  const toggleShadePicker = (id) => {
    setActiveShadeId((prev) => (prev === id ? null : id));
  };

  const pickShade = (originalId, newHex) => {
    const newColors = colors.map((c) =>
      c.id === originalId ? { ...c, hex: newHex } : c
    );
    updateColors(newColors);
    setActiveShadeId(null);
  };

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.code === 'Space') {
        if (document.activeElement instanceof HTMLButtonElement) {
          document.activeElement.blur();
        }
        e.preventDefault();
        generatePalette(colors.length);
        return;
      }

      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      }
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        redo();
      }
      if (e.key === 'Escape') {
        setOpenPanels([]);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [undo, redo, colors.length, generatePalette]);

  // Update URL whenever colors change
  useEffect(() => {
    const hexes = colors.map((c) => c.hex.replace('#', '')).join('-');
    const params = new URLSearchParams();

    if (generationMode !== 'auto') params.set('mode', generationMode);
    if (constraints.mood !== 'any') params.set('mood', constraints.mood);
    if (constraints.minContrast !== 1.5)
      params.set('contrast', constraints.minContrast.toString());
    if (constraints.darkModeFriendly) params.set('dark', '1');
    if (colorBlindMode !== 'normal') params.set('vision', colorBlindMode);

    const queryString = params.toString();
    const newUrl = `/${hexes}${queryString ? '?' + queryString : ''}`;

    window.history.replaceState({}, '', newUrl);
  }, [colors, generationMode, constraints, colorBlindMode]);

  const addColorAtIndex = (index) => {
    if (!canAddMoreColors) return;

    const colorBefore = colors[index].hex;
    const colorAfter = colors[index + 1].hex;
    const newHex = generateBridgeColor(colorBefore, colorAfter);
    const newId = generateId();

    const newColors = [
      ...colors.slice(0, index + 1),
      { id: newId, hex: newHex, locked: false },
      ...colors.slice(index + 1),
    ];

    updateColors(newColors);
    setNewColorId(newId);
    setTimeout(() => setNewColorId(null), 600);
  };

  const removeColor = (id) => {
    if (colors.length <= 2) return;

    setRemovingId(id);
    setTimeout(() => {
      updateColors(colors.filter((c) => c.id !== id));
      setRemovingId(null);
    }, 350);
  };

  const toggleLock = (id) => {
    updateColors(colors.map((c) => (c.id === id ? { ...c, locked: !c.locked } : c)));
  };

  const copyHex = async (id, hex) => {
    try {
      await navigator.clipboard.writeText(hex);
      setCopiedId(id);
      setTimeout(() => setCopiedId(null), 1500);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  // Calculate size by measuring actual elements
  const getColumnSize = useCallback(() => {
    if (!containerRef.current) return 0;

    const firstColumn = containerRef.current.querySelector('.color-column');
    const vertical = isVerticalLayout();

    if (firstColumn) {
      return vertical ? firstColumn.offsetHeight : firstColumn.offsetWidth;
    }

    if (vertical) {
      const containerHeight = containerRef.current.offsetHeight;
      const headerHeight = 56;
      return (containerHeight - headerHeight) / colors.length;
    } else {
      let panelWidth = 0;
      if (isMethodOpen) panelWidth += 240;
      if (isA11yOpen) panelWidth += 280;
      if (isHistoryOpen) panelWidth += 260;
      if (isExportOpen) panelWidth += 300;
      if (isBookmarkOpen) panelWidth += 280;

      const availableWidth = containerRef.current.offsetWidth - panelWidth;
      return availableWidth / colors.length;
    }
  }, [
    colors.length,
    isMethodOpen,
    isA11yOpen,
    isHistoryOpen,
    isExportOpen,
    isBookmarkOpen,
    isVerticalLayout,
  ]);

  // Handle both mouse and touch, both orientations
  const handleDragStart = (e, id, index) => {
    if (e.type === 'touchstart') {
      e.preventDefault();
    }

    const columnSize = getColumnSize();
    const vertical = isVerticalLayout();

    let clientPos;
    if (e.type === 'touchstart') {
      clientPos = vertical ? e.touches[0].clientY : e.touches[0].clientX;
    } else {
      e.preventDefault();
      clientPos = vertical ? e.clientY : e.clientX;
    }

    setDragState({
      id,
      startIndex: index,
      currentIndex: index,
      startPos: clientPos,
      currentPos: clientPos,
      columnSize,
      isMobile: vertical,
    });
  };

  // Handle movement in correct direction
  const handleMouseMove = useCallback(
    (e) => {
      if (!dragState || isSnapping) return;

      const { startIndex, columnSize, isMobile } = dragState;

      let clientPos;
      if (e.type === 'touchmove') {
        clientPos = isMobile ? e.touches[0].clientY : e.touches[0].clientX;
      } else {
        clientPos = isMobile ? e.clientY : e.clientX;
      }

      let delta = clientPos - dragState.startPos;

      const maxNegativeOffset = -startIndex * columnSize;
      const maxPositiveOffset = (colors.length - 1 - startIndex) * columnSize;
      delta = Math.max(maxNegativeOffset, Math.min(maxPositiveOffset, delta));

      const indexOffset = Math.round(delta / columnSize);
      const newIndex = Math.max(0, Math.min(colors.length - 1, startIndex + indexOffset));

      setDragState((prev) => ({
        ...prev,
        currentPos: dragState.startPos + delta,
        currentIndex: newIndex,
      }));
    },
    [dragState, isSnapping, colors.length]
  );

  const handleMouseUp = useCallback(() => {
    if (!dragState) return;

    const { startIndex, currentIndex } = dragState;
    setIsSnapping(true);

    setTimeout(() => {
      if (startIndex !== currentIndex) {
        const newColors = [...colors];
        const [removed] = newColors.splice(startIndex, 1);
        newColors.splice(currentIndex, 0, removed);
        updateColors(newColors);
      }
      setDragState(null);
      setIsSnapping(false);
    }, 250);
  }, [dragState, colors, updateColors]);

  // Event listeners for drag
  useEffect(() => {
    if (dragState) {
      const handleMove = (e) => {
        if (e.type === 'touchmove') {
          e.preventDefault();
        }
        handleMouseMove(e);
      };

      const handleEnd = () => {
        handleMouseUp();
      };

      window.addEventListener('mousemove', handleMove);
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchmove', handleMove, { passive: false });
      window.addEventListener('touchend', handleEnd);
      window.addEventListener('touchcancel', handleEnd);

      document.body.style.cursor = 'grabbing';
      document.body.style.overflow = 'hidden';

      return () => {
        window.removeEventListener('mousemove', handleMove);
        window.removeEventListener('mouseup', handleEnd);
        window.removeEventListener('touchmove', handleMove);
        window.removeEventListener('touchend', handleEnd);
        window.removeEventListener('touchcancel', handleEnd);
        document.body.style.cursor = '';
        document.body.style.overflow = '';
      };
    }
  }, [dragState, handleMouseMove, handleMouseUp]);

  // ResizeObserver for stacked layout detection
  useEffect(() => {
    const el = colorsAreaRef.current;
    if (!el) return;

    const update = () => {
      const w = el.getBoundingClientRect().width;
      const perCol = w / Math.max(1, colors.length);
      setStackColors(perCol < MIN_COL_PX);
    };

    update();

    let ro;
    if (typeof ResizeObserver !== 'undefined') {
      ro = new ResizeObserver(() => update());
      ro.observe(el);
    } else {
      window.addEventListener('resize', update);
    }

    return () => {
      if (ro) ro.disconnect();
      else window.removeEventListener('resize', update);
    };
  }, [colors.length]);

  // Use correct transform direction based on orientation
  const getColumnStyle = (index, id) => {
    if (!dragState) return {};

    const { startIndex, currentIndex, startPos, currentPos, columnSize, isMobile } = dragState;
    const isDragged = id === dragState.id;
    const transformProp = isMobile ? 'translateY' : 'translateX';

    if (isDragged) {
      if (isSnapping) {
        const snapOffset = (currentIndex - startIndex) * columnSize;
        return {
          transform: `${transformProp}(${snapOffset}px)`,
          zIndex: 100,
          transition: 'transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1)',
        };
      } else {
        const offset = currentPos - startPos;
        return {
          transform: `${transformProp}(${offset}px)`,
          zIndex: 100,
          transition: 'none',
        };
      }
    }

    let shift = 0;
    if (startIndex < currentIndex) {
      if (index > startIndex && index <= currentIndex) shift = -1;
    } else if (startIndex > currentIndex) {
      if (index >= currentIndex && index < startIndex) shift = 1;
    }

    return {
      transform: shift !== 0 ? `${transformProp}(${shift * columnSize}px)` : `${transformProp}(0)`,
      transition: 'transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1)',
    };
  };

  const getDisplayColor = (hex) => {
    if (colorBlindMode === 'normal') return hex;
    return simulateColorBlindness(hex, colorBlindMode);
  };

  // --- SEO DATA GENERATION ---
  const currentHexes = useMemo(() => colors.map((c) => c.hex), [colors]);
  const seoData = useMemo(
    () => generateRichSEO(currentHexes, generationMode, constraints.mood),
    [currentHexes, generationMode, constraints.mood]
  );

  const currentCanonical = typeof window !== 'undefined' ? window.location.href : '';
  const contentSections = useMemo(() => formatContentSections(seoData.content), [seoData.content]);

  // Generate JSON-LD structured data for the color palette
  const structuredData = useMemo(() => {
    const colorItems = colors.map((c, index) => {
      const rgb = hexToRgb(c.hex);
      const hsl = hexToHsl(c.hex);
      return {
        '@type': 'Thing',
        name: `Color ${index + 1}`,
        description: `${c.hex} - RGB(${rgb.r}, ${rgb.g}, ${rgb.b}) - HSL(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`,
        identifier: c.hex,
      };
    });

    return {
      '@context': 'https://schema.org',
      '@type': 'CreativeWork',
      name: seoData.title,
      description: seoData.meta,
      url: currentCanonical,
      creator: {
        '@type': 'Organization',
        name: 'CcolorPalette',
      },
      keywords: seoData.keywords?.join(', ') || '',
      about: colorItems,
      additionalProperty: seoData.traits
        ? [
            {
              '@type': 'PropertyValue',
              name: 'Color Harmony',
              value: seoData.traits.harmony,
            },
            {
              '@type': 'PropertyValue',
              name: 'Color Temperature',
              value: seoData.traits.temperature,
            },
            {
              '@type': 'PropertyValue',
              name: 'Saturation Level',
              value: seoData.traits.saturation,
            },
            {
              '@type': 'PropertyValue',
              name: 'Primary Hue',
              value: seoData.traits.primaryHue,
            },
            {
              '@type': 'PropertyValue',
              name: 'Accessibility Score',
              value: seoData.traits.accessibilityScore,
            },
          ]
        : [],
    };
  }, [colors, seoData, currentCanonical]);

  return (
    <div className="app-wrapper">
      {/* SEO: HEAD META TAGS */}
      <Helmet>
        <title>{seoData.title} | CcolorPalette</title>
        <meta name="description" content={seoData.meta} />
        <link rel="canonical" href={currentCanonical} />

        {/* Keywords */}
        {seoData.keywords && seoData.keywords.length > 0 && (
          <meta name="keywords" content={seoData.keywords.slice(0, 10).join(', ')} />
        )}

        {/* Open Graph / Social */}
        <meta property="og:title" content={seoData.title} />
        <meta property="og:description" content={seoData.meta} />
        <meta property="og:url" content={currentCanonical} />
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content="CcolorPalette" />

        {/* Twitter */}
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content={seoData.title} />
        <meta name="twitter:description" content={seoData.meta} />

        {/* Additional SEO signals */}
        <meta name="robots" content="index, follow" />
        <meta name="author" content="CcolorPalette" />

        {/* JSON-LD Structured Data */}
        <script type="application/ld+json">{JSON.stringify(structuredData)}</script>
      </Helmet>

      <div className="page-section visible">
        <Header
          canUndo={canUndo}
          canRedo={canRedo}
          onUndo={undo}
          onRedo={redo}
          onToggleMethod={() => togglePanel('method')}
          isMethodOpen={isMethodOpen}
          onToggleA11y={() => togglePanel('a11y')}
          isA11yOpen={isA11yOpen}
          onToggleHistory={() => togglePanel('history')}
          isHistoryOpen={isHistoryOpen}
          onToggleExport={() => togglePanel('export')}
          isExportOpen={isExportOpen}
          onToggleBookmark={() => togglePanel('bookmark')}
          isBookmarkOpen={isBookmarkOpen}
          logoColors={colors}
          onLogoClick={() => generatePalette(colors.length)}
        />

        <main className="generator-container" ref={containerRef}>
          {/* Mobile Header Row */}
          <div className="mobile-header">
            <button className="mobile-hint" onClick={() => generatePalette(colors.length)}>
              Tap to generate
            </button>

            <div className="mobile-actions">
              <button
                className={`mobile-icon-btn ${!canUndo ? 'disabled' : ''}`}
                onClick={undo}
                disabled={!canUndo}
              >
                <Undo2 size={18} />
              </button>
              <button
                className={`mobile-icon-btn ${!canRedo ? 'disabled' : ''}`}
                onClick={redo}
                disabled={!canRedo}
              >
                <Redo2 size={18} />
              </button>

              <div className="mobile-separator" />

              <button
                className={`mobile-icon-btn ${isMethodOpen ? 'active' : ''}`}
                onClick={() => togglePanel('method')}
              >
                <Sparkles size={18} />
              </button>
              <button
                className={`mobile-icon-btn ${isA11yOpen ? 'active' : ''}`}
                onClick={() => togglePanel('a11y')}
              >
                <Eye size={18} />
              </button>
              <button
                className={`mobile-icon-btn ${isHistoryOpen ? 'active' : ''}`}
                onClick={() => togglePanel('history')}
              >
                <Clock size={18} />
              </button>
              <button
                className={`mobile-icon-btn ${isExportOpen ? 'active' : ''}`}
                onClick={() => togglePanel('export')}
              >
                <Upload size={18} />
              </button>
            </div>
          </div>

          <section
            ref={colorsAreaRef}
            className={`colors-area ${stackColors ? 'stacked' : ''}`}
          >
            {colors.map((color, index) => {
              const displayHex = getDisplayColor(color.hex);
              const textColor = getContrastColor(displayHex);

              const isNew = color.id === newColorId;
              const isRemoving = color.id === removingId;
              const isCopied = copiedId === color.id;
              const isDragging = dragState?.id === color.id;
              const columnStyle = getColumnStyle(index, color.id);
              const isShadePicking = activeShadeId === color.id;

              return (
                <React.Fragment key={color.id}>
                  <div
                    className={`color-column ${isNew ? 'color-entering' : ''} ${
                      isRemoving ? 'color-removing' : ''
                    } ${isDragging ? 'is-dragging' : ''} ${
                      dragState && !isDragging ? 'is-shifting' : ''
                    }`}
                    style={{ backgroundColor: displayHex, ...columnStyle }}
                  >
                    {isShadePicking ? (
                      <div className="shade-container" onMouseLeave={handleMouseLeave}>
                        {generateShades(color.hex, window.innerWidth <= 768 ? 6 : 20).map(
                          (shadeHex) => (
                            <button
                              key={shadeHex}
                              className="shade-step"
                              style={{ backgroundColor: shadeHex }}
                              onClick={(e) => {
                                e.stopPropagation();
                                pickShade(color.id, shadeHex);
                              }}
                              title={shadeHex}
                            />
                          )
                        )}
                        <button
                          className="shade-close-btn"
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleShadePicker(null);
                          }}
                        >
                          <X size={20} />
                        </button>
                      </div>
                    ) : (
                      <>
                        <div className="color-toolbar" style={{ color: textColor }}>
                          {colors.length > 2 && (
                            <button
                              className="toolbar-btn"
                              onClick={(e) => {
                                e.stopPropagation();
                                removeColor(color.id);
                                e.currentTarget.blur();
                              }}
                              title="Remove"
                              style={{ color: textColor }}
                            >
                              <X size={20} />
                            </button>
                          )}

                          <button
                            className="toolbar-btn"
                            onClick={(e) => {
                              e.stopPropagation();
                              copyHex(color.id, color.hex);
                              e.currentTarget.blur();
                            }}
                            title="Copy hex"
                            style={{ color: textColor }}
                          >
                            {isCopied ? <Check size={20} /> : <Copy size={20} />}
                          </button>

                          <button
                            className={`toolbar-btn ${color.locked ? 'active' : ''}`}
                            onClick={(e) => {
                              e.stopPropagation();
                              toggleLock(color.id);
                              e.currentTarget.blur();
                            }}
                            title={color.locked ? 'Unlock' : 'Lock'}
                            style={{ color: textColor }}
                          >
                            {color.locked ? <Lock size={20} /> : <Unlock size={20} />}
                          </button>

                          <button
                            className={`toolbar-btn ${isShadePicking ? 'active' : ''}`}
                            title="Adjust shade"
                            onClick={(e) => {
                              e.stopPropagation();
                              toggleShadePicker(color.id);
                              e.currentTarget.blur();
                            }}
                            style={{ color: textColor }}
                          >
                            <SwatchBook size={20} />
                          </button>

                          <div
                            className="toolbar-btn drag-handle"
                            title="Drag to reorder"
                            style={{ color: textColor }}
                            onMouseDown={(e) => handleDragStart(e, color.id, index)}
                            onTouchStart={(e) => handleDragStart(e, color.id, index)}
                          >
                            <DragIcon size={20} />
                          </div>
                        </div>

                        <div className="color-content">
                          <h2
                            className={`color-hex ${isCopied ? 'copied' : ''}`}
                            style={{ color: textColor }}
                            onClick={() => copyHex(color.id, color.hex)}
                          >
                            {isCopied ? 'Copied!' : color.hex.replace('#', '')}
                          </h2>
                        </div>

                        {color.locked && (
                          <div className="lock-indicator" style={{ color: textColor }}>
                            <Lock size={16} />
                          </div>
                        )}
                      </>
                    )}
                  </div>

                  {index < colors.length - 1 && !dragState && canAddMoreColors && (
                    <div className="addColor">
                      <button
                        className="addBtn"
                        onClick={(e) => {
                          addColorAtIndex(index);
                          e.currentTarget.blur();
                        }}
                        aria-label="Add color"
                      >
                        <Plus size={24} strokeWidth={2.5} color="#161616" />
                      </button>
                    </div>
                  )}
                </React.Fragment>
              );
            })}
          </section>

          <MethodPanel
            isOpen={isMethodOpen}
            onClose={() => closePanel('method')}
            value={generationMode}
            onChange={setGenerationMode}
            constraints={constraints}
            onConstraintsChange={setConstraints}
          />

          <AccessibilityPanel
            isOpen={isA11yOpen}
            onClose={() => closePanel('a11y')}
            colors={colors}
            colorBlindMode={colorBlindMode}
            onColorBlindModeChange={setColorBlindMode}
          />

          <HistoryPanel
            isOpen={isHistoryOpen}
            onClose={() => closePanel('history')}
            history={history}
            currentIndex={historyIndex}
            onSelectPalette={goToHistoryIndex}
          />

          <ExportPanel
            isOpen={isExportOpen}
            onClose={() => closePanel('export')}
            colors={colors}
          />

          <BookmarkPanel
            isOpen={isBookmarkOpen}
            onClose={() => closePanel('bookmark')}
            currentUrl={getCurrentUrl()}
          />
        </main>
      </div>

      {/* SEO: RICH CONTENT FOOTER */}
      <footer className="seo-content-footer">
        <div className="seo-content-wrapper">
          {/* Main Title */}
          <h1 className="seo-main-title">{seoData.title}</h1>

          {/* Palette Summary */}
          {seoData.traits && (
            <div className="seo-palette-summary">
              <span className="seo-trait">
                {seoData.traits.harmony} harmony
              </span>
              <span className="seo-trait-separator">|</span>
              <span className="seo-trait">
                {seoData.traits.temperature} temperature
              </span>
              <span className="seo-trait-separator">|</span>
              <span className="seo-trait">
                {seoData.traits.saturation} saturation
              </span>
              <span className="seo-trait-separator">|</span>
              <span className="seo-trait">
                {seoData.traits.accessibilityScore} accessibility
              </span>
            </div>
          )}
        <div className="sr-only">
          <div className="seo-related-links" style={{ marginTop: '2rem', borderTop: '1px solid #eee', paddingTop: '1rem' }}>
            <h3 className="seo-section-title">Explore Related Palettes</h3>
            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '10px' }}>
              {/* Generate 6 random links so the bot keeps moving */}
              {Array.from({ length: 6 }).map((_, i) => {
                // Create a random valid URL for the bot to follow
                const randomHexes = generateRandomPalette('auto', 5+Math.random(3), {}).map(h => h.replace('#', ''));
                const url = `/${randomHexes.join('-')}`;
                
                return (
                  <a 
                    key={i} 
                    href={url}
                    style={{ fontSize: '12px', textDecoration: 'underline', color: 'inherit', opacity: 0.7 }}
                  >
                    {/* Give the link a descriptive anchor text, e.g., "Vibrant Blue Palette" */}
                    Generated Palette {i + 1}
                  </a>
                );
              })}
            </div>
          </div>
        </div>       

          {/* Color Values Reference */}
          <div className="seo-color-reference">
            <h2 className="seo-section-title">Color Values</h2>
            <div className="seo-color-grid">
              {colors.map((c, index) => {
                const rgb = hexToRgb(c.hex);
                const hsl = hexToHsl(c.hex);
                return (
                  <div key={c.id} className="seo-color-item">
                    <div
                      className="seo-color-swatch"
                      style={{ backgroundColor: c.hex }}
                    />
                    <div className="seo-color-values">
                      <span className="seo-hex">{c.hex}</span>
                      <span className="seo-rgb">
                        RGB({rgb.r}, {rgb.g}, {rgb.b})
                      </span>
                      <span className="seo-hsl">
                        HSL({Math.round(hsl.h)}, {Math.round(hsl.s)}%, {Math.round(hsl.l)}%)
                      </span>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          {/* Content Sections */}
          <article className="seo-article">
            {contentSections.map((section) => (
              <section key={section.id} className="seo-section">
                {section.hasTitle && (
                  <h2 className="seo-section-title">{section.title}</h2>
                )}
                <p className="seo-section-body">{section.body}</p>
              </section>
            ))}
          </article>

          {/* Keywords for crawlers */}
          {seoData.keywords && seoData.keywords.length > 0 && (
            <div className="seo-keywords">
              <span className="seo-keywords-label">Related searches: </span>
              {seoData.keywords.slice(0, 8).map((keyword, index) => (
                <span key={index} className="seo-keyword">
                  {keyword}
                  {index < Math.min(seoData.keywords.length, 8) - 1 && ', '}
                </span>
              ))}
            </div>
          )}
        </div>
      </footer>
    </div>
  );
}

export default ColorGenerator;
/* =========================================
   FILE: src/colorGenerator/ExportPanel.jsx
   ========================================= */

import { useState } from 'react';
import {
  X,
  Link,
  Code,
  FileCode,
  Image,
  Braces,
  Check,
  Wind,
  ChevronDown,
  Settings2,
} from 'lucide-react';
import { hexToHsl } from '../utils/colorUtils';
import '../styles/PanelStyles.css';
import './ExportPanel.css';

// Naming schemes
const namingSchemes = {
  numbered: (i) => `color-${i + 1}`,
  semantic: (i) =>
    [
      'primary',
      'secondary',
      'tertiary',
      'accent',
      'highlight',
      'muted',
      'subtle',
      'background',
      'surface',
      'border',
    ][i] || `color-${i + 1}`,
  palette: (i) =>
    [
      'base',
      'light',
      'dark',
      'accent-1',
      'accent-2',
      'neutral-1',
      'neutral-2',
      'neutral-3',
      'neutral-4',
      'neutral-5',
    ][i] || `color-${i + 1}`,
};

// Calculate contrast ratio
const getContrastRatio = (hex1, hex2) => {
  const getLuminance = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    const toLinear = (c) =>
      c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    return 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
  };
  const l1 = getLuminance(hex1);
  const l2 = getLuminance(hex2);
  return ((Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05)).toFixed(2);
};

function ExportPanel({
  isOpen,
  onClose,
  colors,
  generationMode,
  constraints,
  colorBlindMode,
}) {
  const [copiedOption, setCopiedOption] = useState(null);
  const [namingScheme, setNamingScheme] = useState('numbered');
  const [showSettings, setShowSettings] = useState(false);
  const [cssFormat, setCssFormat] = useState('vars'); // 'vars' | 'classes'
  const [tailwindFormat, setTailwindFormat] = useState('extend'); // 'extend' | 'layer'

  const showCopied = (option) => {
    setCopiedOption(option);
    setTimeout(() => setCopiedOption(null), 2000);
  };

  const hexColors = colors.map((c) => c.hex);
  const getName = namingSchemes[namingScheme];

  // Generate rich color data
  const getColorData = () => {
    return hexColors.map((hex, i) => {
      const hsl = hexToHsl(hex);
      return {
        name: getName(i),
        hex,
        hsl: {
          h: Math.round(hsl.h),
          s: Math.round(hsl.s),
          l: Math.round(hsl.l),
        },
        hslString: `hsl(${Math.round(hsl.h)}, ${Math.round(
          hsl.s
        )}%, ${Math.round(hsl.l)}%)`,
        contrastOnWhite: getContrastRatio(hex, '#FFFFFF'),
        contrastOnBlack: getContrastRatio(hex, '#000000'),
      };
    });
  };

  const exportOptions = [
    {
      id: 'url',
      icon: Link,
      label: 'URL',
      description: 'Full state link',
      action: () => {
        const url = window.chromaAPI?.getShareUrl() || window.location.href;
        navigator.clipboard.writeText(url);
        const urlObj = new URL(url);
        window.history.replaceState({}, '', urlObj.pathname + urlObj.search);
        showCopied('url');
      },
    },
    {
      id: 'css',
      icon: FileCode,
      label: 'CSS',
      description: cssFormat === 'vars' ? 'CSS Variables' : 'Utility Classes',
      action: () => {
        let css;
        if (cssFormat === 'vars') {
          css = `:root {\n${hexColors
            .map((c, i) => `  --${getName(i)}: ${c};`)
            .join('\n')}\n}`;
        } else {
          css = hexColors
            .map(
              (c, i) =>
                `.bg-${getName(i)} { background-color: ${c}; }\n.text-${getName(
                  i
                )} { color: ${c}; }`
            )
            .join('\n\n');
        }
        navigator.clipboard.writeText(css);
        showCopied('css');
      },
    },
    {
      id: 'tailwind',
      icon: Wind,
      label: 'Tailwind',
      description:
        tailwindFormat === 'extend' ? 'Config extend' : '@layer base',
      action: () => {
        let config;
        if (tailwindFormat === 'extend') {
          config = `// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
${hexColors.map((c, i) => `        '${getName(i)}': '${c}',`).join('\n')}
      },
    },
  },
}`;
        } else {
          config = `/* Add to your CSS */
@layer base {
  :root {
${hexColors.map((c, i) => `    --${getName(i)}: ${c};`).join('\n')}
  }
}

/* tailwind.config.js */
module.exports = {
  theme: {
    extend: {
      colors: {
${hexColors
  .map((c, i) => `        '${getName(i)}': 'var(--${getName(i)})',`)
  .join('\n')}
      },
    },
  },
}`;
        }
        navigator.clipboard.writeText(config);
        showCopied('tailwind');
      },
    },
    {
      id: 'scss',
      icon: Code,
      label: 'SCSS',
      description: 'Variables + Map',
      action: () => {
        const scss = `// Individual variables
${hexColors.map((c, i) => `$${getName(i)}: ${c};`).join('\n')}

// As a map
$palette: (
${hexColors.map((c, i) => `  '${getName(i)}': ${c},`).join('\n')}
);`;
        navigator.clipboard.writeText(scss);
        showCopied('scss');
      },
    },
    {
      id: 'json',
      icon: Braces,
      label: 'JSON',
      description: 'Full metadata',
      action: () => {
        const data = {
          palette: getColorData(),
          settings: {
            harmony: generationMode || 'auto',
            mood: constraints?.mood || 'any',
            minContrast: constraints?.minContrast || 1.5,
            darkModeFriendly: constraints?.darkModeFriendly || false,
          },
          generated: new Date().toISOString(),
        };
        navigator.clipboard.writeText(JSON.stringify(data, null, 2));
        showCopied('json');
      },
    },
    {
      id: 'array',
      icon: Code,
      label: 'JS Object',
      description: 'Named object',
      action: () => {
        const obj = `const palette = {\n${hexColors
          .map((c, i) => `  ${getName(i).replace(/-/g, '_')}: '${c}',`)
          .join('\n')}\n};`;
        navigator.clipboard.writeText(obj);
        showCopied('array');
      },
    },
    {
      id: 'svg',
      icon: FileCode,
      label: 'SVG',
      description: 'Vector graphic',
      action: () => {
        const width = 1200;
        const height = 630; // Social media preview size
        const colorWidth = width / hexColors.length;

        const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}">
  <!-- Background colors -->
${hexColors
  .map(
    (c, i) =>
      `  <rect x="${
        i * colorWidth
      }" y="0" width="${colorWidth}" height="${height}" fill="${c}"/>`
  )
  .join('\n')}
  <!-- Color labels -->
${hexColors
  .map((c, i) => {
    const hsl = hexToHsl(c);
    const textColor = hsl.l > 60 ? '#000000' : '#FFFFFF';
    const x = i * colorWidth + colorWidth / 2;
    return `  <text x="${x}" y="${
      height - 30
    }" text-anchor="middle" fill="${textColor}" font-family="monospace" font-size="14" font-weight="bold">${c}</text>`;
  })
  .join('\n')}
</svg>`;

        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `palette-${Date.now()}.svg`;
        a.click();
        URL.revokeObjectURL(url);
        showCopied('svg');
      },
    },
    {
      id: 'png',
      icon: Image,
      label: 'PNG',
      description: 'Social preview',
      action: () => {
        const canvas = document.createElement('canvas');
        canvas.width = 1200;
        canvas.height = 630; // OG image size
        const ctx = canvas.getContext('2d');
        const colorWidth = canvas.width / hexColors.length;

        // Draw colors
        hexColors.forEach((color, i) => {
          ctx.fillStyle = color;
          ctx.fillRect(i * colorWidth, 0, colorWidth, canvas.height);
        });

        // Draw hex labels
        ctx.font = 'bold 16px monospace';
        ctx.textAlign = 'center';
        hexColors.forEach((color, i) => {
          const hsl = hexToHsl(color);
          ctx.fillStyle = hsl.l > 60 ? '#000000' : '#FFFFFF';
          const x = i * colorWidth + colorWidth / 2;
          ctx.fillText(color, x, canvas.height - 30);
        });

        // Add subtle branding
        ctx.font = '12px sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.textAlign = 'right';
        ctx.fillText(
          'ccolorpalette.com',
          canvas.width - 20,
          canvas.height - 12
        );

        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `palette-${Date.now()}.png`;
          a.click();
          URL.revokeObjectURL(url);
        });
        showCopied('png');
      },
    },
  ];

  return (
    <div
      className={`panel-column ${isOpen ? 'open' : ''}`}
      style={{ flexBasis: isOpen ? '320px' : '0px' }}
    >
      <div className="panel-inner" style={{ width: '320px' }}>
        <div className="panel-header">
          <div className="panel-title">
            <span>Export Palette</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          {/* Settings Toggle */}
          <button
            className={`export-settings-toggle ${showSettings ? 'active' : ''}`}
            onClick={() => setShowSettings(!showSettings)}
          >
            <Settings2 size={16} />
            <span>Export Settings</span>
            <ChevronDown
              size={16}
              className={`chevron ${showSettings ? 'open' : ''}`}
            />
          </button>

          {/* Settings Panel */}
          {showSettings && (
            <div className="export-settings">
              <div className="export-setting">
                <label>Naming Scheme</label>
                <div className="export-setting-options">
                  {Object.keys(namingSchemes).map((scheme) => (
                    <button
                      key={scheme}
                      className={`panel-btn ${
                        namingScheme === scheme ? 'active' : ''
                      }`}
                      onClick={() => setNamingScheme(scheme)}
                    >
                      {scheme.charAt(0).toUpperCase() + scheme.slice(1)}
                    </button>
                  ))}
                </div>
                <span className="export-setting-preview">
                  e.g., {getName(0)}, {getName(1)}
                </span>
              </div>

              <div className="export-setting">
                <label>CSS Format</label>
                <div className="export-setting-options">
                  <button
                    className={`panel-btn ${
                      cssFormat === 'vars' ? 'active' : ''
                    }`}
                    onClick={() => setCssFormat('vars')}
                  >
                    Variables
                  </button>
                  <button
                    className={`panel-btn ${
                      cssFormat === 'classes' ? 'active' : ''
                    }`}
                    onClick={() => setCssFormat('classes')}
                  >
                    Classes
                  </button>
                </div>
              </div>

              <div className="export-setting">
                <label>Tailwind Format</label>
                <div className="export-setting-options">
                  <button
                    className={`panel-btn ${
                      tailwindFormat === 'extend' ? 'active' : ''
                    }`}
                    onClick={() => setTailwindFormat('extend')}
                  >
                    Config Extend
                  </button>
                  <button
                    className={`panel-btn ${
                      tailwindFormat === 'layer' ? 'active' : ''
                    }`}
                    onClick={() => setTailwindFormat('layer')}
                  >
                    @layer + Vars
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Export Grid */}
          <div className="panel-export-grid">
            {exportOptions.map((option) => {
              const Icon = option.icon;
              const isCopied = copiedOption === option.id;

              return (
                <button
                  key={option.id}
                  className={`panel-export-btn ${isCopied ? 'copied' : ''}`}
                  onClick={(e) => {
                    option.action();
                    e.currentTarget.blur();
                  }}
                >
                  <div className="panel-export-btn-icon">
                    {isCopied ? <Check size={24} /> : <Icon size={24} />}
                  </div>
                  <span className="panel-export-btn-label">
                    {isCopied ? 'Done!' : option.label}
                  </span>
                  <span className="panel-export-btn-desc">
                    {option.description}
                  </span>
                </button>
              );
            })}
          </div>

          {/* Preview */}
          <div className="panel-preview">
            <label className="panel-label">Preview</label>
            <div className="panel-preview-colors">
              {hexColors.map((color, i) => (
                <div
                  key={i}
                  className="panel-preview-color"
                  style={{ backgroundColor: color }}
                />
              ))}
            </div>
            <div className="panel-preview-hexes">
              {hexColors.map((color, i) => (
                <span key={i} className="panel-preview-hex">
                  {color.replace('#', '')}
                </span>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default ExportPanel;

/* =========================================
   FILE: src/colorGenerator/HistoryPanel.jsx
   ========================================= */

import { X, Clock } from 'lucide-react';
import '../styles/PanelStyles.css';

function HistoryPanel({
  isOpen,
  onClose,
  history,
  currentIndex,
  onSelectPalette,
}) {
  return (
    <div
      className={`panel-column ${isOpen ? 'open' : ''}`}
      style={{ flexBasis: isOpen ? '260px' : '0px' }}
    >
      <div className="panel-inner" style={{ width: '260px' }}>
        <div className="panel-header">
          <div className="panel-title">
            <Clock size={18} />
            <span>History</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          {history.length === 0 ? (
            <div className="panel-empty">
              <p>No history yet</p>
              <span>Press space to generate palettes</span>
            </div>
          ) : (
            <div className="panel-list" style={{ gap: '10px' }}>
              {[...history].reverse().map((palette, idx) => {
                const actualIndex = history.length - 1 - idx;
                const isCurrent = actualIndex === currentIndex;

                return (
                  <button
                    key={idx}
                    className={`panel-card ${isCurrent ? 'current' : ''}`}
                    onClick={(e) => {
                      onSelectPalette(actualIndex);
                      e.currentTarget.blur();
                    }}
                  >
                    <div
                      className="panel-preview-colors"
                      style={{ height: '40px', borderRadius: '8px' }}
                    >
                      {palette.map((color, colorIdx) => (
                        <div
                          key={colorIdx}
                          className="panel-preview-color"
                          style={{ backgroundColor: color.hex }}
                        />
                      ))}
                    </div>
                  </button>
                );
              })}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

export default HistoryPanel;

/* =========================================
   FILE: src/colorGenerator/MethodPanel.jsx
   ========================================= */

import { X, Sparkles } from 'lucide-react';
import '../styles/PanelStyles.css';

const modes = [
  { id: 'auto', label: 'Auto', description: 'Random harmony' },
  { id: 'mono', label: 'Monochromatic', description: 'Single hue variations' },
  { id: 'analogous', label: 'Analogous', description: 'Adjacent hues' },
  { id: 'complementary', label: 'Complementary', description: 'Opposite hues' },
  {
    id: 'splitComplementary',
    label: 'Split Comp.',
    description: 'Opposite + adjacent',
  },
  { id: 'triadic', label: 'Triadic', description: 'Three-way split' },
];

const moods = [
  { id: 'any', label: 'Any' },
  { id: 'muted', label: 'Muted' },
  { id: 'pastel', label: 'Pastel' },
  { id: 'vibrant', label: 'Vibrant' },
  { id: 'dark', label: 'Dark' },
];

function MethodPanel({
  isOpen,
  onClose,
  value,
  onChange,
  constraints,
  onConstraintsChange,
}) {
  return (
    <div
      className={`panel-column ${isOpen ? 'open' : ''}`}
      style={{ flexBasis: isOpen ? '240px' : '0px' }}
    >
      <div className="panel-inner" style={{ width: '240px' }}>
        <div className="panel-header">
          <div className="panel-title">
            <Sparkles size={18} />
            <span>Method</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          <div className="panel-section">
            <label className="panel-label">Harmony</label>
            <div className="panel-list">
              {modes.map((mode) => (
                <button
                  key={mode.id}
                  className={`panel-list-item ${
                    value === mode.id ? 'selected' : ''
                  }`}
                  onClick={(e) => {
                    onChange(mode.id);
                    e.currentTarget.blur();
                  }}
                >
                  <div className="panel-list-item-content">
                    <span className="panel-list-item-title">{mode.label}</span>
                    <span className="panel-list-item-desc">
                      {mode.description}
                    </span>
                  </div>
                  {value === mode.id && <div className="panel-check" />}
                </button>
              ))}
            </div>
          </div>

          <div className="panel-section">
            <label className="panel-label">Mood</label>
            <div className="panel-btn-grid">
              {moods.map((mood) => (
                <button
                  key={mood.id}
                  className={`panel-btn ${
                    constraints.mood === mood.id ? 'active' : ''
                  }`}
                  onClick={(e) => {
                    onConstraintsChange({ ...constraints, mood: mood.id });
                    e.currentTarget.blur();
                  }}
                >
                  {mood.label}
                </button>
              ))}
            </div>
          </div>

          <div className="panel-section">
            <label className="panel-label">
              Min Adjacent Contrast
              <span>{constraints.minContrast.toFixed(1)}:1</span>
            </label>
            <input
              type="range"
              min="1"
              max="4.5"
              step="0.1"
              value={constraints.minContrast}
              onChange={(e) =>
                onConstraintsChange({
                  ...constraints,
                  minContrast: Number(e.target.value),
                })
              }
              className="panel-slider"
            />
            <div className="panel-slider-labels">
              <span>Low</span>
              <span>High</span>
            </div>
          </div>

          <div className="panel-section">
            <button
              className={`panel-toggle ${
                constraints.darkModeFriendly ? 'active' : ''
              }`}
              onClick={(e) => {
                onConstraintsChange({
                  ...constraints,
                  darkModeFriendly: !constraints.darkModeFriendly,
                });
                e.currentTarget.blur();
              }}
            >
              <span className="panel-toggle-indicator" />
              <span>Dark mode friendly</span>
            </button>
            <p className="panel-hint">
              Ensures colors work well on dark backgrounds
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}

export default MethodPanel;

/* =========================================
   FILE: src/header/Header.jsx
   ========================================= */

import { Link } from 'react-router-dom';
import { 
  Undo2, Redo2, Clock, Upload, Sparkles, Eye, Bookmark, 
  Share 
} from 'lucide-react';
import './Header.css';

function Header({
  isLanding = false,
  canUndo,
  canRedo,
  onUndo,
  onRedo,
  onToggleMethod,
  isMethodOpen,
  onToggleA11y,
  isA11yOpen,
  onToggleHistory,
  isHistoryOpen,
  onToggleExport,
  isExportOpen,
  onToggleBookmark,
  isBookmarkOpen,
  logoColors = [],
}) {
  
  // Static logo colors for landing page
  const displayLogoColors = isLanding 
    ? [{hex: '#0B2B29'}, {hex: '#21A479'}, {hex: '#95D2A6'}] 
    : logoColors;

  return (
    <header className={`header ${isLanding ? 'landing-mode' : ''}`}>
      <div className="leftSection">
        <Link 
          to="/home" 
          className="logoContainer" 
          title="Go to Home"
          style={{ textDecoration: 'none' }}
        >
          <div className="logoMark">
            {displayLogoColors.slice(0, 3).map((color, i) => (
              <span 
                key={i}
                className="logoSwatch" 
                style={{ backgroundColor: color.hex }} 
              />
            ))}
          </div>
          <span className="logoText">CColorPalette</span>
        </Link>
        {!isLanding && <span className="hint">Press spacebar to generate</span>}
      </div>

      <div className="rightSection">
        {isLanding ? (
          /* LANDING PAGE NAVIGATION 
          (add these later): 
            <a href="#start" className="nav-link">Get started</a>
            <a href="#faq" className="nav-link">FAQ</a>
            <a href="#about" className="nav-link">About</a>
                        
            <div className="landing-icons">
              <button className="iconBtn" title="Share">
                <Share size={20} />
              </button>
              <button className="iconBtn" title="Saved">
                <Bookmark size={20} />
              </button>
            </div>
            */
          <div className="landing-nav">
          </div>
        ) : (
          /* GENERATOR TOOLS */
          <>
            <button
              className={`iconBtn ${!canUndo ? 'disabled' : ''}`}
              onClick={onUndo}
              disabled={!canUndo}
              title="Undo (Ctrl+Z)"
            >
              <Undo2 size={20} />
            </button>

            <button
              className={`iconBtn ${!canRedo ? 'disabled' : ''}`}
              onClick={onRedo}
              disabled={!canRedo}
              title="Redo (Ctrl+Y)"
            >
              <Redo2 size={20} />
            </button>

            <div className="separator" />

            <button 
              className={`iconBtn ${isMethodOpen ? 'active' : ''}`}
              onClick={onToggleMethod}
              title="Generation Method"
            >
              <Sparkles size={20} />
            </button>

            <button 
              className={`iconBtn ${isA11yOpen ? 'active' : ''}`}
              onClick={onToggleA11y}
              title="Accessibility"
            >
              <Eye size={20} />
            </button>

            <button 
              className={`iconBtn ${isHistoryOpen ? 'active' : ''}`}
              onClick={onToggleHistory}
              title="History"
            >
              <Clock size={20} />
            </button>

            <button 
              className={`iconBtn ${isExportOpen ? 'active' : ''}`}
              onClick={onToggleExport}
              title="Export"
            >
              <Upload size={20} />
            </button>

            <button 
              className={`iconBtn ${isBookmarkOpen ? 'active' : ''}`}
              onClick={onToggleBookmark}
              title="Bookmark"
            >
              <Bookmark size={20} />
            </button>
          </>
        )}
      </div>
    </header>
  );
}

export default Header;
/* =========================================
   FILE: src/header/ModeDropdown.jsx
   ========================================= */

import { useState, useRef, useEffect } from 'react';
import { SlidersHorizontal } from 'lucide-react';
import './ModeDropdown.css';

const modes = [
  { id: 'auto', label: 'Auto', description: 'Random harmony' },
  { id: 'mono', label: 'Monochromatic', description: 'Single hue' },
  { id: 'analogous', label: 'Analogous', description: 'Adjacent hues' },
  { id: 'complementary', label: 'Complementary', description: 'Opposite hues' },
  {
    id: 'splitComplementary',
    label: 'Split Comp.',
    description: 'Opposite + adjacent',
  },
  { id: 'triadic', label: 'Triadic', description: 'Three-way split' },
];

function ModeDropdown({ value, onChange }) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  const currentMode = modes.find((m) => m.id === value) || modes[0];

  useEffect(() => {
    const handleClickOutside = (e) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
        setIsOpen(false);
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isOpen]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === 'Escape') setIsOpen(false);
    };

    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
    }
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen]);

  const handleSelect = (modeId) => {
    onChange(modeId);
    setIsOpen(false);
  };

  return (
    <div className="modeDropdown" ref={dropdownRef}>
      <button
        className={`modeIconBtn ${isOpen ? 'active' : ''}`}
        onClick={() => setIsOpen(!isOpen)}
        title={`Mode: ${currentMode.label}`}
      >
        <SlidersHorizontal size={20} />
      </button>

      {isOpen && (
        <div className="modeDropdownMenu">
          <div className="modeDropdownHeader">Generate Method</div>
          {modes.map((mode) => {
            const isSelected = mode.id === value;

            return (
              <button
                key={mode.id}
                className={`modeDropdownItem ${isSelected ? 'selected' : ''}`}
                onClick={() => handleSelect(mode.id)}
              >
                <span className="modeLabel">{mode.label}</span>
                <span className="modeDescription">{mode.description}</span>
              </button>
            );
          })}
        </div>
      )}
    </div>
  );
}

export default ModeDropdown;

/* =========================================
   FILE: src/main.jsx
   ========================================= */

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App'; // Import the new App component
import './index.css';    // Keep your global styles

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
/* =========================================
   FILE: src/pages/LandingPage/LandingPage.jsx
   ========================================= */

import React from 'react';
import { useNavigate } from 'react-router-dom';
import Header from '../../header/Header'; 
import heroImage from '../../assets/heroImage.jpg'; 
import './LandingPage.css';

function LandingPage() {
  const navigate = useNavigate();

  return (
    <div className="landing-wrapper">
      {/* 1. Header (Fixed at top) */}
      <Header isLanding={true} />

      {/* 2. Hero Section (Fills remaining height) */}
      <main 
        className="hero-section" 
        style={{ backgroundImage: `url(${heroImage})` }}
      >
        <div className="hero-content">
          <h1 className="hero-title">CcolorPalette</h1>
          
          <p className="hero-subtitle">
            Create beautiful, accessible color schemes with one-click
            <br />
            export to CSS, PNG, SVG, and more.
          </p>

          <div className="hero-buttons">
            <button className="btn-primary" onClick={() => navigate('/')}>
              Open Generator
            </button>
            
            <button className="btn-secondary">
              See how it works (coming soon)
            </button>
          </div>
        </div>
        <div className="feature-section">
          <div className="feature-1-box">
            <div className="feature-1-title-container">
              <div className="feature-1-title">
              </div>
              <div className="feature-1-icon">
              </div>
            </div>
            <div className="feature-1-descripton">

            </div>
          </div>
          <div className="feature-box-2">
          </div>
          <div className="feature-box-3">
          </div>
        </div>
      </main>
    </div>
  );
}

export default LandingPage;
/* =========================================
   FILE: src/utils/colorUtils.js
   ========================================= */

// src/utils/colorUtils.js

// ============================================
// 1. BASIC CONVERTERS & MATH
// ============================================

export const hslToHex = (h, s, l) => {
  l /= 100;
  const a = (s * Math.min(l, 1 - l)) / 100;
  const f = (n) => {
    const k = (n + h / 30) % 12;
    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * color)
      .toString(16)
      .padStart(2, '0');
  };
  return `#${f(0)}${f(8)}${f(4)}`.toUpperCase();
};

export const hexToHsl = (hex) => {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s;
  const l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
      case g: h = ((b - r) / d + 2) / 6; break;
      case b: h = ((r - g) / d + 4) / 6; break;
      default: h = 0;
    }
    h *= 360;
  }

  return { h, s: s * 100, l: l * 100 };
};

const random = (min, max) => Math.random() * (max - min) + min;

// ============================================
// 2. VIBRANCY & HARMONY LOGIC
// ============================================

const adjustForVibrancy = (h, s, l) => {
  let newH = h;
  let newS = s;
  let newL = l;

  // "The Muddy Zone" Fix
  if (h > 35 && h < 100) {
    if (l < 40) {
      newS = Math.max(newS, 45); 
      newL = Math.max(newL, 20); 
    } else if (l > 40 && l < 70) {
      newS = Math.max(newS, 65);
    }
  }

  // "The Toxic Green" Fix
  if (h > 80 && h < 150) {
    if (l > 60) {
      newS = Math.min(newS, 40);
    } else {
      newS = Math.min(newS, 60);
    }
  }

  // "The Cold Gray" Fix
  if (h > 210 && h < 260 && l > 80 && s < 40) {
    newS += 20;
  }

  // Luminance Compensation
  if (h > 50 && h < 70) newL = Math.max(newL, 60);
  if (h > 230 && h < 280) newL = Math.min(newL, 85);

  // Cap extremes
  newS = Math.max(5, Math.min(98, newS));
  newL = Math.max(8, Math.min(96, newL));

  return { h: newH, s: newS, l: newL };
};

const generateHarmoniousHues = (mode, count, constraints) => {
  let base = random(0, 360);
  if (base > 80 && base < 120 && Math.random() > 0.2) {
    base = (base + 100) % 360; 
  }

  const hues = [];
  const jitter = (amount = 15) => random(-amount, amount);

  switch (mode) {
    case 'mono':
      for (let i = 0; i < count; i++) hues.push((base + jitter(5) + 360) % 360);
      break;
    case 'analogous':
      const range = 50; 
      for (let i = 0; i < count; i++) {
        const offset = (i / (count - 1)) * range - (range / 2);
        hues.push((base + offset + jitter(8) + 360) % 360);
      }
      break;
    case 'complementary':
      for (let i = 0; i < count; i++) {
        if (i < 3) hues.push((base + jitter(15) + 360) % 360);
        else hues.push((base + 180 + jitter(15) + 360) % 360);
      }
      break;
    case 'splitComplementary':
    case 'triadic':
      const anchors = mode === 'triadic' ? [0, 120, 240] : [0, 150, 210];
      for (let i = 0; i < count; i++) {
        const anchor = anchors[i % anchors.length];
        hues.push((base + anchor + jitter(10) + 360) % 360);
      }
      break;
    default: 
      for (let i = 0; i < count; i++) hues.push((base + (i * 30) + 360) % 360);
  }
  return hues;
};

const generateCohesiveVariations = (hues, mood, count) => {
  const result = [];
  const strategy = Math.random();
  
  for (let i = 0; i < count; i++) {
    const t = i / (count - 1); 
    let s, l;

    if (mood === 'pastel') s = random(30, 60);
    else if (mood === 'vibrant') s = random(75, 95);
    else if (mood === 'muted') s = random(10, 35);
    else s = 55 + (Math.sin(t * Math.PI) * 15) + random(-10, 10);

    if (mood === 'dark') l = random(12, 35);
    else if (mood === 'pastel') l = random(82, 94);
    else {
      if (strategy < 0.40) l = 15 + (t * 75) + random(-5, 5);
      else if (strategy < 0.80) l = 90 - (t * 75) + random(-5, 5);
      else {
        if (i === 0) l = random(15, 30);
        else if (i === count - 1) l = random(80, 95);
        else l = random(30, 80);
      }
    }
    result.push({ s, l });
  }
  return result;
};

// ============================================
// 3. MAIN PALETTE GENERATOR
// ============================================

export const generateRandomPalette = (mode = 'auto', count = 5, constraints = {}) => {
  let harmonyMode = mode;

  if (mode === 'auto') {
    const roll = Math.random();
    if (roll < 0.40) harmonyMode = 'analogous';      
    else if (roll < 0.65) harmonyMode = 'mono';           
    else if (roll < 0.85) harmonyMode = 'complementary';  
    else if (roll < 0.95) harmonyMode = 'splitComplementary'; 
    else harmonyMode = 'triadic';        
  }

  const hues = generateHarmoniousHues(harmonyMode, count, constraints);
  const slValues = generateCohesiveVariations(hues, constraints.mood || 'any', count);

  let palette = [];
  for (let i = 0; i < count; i++) {
    const h = hues[i];
    let { s, l } = slValues[i];
    const polished = adjustForVibrancy(h, s, l);
    if (constraints.darkModeFriendly && polished.l > 85) polished.l = 85;
    palette.push(hslToHex(polished.h, polished.s, polished.l));
  }

  return optimizeColorOrder(palette);
};

// ============================================
// 4. UTILITIES (Sorting, Contrast, Shades)
// ============================================

const getHueDistance = (h1, h2) => {
  let diff = Math.abs(h1 - h2);
  return diff > 180 ? 360 - diff : diff;
};

const getColorDistance = (c1, c2) => {
  const hDist = getHueDistance(c1.hsl.h, c2.hsl.h);
  const sDist = Math.abs(c1.hsl.s - c2.hsl.s);
  const lDist = Math.abs(c1.hsl.l - c2.hsl.l);
  return Math.sqrt((hDist * hDist) + (sDist * sDist * 0.5) + (lDist * lDist * 0.8));
};

const optimizeColorOrder = (colors) => {
  const colorData = colors.map((hex) => ({ hex, hsl: hexToHsl(hex) }));
  const hues = colorData.map(c => c.hsl.h);
  const hueSpread = Math.max(...hues) - Math.min(...hues);
  
  if (hueSpread < 40) {
    return colorData.sort((a, b) => a.hsl.l - b.hsl.l).map(c => c.hex);
  }

  let current = colorData.reduce((prev, curr) => (curr.hsl.l < prev.hsl.l ? curr : prev));
  const sorted = [current];
  let remaining = colorData.filter(c => c !== current);

  while (remaining.length > 0) {
    let nearest = null;
    let minDist = Infinity;
    for (const candidate of remaining) {
      const dist = getColorDistance(current, candidate);
      if (dist < minDist) {
        minDist = dist;
        nearest = candidate;
      }
    }
    if (nearest) {
      sorted.push(nearest);
      current = nearest;
      remaining = remaining.filter(c => c !== nearest);
    } else break; 
  }
  return sorted.map(c => c.hex);
};

export const getContrastColor = (hex) => {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminance > 0.6 ? '#000000' : '#FFFFFF';
};

export const generateBridgeColor = (colorBefore, colorAfter) => {
  const c1 = hexToHsl(colorBefore);
  const c2 = hexToHsl(colorAfter);
  let diff = c2.h - c1.h;
  if (diff > 180) diff -= 360; 
  if (diff < -180) diff += 360;
  let h = (c1.h + diff * 0.5);
  if (h < 0) h += 360;
  if (h >= 360) h -= 360;
  const s = (c1.s + c2.s) / 2; 
  const l = (c1.l + c2.l) / 2;
  const polished = adjustForVibrancy(h, s, l);
  return hslToHex(polished.h, polished.s, polished.l);
};

export const generateShades = (hex, totalSteps = 20) => {
  const { h, s, l } = hexToHsl(hex);
  const shades = [];
  const maxLight = 98;
  const minLight = 5;
  const currentIndex = Math.round((1 - (l / 100)) * (totalSteps - 1));

  if (currentIndex > 0) {
    const stepSize = (maxLight - l) / currentIndex;
    for (let i = 0; i < currentIndex; i++) {
      const newL = maxLight - (stepSize * i);
      shades.push(hslToHex(h, s, newL));
    }
  }
  shades.push(hex);
  const remainingSteps = totalSteps - 1 - currentIndex;
  if (remainingSteps > 0) {
    const stepSize = (l - minLight) / remainingSteps;
    for (let i = 1; i <= remainingSteps; i++) {
      const newL = l - (stepSize * i);
      shades.push(hslToHex(h, s, newL));
    }
  }
  return shades;
};

const colorBlindnessMatrices = {
  protanopia: [[0.567, 0.433, 0], [0.558, 0.442, 0], [0, 0.242, 0.758]],
  deuteranopia: [[0.625, 0.375, 0], [0.7, 0.3, 0], [0, 0.3, 0.7]],
  tritanopia: [[0.95, 0.05, 0], [0, 0.433, 0.567], [0, 0.475, 0.525]],
  achromatopsia: [[0.299, 0.587, 0.114], [0.299, 0.587, 0.114], [0.299, 0.587, 0.114]],
};

export const simulateColorBlindness = (hex, type) => {
  if (type === 'normal' || !colorBlindnessMatrices[type]) return hex;
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  const matrix = colorBlindnessMatrices[type];
  const newR = Math.round(matrix[0][0] * r + matrix[0][1] * g + matrix[0][2] * b);
  const newG = Math.round(matrix[1][0] * r + matrix[1][1] * g + matrix[1][2] * b);
  const newB = Math.round(matrix[2][0] * r + matrix[2][1] * g + matrix[2][2] * b);
  const clamp = (v) => Math.max(0, Math.min(255, v));
  return `#${clamp(newR).toString(16).padStart(2, '0')}${clamp(newG).toString(16).padStart(2, '0')}${clamp(newB).toString(16).padStart(2, '0')}`.toUpperCase();
};

// ============================================
// 5. DETERMINISTIC SEED SYSTEM
// ============================================

const pseudoRandom = (seedString) => {
  let h = 0xdeadbeef;
  for (let i = 0; i < seedString.length; i++) {
    h = Math.imul(h ^ seedString.charCodeAt(i), 2654435761);
  }
  return ((h ^ h >>> 15) >>> 0) / 4294967296;
};

const createSeededGenerator = (seedString) => {
  let index = 0;
  return () => {
    index++;
    return pseudoRandom(seedString + index.toString());
  };
};

const pickOne = (options, seed) => {
  const index = Math.floor(seed * options.length);
  return options[Math.min(index, options.length - 1)];
};

const pickMultiple = (options, seedGen, count) => {
  const selected = [];
  const available = [...options];
  for (let i = 0; i < Math.min(count, options.length); i++) {
    const idx = Math.floor(seedGen() * available.length);
    selected.push(available.splice(idx, 1)[0]);
  }
  return selected;
};

// ============================================
// 6. COMPREHENSIVE COLOR ANALYSIS
// ============================================

const getDetailedHueInfo = (h) => {
  const hueMap = [
    { range: [0, 10], primary: "red", detailed: "pure red", searchTerms: ["red", "crimson", "scarlet"] },
    { range: [10, 25], primary: "red", detailed: "vermilion", searchTerms: ["red-orange", "vermilion", "tomato"] },
    { range: [25, 40], primary: "orange", detailed: "burnt orange", searchTerms: ["orange", "burnt orange", "rust"] },
    { range: [40, 50], primary: "orange", detailed: "amber", searchTerms: ["amber", "golden orange", "honey"] },
    { range: [50, 60], primary: "yellow", detailed: "golden yellow", searchTerms: ["yellow", "gold", "mustard"] },
    { range: [60, 75], primary: "yellow", detailed: "lemon", searchTerms: ["yellow", "lemon", "citrus"] },
    { range: [75, 90], primary: "green", detailed: "chartreuse", searchTerms: ["lime", "chartreuse", "yellow-green"] },
    { range: [90, 120], primary: "green", detailed: "leaf green", searchTerms: ["green", "grass green", "kelly green"] },
    { range: [120, 150], primary: "green", detailed: "emerald", searchTerms: ["emerald", "forest green", "jade"] },
    { range: [150, 170], primary: "teal", detailed: "teal", searchTerms: ["teal", "turquoise", "aqua"] },
    { range: [170, 195], primary: "cyan", detailed: "cyan", searchTerms: ["cyan", "aqua", "robin egg"] },
    { range: [195, 220], primary: "blue", detailed: "sky blue", searchTerms: ["sky blue", "azure", "cerulean"] },
    { range: [220, 245], primary: "blue", detailed: "cobalt", searchTerms: ["blue", "cobalt", "royal blue"] },
    { range: [245, 265], primary: "blue", detailed: "navy", searchTerms: ["navy", "indigo", "midnight blue"] },
    { range: [265, 285], primary: "purple", detailed: "violet", searchTerms: ["purple", "violet", "grape"] },
    { range: [285, 310], primary: "purple", detailed: "magenta", searchTerms: ["magenta", "fuchsia", "orchid"] },
    { range: [310, 335], primary: "pink", detailed: "rose", searchTerms: ["pink", "rose", "blush"] },
    { range: [335, 360], primary: "red", detailed: "crimson", searchTerms: ["crimson", "ruby", "cherry"] }
  ];
  
  const normalized = ((h % 360) + 360) % 360;
  const match = hueMap.find(entry => normalized >= entry.range[0] && normalized < entry.range[1]);
  return match || hueMap[0];
};

const analyzeColorTemperature = (hsls) => {
  const warmRanges = [[0, 70], [320, 360]];
  const coolRanges = [[170, 280]];
  
  let warmCount = 0;
  let coolCount = 0;
  
  hsls.forEach(({ h }) => {
    const inWarm = warmRanges.some(([min, max]) => h >= min && h < max);
    const inCool = coolRanges.some(([min, max]) => h >= min && h < max);
    if (inWarm) warmCount++;
    if (inCool) coolCount++;
  });
  
  const total = hsls.length;
  if (warmCount > total * 0.6) return { type: "warm", ratio: warmCount / total };
  if (coolCount > total * 0.6) return { type: "cool", ratio: coolCount / total };
  return { type: "balanced", ratio: 0.5 };
};

const calculateContrastRatio = (l1, l2) => {
  const lighter = Math.max(l1, l2) / 100;
  const darker = Math.min(l1, l2) / 100;
  return ((lighter + 0.05) / (darker + 0.05)).toFixed(2);
};

const detectHarmonyType = (hsls) => {
  if (hsls.length < 2) return "single";
  
  const hues = hsls.map(c => c.h);
  const pairs = [];
  
  for (let i = 0; i < hues.length; i++) {
    for (let j = i + 1; j < hues.length; j++) {
      let diff = Math.abs(hues[i] - hues[j]);
      if (diff > 180) diff = 360 - diff;
      pairs.push(diff);
    }
  }
  
  const maxDiff = Math.max(...pairs);
  const avgDiff = pairs.reduce((a, b) => a + b, 0) / pairs.length;
  
  if (maxDiff < 25) return "monochromatic";
  if (maxDiff < 60) return "analogous";
  if (avgDiff > 100 && avgDiff < 140) return "triadic";
  if (maxDiff > 150 && maxDiff < 210) return "complementary";
  if (maxDiff >= 130 && maxDiff <= 170) return "split-complementary";
  return "custom";
};

const getComprehensiveTraits = (hsls) => {
  const avgS = hsls.reduce((a, c) => a + c.s, 0) / hsls.length;
  const avgL = hsls.reduce((a, c) => a + c.l, 0) / hsls.length;
  const maxL = Math.max(...hsls.map(c => c.l));
  const minL = Math.min(...hsls.map(c => c.l));
  const lightnessRange = maxL - minL;
  
  const satStdDev = Math.sqrt(hsls.reduce((a, c) => a + Math.pow(c.s - avgS, 2), 0) / hsls.length);
  const lightStdDev = Math.sqrt(hsls.reduce((a, c) => a + Math.pow(c.l - avgL, 2), 0) / hsls.length);
  
  const dominantHsl = hsls.reduce((prev, curr) => curr.s > prev.s ? curr : prev);
  const hueInfo = getDetailedHueInfo(dominantHsl.h);
  const temperature = analyzeColorTemperature(hsls);
  const harmony = detectHarmonyType(hsls);
  const contrastRatio = calculateContrastRatio(minL, maxL);
  
  return {
    avgS, avgL, maxL, minL, lightnessRange,
    satStdDev, lightStdDev,
    hueInfo, temperature, harmony, contrastRatio,
    
    // Boolean characteristics
    isVibrant: avgS > 65,
    isMuted: avgS < 35,
    isPastel: avgS < 55 && avgL > 72,
    isDark: avgL < 38,
    isLight: avgL > 68,
    isHighContrast: lightnessRange > 55,
    isLowContrast: lightnessRange < 25,
    isUniform: satStdDev < 12 && lightStdDev < 15,
    hasNeutrals: hsls.some(c => c.s < 15),
    
    // Computed scores
    vibrancyScore: Math.round((avgS + lightnessRange) / 2),
    accessibilityScore: lightnessRange > 45 ? "good" : lightnessRange > 30 ? "moderate" : "limited"
  };
};

// ============================================
// 7. SEMANTIC CONTENT DATABASE
// ============================================

const contentDatabase = {
  paletteCharacteristics: {
    vibrant: {
      adjectives: ["vivid", "bold", "striking", "dynamic", "saturated", "intense", "energetic", "punchy"],
      descriptions: [
        "commands attention and creates immediate visual impact",
        "delivers strong chromatic presence for memorable designs",
        "provides maximum color energy for engaging compositions"
      ]
    },
    muted: {
      adjectives: ["subtle", "refined", "understated", "sophisticated", "restrained", "nuanced", "tempered", "gentle"],
      descriptions: [
        "creates refined atmospheres without visual competition",
        "supports content-focused designs where color complements rather than dominates",
        "delivers timeless sophistication through careful desaturation"
      ]
    },
    pastel: {
      adjectives: ["soft", "delicate", "airy", "gentle", "light", "serene", "calming", "ethereal"],
      descriptions: [
        "evokes lightness and approachability in any application",
        "creates welcoming, non-aggressive visual environments",
        "balances color interest with visual gentleness"
      ]
    },
    dark: {
      adjectives: ["deep", "rich", "dramatic", "moody", "luxurious", "intense", "grounded", "substantial"],
      descriptions: [
        "establishes visual weight and dramatic presence",
        "creates depth and sophistication in design compositions",
        "anchors layouts with substantial chromatic foundation"
      ]
    },
    light: {
      adjectives: ["bright", "fresh", "open", "clean", "luminous", "crisp", "airy", "spacious"],
      descriptions: [
        "maximizes perceived space and visual breathing room",
        "supports readability and content clarity",
        "creates inviting, accessible visual environments"
      ]
    },
    warm: {
      adjectives: ["inviting", "cozy", "welcoming", "friendly", "approachable", "comforting", "earthy", "sun-touched"],
      descriptions: [
        "activates emotional warmth and human connection",
        "creates psychologically comfortable environments",
        "supports approachable, personable brand positioning"
      ]
    },
    cool: {
      adjectives: ["calm", "serene", "professional", "trustworthy", "composed", "refreshing", "clean", "tranquil"],
      descriptions: [
        "establishes measured professionalism and trust",
        "creates psychologically calming visual experiences",
        "supports clarity-focused, rational design approaches"
      ]
    }
  },

  harmonyDescriptions: {
    monochromatic: {
      name: "monochromatic",
      explanation: "uses variations of a single hue across different saturation and lightness levels",
      benefits: "ensures automatic color harmony while providing tonal variation for visual hierarchy",
      bestFor: "minimalist designs, text-heavy layouts, and brands seeking cohesive simplicity"
    },
    analogous: {
      name: "analogous",
      explanation: "combines neighboring hues from the color wheel for natural color flow",
      benefits: "creates organic, nature-inspired harmonies that feel intuitive and comfortable",
      bestFor: "environmental design, wellness branding, and compositions requiring visual comfort"
    },
    complementary: {
      name: "complementary",
      explanation: "pairs colors from opposite sides of the color wheel for maximum contrast",
      benefits: "generates visual tension and energy that draws attention to key elements",
      bestFor: "call-to-action designs, sports branding, and high-energy marketing materials"
    },
    triadic: {
      name: "triadic",
      explanation: "uses three colors equally spaced around the color wheel",
      benefits: "provides rich color variety while maintaining structural balance",
      bestFor: "playful brands, children's products, and designs requiring diverse color options"
    },
    "split-complementary": {
      name: "split-complementary",
      explanation: "modifies complementary harmony by using two colors adjacent to the complement",
      benefits: "retains complementary contrast with reduced visual tension",
      bestFor: "balanced designs that need contrast without aggressive color opposition"
    },
    custom: {
      name: "custom",
      explanation: "follows a unique color relationship tailored to specific design requirements",
      benefits: "provides flexibility for specialized applications and distinctive brand identities",
      bestFor: "unique brand positioning and designs requiring non-traditional color approaches"
    }
  },

  industryApplications: {
    webDesign: {
      title: "Web and Digital Interface Design",
      contexts: {
        highContrast: [
          "The substantial lightness range supports WCAG accessibility compliance for body text and interactive elements.",
          "Provides clear visual hierarchy for navigation systems, buttons, and content sections.",
          "Enables effective data visualization where distinct values require clear color differentiation."
        ],
        lowContrast: [
          "Consider reserving pure black or white for text to meet accessibility contrast requirements.",
          "Works well for background layering and subtle UI depth effects.",
          "Suitable for decorative elements where readability is not the primary concern."
        ],
        dark: [
          "Optimized for dark mode interfaces with sufficient tonal separation for layered components.",
          "Reduces eye strain in low-ambient-light environments and extended reading sessions.",
          "Supports immersive experiences for media-focused and entertainment applications."
        ],
        light: [
          "Creates open, breathable layouts for content-dense pages and documentation.",
          "Supports scannable interfaces where information hierarchy drives user flow.",
          "Effective for e-commerce where products need neutral, non-competing backgrounds."
        ],
        vibrant: [
          "Delivers strong brand recognition and memorability in competitive digital spaces.",
          "Commands attention for key conversion elements and promotional content.",
          "Supports engagement-focused designs for social and interactive platforms."
        ],
        muted: [
          "Allows content to take center stage without color distraction.",
          "Supports long-form reading experiences and professional service contexts.",
          "Creates sophisticated backdrops for portfolio and editorial presentations."
        ]
      }
    },
    branding: {
      title: "Brand Identity and Marketing",
      hueAssociations: {
        red: "energy, urgency, passion, and appetite stimulation, commonly deployed in food service, entertainment, retail, and emergency services",
        orange: "friendliness, creativity, affordability, and youthful energy, effective for startups, creative agencies, and value-oriented retail",
        yellow: "optimism, clarity, warmth, and attention-grabbing visibility, suited for hospitality, construction, and caution signaling",
        green: "growth, health, sustainability, wealth, and natural authenticity, standard in finance, healthcare, organic products, and environmental sectors",
        teal: "sophistication, clarity, and balanced professionalism, popular in healthcare technology and modern corporate identities",
        cyan: "innovation, cleanliness, and technological advancement, common in tech startups and medical device companies",
        blue: "reliability, trustworthiness, competence, and stability, dominant across corporate, finance, technology, and healthcare sectors",
        purple: "creativity, luxury, wisdom, and imagination, used in beauty, education, wellness, and premium product positioning",
        pink: "nurturing, approachability, playfulness, and compassion, effective in health, beauty, confectionery, and youth marketing"
      },
      saturationImpact: {
        high: "High saturation creates memorable brand recognition and works effectively for digital-first companies competing for attention in crowded markets.",
        low: "Reduced saturation projects maturity, trustworthiness, and sophistication, appropriate for professional services, luxury positioning, and heritage brands."
      }
    },
    interiorDesign: {
      title: "Interior Design and Architecture",
      temperatureContexts: {
        warm: [
          "Creates intimate, inviting atmospheres in residential living spaces, restaurants, and hospitality environments.",
          "Compensates for north-facing rooms with limited natural warmth.",
          "Supports social spaces where conversation and connection are priorities."
        ],
        cool: [
          "Provides visual relief in south-facing rooms with abundant direct sunlight.",
          "Creates calming environments appropriate for bedrooms, bathrooms, spas, and healthcare facilities.",
          "Supports focused work environments in offices and study spaces."
        ],
        balanced: [
          "Offers flexibility across different lighting conditions and room orientations.",
          "Adapts well to spaces with mixed natural and artificial light sources.",
          "Supports transitional spaces that serve multiple functions throughout the day."
        ]
      },
      lightnessContexts: {
        light: [
          "Maximizes perceived space in compact rooms and apartments.",
          "Reflects available light to brighten rooms with limited windows.",
          "Creates gallery-like backdrops for art and object display."
        ],
        dark: [
          "Adds drama and intimacy to feature walls, libraries, and entertainment rooms.",
          "Grounds open-plan spaces when applied strategically to architectural elements.",
          "Works on ceilings in rooms with generous height and natural light."
        ]
      }
    },
    digitalArt: {
      title: "Digital Art and Illustration",
      contexts: {
        highContrast: [
          "Supports clear focal point establishment and compositional hierarchy.",
          "Enables effective foreground-background separation in complex illustrations.",
          "Provides the value range needed for dramatic lighting effects."
        ],
        analogous: [
          "Creates cohesive color scripts for animation and sequential narrative art.",
          "Natural choice for landscape and environmental concept art with atmospheric depth.",
          "Supports mood consistency across multi-scene storyboarding."
        ],
        monochromatic: [
          "Ideal for value studies and establishing lighting before introducing color complexity.",
          "Effective for noir and limited-palette stylistic approaches.",
          "Supports focused mood development in conceptual work."
        ],
        vibrant: [
          "Commands attention in thumbnail compositions for portfolio presentation.",
          "Supports stylized and cel-shaded illustration techniques.",
          "Effective for character design requiring distinctive, memorable palettes."
        ]
      }
    },
    fashion: {
      title: "Fashion and Textile Design",
      temperatureGuidance: {
        warm: [
          "Complements warm skin undertones and autumn seasonal color analysis profiles.",
          "Pairs naturally with gold jewelry, brass hardware, and brown leather.",
          "Photographs well under incandescent and warm-filtered lighting."
        ],
        cool: [
          "Complements cool skin undertones and winter seasonal color analysis profiles.",
          "Pairs naturally with silver jewelry, chrome hardware, and black leather.",
          "Photographs well under daylight and cool-filtered studio lighting."
        ]
      },
      practicalNotes: [
        "The tonal range supports outfit building from statement pieces to coordinating layers.",
        "Enables capsule wardrobe planning with interchangeable color combinations.",
        "Consider fabric type when evaluating colors, as material affects appearance under different lighting."
      ]
    },
    print: {
      title: "Print Production",
      contexts: {
        vibrant: [
          "High saturation values may shift during RGB-to-CMYK conversion; request press proofs for critical brand colors.",
          "Consider Pantone spot color matching for consistent reproduction across print vendors and materials.",
          "Allow for paper absorption differences between coated and uncoated stocks."
        ],
        muted: [
          "Desaturated values reproduce more predictably across different paper stocks and printing methods.",
          "Performs well on uncoated and textured stocks where highly saturated inks may absorb unevenly.",
          "Reduces registration sensitivity for multi-color process printing."
        ],
        general: [
          "Verify sufficient tonal separation for clear reproduction in grayscale printing scenarios.",
          "Test on target paper stock, as substrate color temperature affects final appearance.",
          "Consider environmental factors like lighting conditions where printed materials will be viewed."
        ]
      }
    },
    photography: {
      title: "Photography and Color Grading",
      contexts: {
        dark: [
          "Provides foundation for moody editorial photography and cinematic color grading.",
          "Supports low-key lighting setups and dramatic portrait work.",
          "Effective reference for shadow color in controlled studio environments."
        ],
        light: [
          "Suited for high-key photography and bright editorial aesthetics.",
          "Supports clean product photography requiring neutral, airy backgrounds.",
          "Provides reference for highlight and fill light coloring."
        ],
        general: [
          "Informs preset development for batch processing in Lightroom, Capture One, or DaVinci Resolve.",
          "Provides reference for gel selection in studio lighting setups.",
          "Guides color harmony decisions for styled shoots and art direction."
        ]
      }
    },
    accessibility: {
      title: "Accessibility Considerations",
      contrastGuidance: {
        high: [
          "The contrast range supports WCAG 2.1 Level AA requirements for normal body text at 4.5:1 minimum.",
          "Provides sufficient luminance differentiation for users with contrast sensitivity conditions.",
          "Enables clear visual hierarchy for screen reader users who may also have partial vision."
        ],
        low: [
          "Additional contrast enhancement needed for text applications to meet WCAG guidelines.",
          "Reserve highest and lowest lightness values for critical text and interactive elements.",
          "Consider using pure black or white for text overlays to ensure adequate readability."
        ]
      },
      colorBlindnessNotes: {
        redGreen: "Red and green combinations should be validated with deuteranopia and protanopia simulation tools. Add pattern, texture, or label differentiation for color-coded information.",
        blueYellow: "Blue and yellow combinations should be tested with tritanopia simulation, though this affects a smaller percentage of users.",
        general: "Ensure color is never the sole means of conveying critical information. Provide redundant cues through icons, patterns, or text labels."
      }
    }
  }
};

// ============================================
// 8. CONTENT GENERATION FUNCTIONS
// ============================================

const generateTitle = (traits, colorCount, seedGen) => {
  const hue = traits.hueInfo.primary;
  const detailed = traits.hueInfo.detailed;
  const harmony = traits.harmony;
  
  const templates = [];
  
  // Characteristic-based templates
  if (traits.isVibrant) {
    templates.push(
      `${colorCount}-Color ${capitalize(hue)} Palette with Bold Saturation`,
      `Vibrant ${capitalize(detailed)} Color Scheme for Design Projects`,
      `High-Energy ${capitalize(hue)} Palette: ${colorCount} Coordinated Colors`
    );
  }
  
  if (traits.isMuted) {
    templates.push(
      `Muted ${capitalize(hue)} Palette: ${colorCount} Sophisticated Tones`,
      `Subtle ${capitalize(detailed)} Color Scheme for Refined Design`,
      `${colorCount}-Color Desaturated ${capitalize(hue)} Palette`
    );
  }
  
  if (traits.isPastel) {
    templates.push(
      `Soft Pastel ${capitalize(hue)} Palette: ${colorCount} Light Tones`,
      `Gentle ${capitalize(detailed)} Color Scheme for Delicate Design`,
      `${colorCount}-Color Light ${capitalize(hue)} Pastel Collection`
    );
  }
  
  if (traits.isDark) {
    templates.push(
      `Deep ${capitalize(hue)} Palette: ${colorCount} Rich Dark Tones`,
      `Dramatic ${capitalize(detailed)} Color Scheme for Bold Design`,
      `${colorCount}-Color Dark ${capitalize(hue)} Collection`
    );
  }
  
  // Harmony-based templates
  if (harmony === "monochromatic") {
    templates.push(
      `Monochromatic ${capitalize(hue)} Palette: ${colorCount} Tonal Variations`,
      `Single-Hue ${capitalize(detailed)} Color System`
    );
  }
  
  if (harmony === "analogous") {
    templates.push(
      `Analogous ${capitalize(hue)} Color Harmony: ${colorCount} Adjacent Hues`,
      `Harmonious ${capitalize(detailed)} Gradient Palette`
    );
  }
  
  if (harmony === "complementary") {
    templates.push(
      `Complementary ${capitalize(hue)} Color Scheme: ${colorCount} Contrasting Tones`,
      `High-Contrast ${capitalize(detailed)} Palette`
    );
  }
  
  // General fallbacks
  templates.push(
    `${capitalize(detailed)} Color Palette: ${colorCount} Curated Shades`,
    `${colorCount}-Color ${capitalize(hue)} Scheme for Creative Projects`,
    `Professional ${capitalize(hue)} Palette: ${colorCount} Coordinated Colors`
  );
  
  return pickOne(templates, seedGen());
};

const generateMetaDescription = (traits, colorCount, seedGen) => {
  const hue = traits.hueInfo.primary;
  const harmony = contentDatabase.harmonyDescriptions[traits.harmony]?.name || "custom";
  
  const templates = [];
  
  if (traits.isVibrant) {
    templates.push(
      `A ${colorCount}-color ${hue} palette with bold saturation levels. Includes hex codes optimized for web design, branding, and digital illustration projects.`,
      `Vibrant ${hue} color scheme featuring ${colorCount} coordinated shades. Ready for UI design, brand identity, and creative applications with full hex values.`
    );
  }
  
  if (traits.isMuted) {
    templates.push(
      `Refined ${colorCount}-color ${hue} palette with sophisticated muted tones. Hex codes included for professional design, editorial work, and understated branding.`,
      `A subtle ${hue} color scheme with ${colorCount} desaturated shades. Suitable for elegant design projects and mature brand applications.`
    );
  }
  
  if (traits.isPastel) {
    templates.push(
      `Soft pastel ${hue} palette with ${colorCount} gentle, light tones. Ideal for wellness branding, feminine design, and approachable digital experiences.`,
      `Delicate ${colorCount}-color ${hue} scheme with airy pastel values. Hex codes ready for web, print, and interior design applications.`
    );
  }
  
  if (traits.isDark) {
    templates.push(
      `Deep ${hue} color palette featuring ${colorCount} rich dark values. Optimized for dramatic branding, dark mode interfaces, and premium design work.`,
      `A ${colorCount}-color dark ${hue} scheme with substantial depth. Includes hex codes for sophisticated web interfaces and luxury brand applications.`
    );
  }
  
  // Harmony-based
  templates.push(
    `A ${harmony} ${hue} palette with ${colorCount} colors. Export hex, RGB, and HSL values for web design, branding, and creative projects.`,
    `Curated ${hue} color scheme featuring ${colorCount} ${harmony} shades. Professional palette with accessibility considerations and export options.`
  );
  
  return pickOne(templates, seedGen());
};

const generateOpeningParagraph = (traits, colorCount, seedGen) => {
  const charType = traits.isVibrant ? 'vibrant' : 
                   traits.isMuted ? 'muted' : 
                   traits.isPastel ? 'pastel' :
                   traits.isDark ? 'dark' :
                   traits.isLight ? 'light' :
                   traits.temperature.type === 'warm' ? 'warm' : 
                   traits.temperature.type === 'cool' ? 'cool' : 'muted';
  
  const charData = contentDatabase.paletteCharacteristics[charType];
  const adjective = pickOne(charData.adjectives, seedGen());
  const description = pickOne(charData.descriptions, seedGen());
  const harmonyData = contentDatabase.harmonyDescriptions[traits.harmony];
  
  const openings = [
    `This ${adjective} color palette presents ${colorCount} coordinated ${traits.hueInfo.primary} tones that ${description}.`,
    `Featuring ${colorCount} carefully selected ${traits.hueInfo.detailed} shades, this ${adjective} palette ${description}.`,
    `A ${adjective} collection of ${colorCount} ${traits.hueInfo.primary}-based colors that ${description}.`
  ];
  
  const opening = pickOne(openings, seedGen());
  
  const harmonyExplanation = `The palette ${harmonyData.explanation}, which ${harmonyData.benefits}. This harmony type is ${harmonyData.bestFor}.`;
  
  return `${opening}\n\n${harmonyExplanation}`;
};

const generateIndustrySection = (sectionKey, traits, seedGen) => {
  const section = contentDatabase.industryApplications[sectionKey];
  if (!section) return null;
  
  let content = `${section.title}: `;
  const contexts = [];
  
  switch (sectionKey) {
    case 'webDesign': {
      if (traits.isHighContrast) {
        contexts.push(...pickMultiple(section.contexts.highContrast, seedGen, 2));
      } else if (traits.isLowContrast) {
        contexts.push(...pickMultiple(section.contexts.lowContrast, seedGen, 2));
      }
      
      if (traits.isDark) {
        contexts.push(pickOne(section.contexts.dark, seedGen()));
      } else if (traits.isLight) {
        contexts.push(pickOne(section.contexts.light, seedGen()));
      }
      
      if (traits.isVibrant) {
        contexts.push(pickOne(section.contexts.vibrant, seedGen()));
      } else if (traits.isMuted) {
        contexts.push(pickOne(section.contexts.muted, seedGen()));
      }
      break;
    }
    
    case 'branding': {
      const hue = traits.hueInfo.primary;
      const hueAssoc = section.hueAssociations[hue];
      if (hueAssoc) {
        contexts.push(`${capitalize(hue)} communicates ${hueAssoc}.`);
      }
      
      const satImpact = traits.isVibrant ? section.saturationImpact.high : section.saturationImpact.low;
      contexts.push(satImpact);
      break;
    }
    
    case 'interiorDesign': {
      const tempContexts = section.temperatureContexts[traits.temperature.type] || section.temperatureContexts.balanced;
      contexts.push(pickOne(tempContexts, seedGen()));
      
      if (traits.isLight) {
        contexts.push(pickOne(section.lightnessContexts.light, seedGen()));
      } else if (traits.isDark) {
        contexts.push(pickOne(section.lightnessContexts.dark, seedGen()));
      }
      break;
    }
    
    case 'digitalArt': {
      if (traits.isHighContrast) {
        contexts.push(pickOne(section.contexts.highContrast, seedGen()));
      }
      
      if (traits.harmony === 'analogous') {
        contexts.push(pickOne(section.contexts.analogous, seedGen()));
      } else if (traits.harmony === 'monochromatic') {
        contexts.push(pickOne(section.contexts.monochromatic, seedGen()));
      }
      
      if (traits.isVibrant) {
        contexts.push(pickOne(section.contexts.vibrant, seedGen()));
      }
      break;
    }
    
    case 'fashion': {
      const tempGuidance = section.temperatureGuidance[traits.temperature.type] || section.temperatureGuidance.warm;
      contexts.push(pickOne(tempGuidance, seedGen()));
      contexts.push(pickOne(section.practicalNotes, seedGen()));
      break;
    }
    
    case 'print': {
      if (traits.isVibrant) {
        contexts.push(pickOne(section.contexts.vibrant, seedGen()));
      } else if (traits.isMuted) {
        contexts.push(pickOne(section.contexts.muted, seedGen()));
      }
      contexts.push(pickOne(section.contexts.general, seedGen()));
      break;
    }
    
    case 'photography': {
      if (traits.isDark) {
        contexts.push(pickOne(section.contexts.dark, seedGen()));
      } else if (traits.isLight) {
        contexts.push(pickOne(section.contexts.light, seedGen()));
      }
      contexts.push(pickOne(section.contexts.general, seedGen()));
      break;
    }
    
    case 'accessibility': {
      if (traits.isHighContrast) {
        contexts.push(pickOne(section.contrastGuidance.high, seedGen()));
      } else {
        contexts.push(pickOne(section.contrastGuidance.low, seedGen()));
      }
      
      const hue = traits.hueInfo.primary;
      if (hue === 'red' || hue === 'green') {
        contexts.push(section.colorBlindnessNotes.redGreen);
      } else {
        contexts.push(section.colorBlindnessNotes.general);
      }
      break;
    }
  }
  
  return contexts.length > 0 ? content + contexts.join(' ') : null;
};

const generateTechnicalSpecs = (colors, traits) => {
  const specs = [
    `Palette Size: ${colors.length} colors`,
    `Primary Hue: ${Math.round(traits.hueInfo.detailed === traits.hueInfo.primary ? hexToHsl(colors[0]).h : hexToHsl(colors[0]).h)} degrees`,
    `Color Harmony: ${traits.harmony}`,
    `Saturation Range: ${Math.round(traits.avgS)}% average`,
    `Lightness Range: ${Math.round(traits.minL)}% to ${Math.round(traits.maxL)}%`,
    `Contrast Ratio: ${traits.contrastRatio}:1`,
    `Temperature: ${traits.temperature.type}`,
    `Accessibility Rating: ${traits.accessibilityScore} contrast separation`
  ];
  
  return `Technical Specifications: ${specs.join('. ')}.`;
};

const generateExportInfo = () => {
  return `Format Availability: This palette exports to HEX, RGB, HSL, OKLCH, and CMYK formats. CSS custom properties, Tailwind configuration, and design token formats support systematic implementation across development workflows and design tools.`;
};

const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : '';

// ============================================
// 9. KEYWORD GENERATION
// ============================================

const generateKeywords = (traits, colorCount) => {
  const hue = traits.hueInfo.primary;
  const detailed = traits.hueInfo.detailed;
  const keywords = [];
  
  // Primary search terms
  keywords.push(`${hue} color palette`);
  keywords.push(`${hue} color scheme`);
  keywords.push(`${colorCount} color palette`);
  keywords.push(`${hue} hex codes`);
  
  // Characteristic-based
  if (traits.isVibrant) {
    keywords.push(`vibrant ${hue} palette`, `bold ${hue} colors`, `saturated ${hue} scheme`);
  }
  if (traits.isMuted) {
    keywords.push(`muted ${hue} palette`, `subtle ${hue} colors`, `desaturated ${hue} scheme`);
  }
  if (traits.isPastel) {
    keywords.push(`pastel ${hue} palette`, `soft ${hue} colors`, `light ${hue} scheme`);
  }
  if (traits.isDark) {
    keywords.push(`dark ${hue} palette`, `deep ${hue} colors`, `moody ${hue} scheme`);
  }
  
  // Harmony-based
  keywords.push(`${traits.harmony} color palette`, `${traits.harmony} ${hue} colors`);
  
  // Application-based
  keywords.push(`${hue} web design colors`, `${hue} branding palette`, `${hue} ui colors`);
  keywords.push(`${hue} interior design`, `${hue} graphic design`);
  
  // Detailed hue variations
  if (detailed !== hue) {
    keywords.push(`${detailed} color palette`, `${detailed} color scheme`);
  }
  
  return keywords;
};

// ============================================
// 10. MAIN SEO GENERATOR
// ============================================

export const generateRichSEO = (colors, mode = 'auto', mood = 'any') => {
  if (!colors || colors.length === 0) {
    return { title: "", meta: "", content: "", keywords: [], traits: null };
  }

  const hsls = colors.map(hexToHsl);
  const traits = getComprehensiveTraits(hsls);
  const seedString = colors.join('');
  const seedGen = createSeededGenerator(seedString);
  const colorCount = colors.length;
  
  // Generate core SEO elements
  const title = generateTitle(traits, colorCount, seedGen);
  const meta = generateMetaDescription(traits, colorCount, seedGen);
  
  // Build content sections
  const contentSections = [];
  
  // Opening paragraph with harmony explanation
  contentSections.push(generateOpeningParagraph(traits, colorCount, seedGen));
  
  // Industry application sections
  const industries = ['webDesign', 'branding', 'interiorDesign', 'digitalArt', 'fashion', 'print', 'photography', 'accessibility'];
  
  industries.forEach(industry => {
    const section = generateIndustrySection(industry, traits, seedGen);
    if (section) {
      contentSections.push(section);
    }
  });
  
  // Technical specifications
  contentSections.push(generateTechnicalSpecs(colors, traits));
  
  // Export information
  contentSections.push(generateExportInfo());
  
  // Generate keywords
  const keywords = generateKeywords(traits, colorCount);
  
  return {
    title,
    meta,
    content: contentSections.join('\n\n'),
    keywords,
    traits: {
      harmony: traits.harmony,
      temperature: traits.temperature.type,
      saturation: traits.isVibrant ? 'vibrant' : traits.isMuted ? 'muted' : 'moderate',
      lightness: traits.isDark ? 'dark' : traits.isLight ? 'light' : traits.isPastel ? 'pastel' : 'balanced',
      primaryHue: traits.hueInfo.primary,
      detailedHue: traits.hueInfo.detailed,
      contrastRatio: traits.contrastRatio,
      accessibilityScore: traits.accessibilityScore
    }
  };
};