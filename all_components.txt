
/* =========================================
   FILE: src/App.jsx
   ========================================= */

import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { HelmetProvider } from 'react-helmet-async';

import ColorGenerator from './colorGenerator/ColorGenerator';
import LandingPage from './pages/LandingPage/LandingPage';
import PrivacyPolicy from './pages/Legal/PrivacyPolicy';
import TermsOfService from './pages/Legal/TermsOfService';
import ExplorePage from './pages/Explore/ExplorePage';
import ScrollToTop from './components/ScrollToTop';

function App() {
  return (
    <HelmetProvider>
      <Router>
        <ScrollToTop />
        <Routes>
          {/* Specific routes FIRST */}
          <Route path="/home" element={<LandingPage />} />
          <Route path="/explore" element={<ExplorePage />} />
          <Route path="/privacy" element={<PrivacyPolicy />} />
          <Route path="/terms" element={<TermsOfService />} />
          
          {/* Catch-all palette route LAST */}
          <Route path="/:hexCodes" element={<ColorGenerator />} />
          <Route path="/" element={<ColorGenerator />} />
        </Routes>
      </Router>
    </HelmetProvider>
  );
}

export default App;
/* =========================================
   FILE: src/colorGenerator/AccessibilityPanel.jsx
   ========================================= */

import { X, Eye, Check, AlertTriangle } from 'lucide-react';
import '../styles/PanelStyles.css';
import { trackEvent } from '../utils/analytics';

const PANEL_WIDTH = 280;

const COLOR_BLIND_MODES = [
  { id: 'normal', label: 'Normal Vision' },
  { id: 'protanopia', label: 'Protanopia', desc: 'Red-blind' },
  { id: 'deuteranopia', label: 'Deuteranopia', desc: 'Green-blind' },
  { id: 'tritanopia', label: 'Tritanopia', desc: 'Blue-blind' },
  { id: 'achromatopsia', label: 'Achromatopsia', desc: 'Monochrome' },
];

const getLuminance = (hex) => {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;
  const toLinear = (c) => c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  return 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
};

const getContrastRatio = (hex1, hex2) => {
  const l1 = getLuminance(hex1);
  const l2 = getLuminance(hex2);
  return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
};

const getWCAGRating = (ratio) => {
  if (ratio >= 7) return { level: 'AAA', pass: true };
  if (ratio >= 4.5) return { level: 'AA', pass: true };
  if (ratio >= 3) return { level: 'AA+', pass: true };
  return { level: 'Fail', pass: false };
};

function AccessibilityPanel({
  isOpen,
  onClose,
  colors,
  colorBlindMode,
  onColorBlindModeChange,
}) {
  return (
    <div
      className={`panel-column ${isOpen ? 'open' : ''}`}
      style={{ flexBasis: isOpen ? `${PANEL_WIDTH}px` : '0px' }}
    >
      <div className="panel-inner" style={{ width: `${PANEL_WIDTH}px` }}>
        <div className="panel-header">
          <div className="panel-title">
            <Eye size={18} />
            <span>Accessibility</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          {/* Vision Simulation */}
          <div className="panel-section">
            <label className="panel-label">Vision Simulation</label>
            <div className="panel-list">
              {COLOR_BLIND_MODES.map((mode) => (
                <button
                  key={mode.id}
                  className={`panel-list-item ${colorBlindMode === mode.id ? 'selected' : ''}`}
                  onClick={(e) => {
                    trackEvent('view_vision_simulation', { mode: mode.id });
                    onColorBlindModeChange(mode.id);
                    e.currentTarget.blur();
                  }}
                >
                  <div className="panel-list-item-content">
                    <span className="panel-list-item-title">{mode.label}</span>
                    {mode.desc && <span className="panel-list-item-desc">{mode.desc}</span>}
                  </div>
                  {colorBlindMode === mode.id && <div className="panel-check" />}
                </button>
              ))}
            </div>
          </div>

          {/* Text Contrast */}
          <div className="panel-section">
            <label className="panel-label">Text Contrast</label>
            <div className="panel-contrast-grid">
              {colors.map((color) => {
                const whiteRatio = getContrastRatio(color.hex, '#FFFFFF');
                const blackRatio = getContrastRatio(color.hex, '#000000');
                const bestColor = whiteRatio > blackRatio ? '#FFFFFF' : '#000000';
                const bestRatio = Math.max(whiteRatio, blackRatio);
                const rating = getWCAGRating(bestRatio);

                return (
                  <div 
                    key={color.id} 
                    className="panel-contrast-card"
                    style={{ backgroundColor: color.hex, color: bestColor }}
                  >
                    <div className="contrast-card-header">
                      <span className="contrast-aa">Aa</span>
                      <span className="contrast-badge">{rating.level}</span>
                    </div>
                    <div className="contrast-card-footer">
                      <span className="contrast-hex">{color.hex}</span>
                      <span className="contrast-ratio">{bestRatio.toFixed(1)}:1</span>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          {/* Adjacent Contrast */}
          <div className="panel-section">
            <label className="panel-label">Adjacent Contrast</label>
            <div className="panel-list">
              {colors.slice(0, -1).map((color, i) => {
                const nextColor = colors[i + 1];
                const ratio = getContrastRatio(color.hex, nextColor.hex);
                
                let status = 'fail';
                let Icon = X;
                if (ratio >= 3) { status = 'pass'; Icon = Check; }
                else if (ratio >= 1.6) { status = 'warn'; Icon = AlertTriangle; }

                return (
                  <div key={color.id} className="panel-adjacent-row">
                    <div className="panel-adjacent-pill">
                      <div style={{ backgroundColor: color.hex }} />
                      <div style={{ backgroundColor: nextColor.hex }} />
                    </div>
                    <div className="panel-adjacent-info">
                      <span className="adjacent-ratio">{ratio.toFixed(1)}:1</span>
                      <div className={`adjacent-status ${status}`}>
                        <Icon size={10} strokeWidth={3} />
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default AccessibilityPanel;
/* =========================================
   FILE: src/colorGenerator/BookmarkPanel.jsx
   ========================================= */

import { useState } from 'react';
import { X, Bookmark, Star, Copy, Check } from 'lucide-react';
import '../styles/PanelStyles.css';
import './BookmarkPanel.css';

const PANEL_WIDTH = 280;

function BookmarkPanel({ isOpen, onClose, currentUrl }) {
  const [copied, setCopied] = useState(false);

  const isMac = typeof navigator !== 'undefined' && 
    navigator.platform.toUpperCase().indexOf('MAC') >= 0;

  const handleCopyUrl = async () => {
    try {
      await navigator.clipboard.writeText(currentUrl);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  return (
    <div
      className={`panel-column ${isOpen ? 'open' : ''}`}
      style={{ flexBasis: isOpen ? `${PANEL_WIDTH}px` : '0px' }}
    >
      <div className="panel-inner" style={{ width: `${PANEL_WIDTH}px` }}>
        <div className="panel-header">
          <div className="panel-title">
            <Bookmark size={18} />
            <span>Bookmark</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          {/* Main Card */}
          <div className="bookmark-hero">
            <div className="bookmark-icon">
              <Star size={28} />
            </div>
            <h3>Save this palette</h3>
            <p>Bookmark this page to access your colors anytime.</p>
          </div>

          {/* Keyboard Shortcut */}
          <div className="panel-section">
            <label className="panel-label">Keyboard Shortcut</label>
            <div className="bookmark-shortcut">
              <div className="bookmark-keys">
                <kbd>{isMac ? '⌘' : 'Ctrl'}</kbd>
                <span>+</span>
                <kbd>D</kbd>
              </div>
              <span className="bookmark-shortcut-hint">Add to bookmarks</span>
            </div>
          </div>

          {/* URL */}
          <div className="panel-section">
            <label className="panel-label">Palette URL</label>
            <div className="bookmark-url-row">
              <code className="bookmark-url">{currentUrl}</code>
              <button
                className={`bookmark-copy ${copied ? 'copied' : ''}`}
                onClick={handleCopyUrl}
              >
                {copied ? <Check size={14} /> : <Copy size={14} />}
              </button>
            </div>
            <p className="panel-hint">Share or bookmark this unique URL!</p>
          </div>

          {/* Steps */}
          <div className="panel-section">
            <label className="panel-label">Or manually</label>
            <div className="bookmark-steps">
              <div className="bookmark-step">
                <span className="bookmark-step-num">1</span>
                <span>Click the star in your address bar</span>
              </div>
              <div className="bookmark-step">
                <span className="bookmark-step-num">2</span>
                <span>Choose a folder and save</span>
              </div>
              <div className="bookmark-step">
                <span className="bookmark-step-num">3</span>
                <span>Access anytime from bookmarks</span>
              </div>
            </div>
          </div>

          {/* Tip */}
          <div className="bookmark-tip">
            <strong>Pro tip:</strong> Each palette has a unique URL! Generate one you love, then bookmark it!
          </div>
        </div>
      </div>
    </div>
  );
}

export default BookmarkPanel;
/* =========================================
   FILE: src/colorGenerator/ColorEditorPanel.jsx
   ========================================= */

import { useState, useEffect } from 'react';
import { X, Sun, Moon, Flame, Snowflake, Pipette } from 'lucide-react';
import { hexToHsl, hslToHex } from '../utils/colorUtils';
import './ColorEditorPanel.css';

const PANEL_WIDTH = 280;

const ADJUSTMENTS = [
  { icon: Sun, label: 'Lighter', adjust: (hsl) => ({ ...hsl, l: hsl.l + 10 }) },
  { icon: Moon, label: 'Darker', adjust: (hsl) => ({ ...hsl, l: hsl.l - 10 }) },
  { icon: Flame, label: 'Warmer', adjust: (hsl) => ({ ...hsl, h: hsl.h - 15 }) },
  { icon: Snowflake, label: 'Cooler', adjust: (hsl) => ({ ...hsl, h: hsl.h + 15 }) },
  { icon: Pipette, label: 'Saturate', adjust: (hsl) => ({ ...hsl, s: hsl.s + 15 }) },
];

function ColorEditorPanel({ isOpen, onClose, color, onColorChange }) {
  const [hsl, setHsl] = useState({ h: 0, s: 50, l: 50 });
  const [hexInput, setHexInput] = useState('');

  useEffect(() => {
    if (color?.hex) {
      const converted = hexToHsl(color.hex);
      setHsl(converted);
      setHexInput(color.hex.replace('#', ''));
    }
  }, [color?.hex]);

  const updateColor = (newHsl) => {
    const clamped = {
      h: ((newHsl.h % 360) + 360) % 360,
      s: Math.max(0, Math.min(100, newHsl.s)),
      l: Math.max(0, Math.min(100, newHsl.l)),
    };
    setHsl(clamped);
    const newHex = hslToHex(clamped.h, clamped.s, clamped.l);
    setHexInput(newHex.replace('#', ''));
    onColorChange(color.id, newHex);
  };

  const handleHexInput = (value) => {
    setHexInput(value);
    if (/^[0-9A-Fa-f]{6}$/.test(value)) {
      const hex = `#${value.toUpperCase()}`;
      const converted = hexToHsl(hex);
      setHsl(converted);
      onColorChange(color.id, hex);
    }
  };

  const handleSliderChange = (key) => (e) => {
    updateColor({ ...hsl, [key]: Number(e.target.value) });
  };

  if (!color) return null;

  const textColor = hsl.l > 60 ? '#000' : '#fff';

  return (
    <div className={`editor-column ${isOpen ? 'open' : ''}`}>
      <div className="editor-inner">
        <div className="editor-header">
          <span className="editor-title">Edit Color</span>
          <button className="editor-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="editor-scroll">
          {/* Color Preview */}
          <div
            className="editor-preview"
            style={{ backgroundColor: color.hex }}
          >
            <span className="editor-preview-hex" style={{ color: textColor }}>
              {color.hex}
            </span>
          </div>

          {/* Hex Input */}
          <div className="editor-field">
            <label>Hex</label>
            <div className="editor-hex-input">
              <span>#</span>
              <input
                type="text"
                value={hexInput}
                onChange={(e) => handleHexInput(e.target.value.toUpperCase())}
                maxLength={6}
                spellCheck={false}
              />
            </div>
          </div>

          {/* Hue Slider */}
          <div className="editor-field">
            <label>
              Hue <span>{Math.round(hsl.h)}°</span>
            </label>
            <input
              type="range"
              min="0"
              max="360"
              value={hsl.h}
              onChange={handleSliderChange('h')}
              className="slider slider-hue"
            />
          </div>

          {/* Saturation Slider */}
          <div className="editor-field">
            <label>
              Saturation <span>{Math.round(hsl.s)}%</span>
            </label>
            <input
              type="range"
              min="0"
              max="100"
              value={hsl.s}
              onChange={handleSliderChange('s')}
              className="slider slider-saturation"
              style={{ '--sat-color': hslToHex(hsl.h, 100, 50) }}
            />
          </div>

          {/* Lightness Slider */}
          <div className="editor-field">
            <label>
              Lightness <span>{Math.round(hsl.l)}%</span>
            </label>
            <input
              type="range"
              min="0"
              max="100"
              value={hsl.l}
              onChange={handleSliderChange('l')}
              className="slider slider-lightness"
              style={{ '--light-mid': hslToHex(hsl.h, hsl.s, 50) }}
            />
          </div>

          {/* Quick Adjustments */}
          <div className="editor-adjustments">
            <label>Quick Adjust</label>
            <div className="adjustment-buttons">
              {ADJUSTMENTS.map((adj) => (
                <button
                  key={adj.label}
                  className="adjustment-btn"
                  onClick={() => updateColor(adj.adjust(hsl))}
                  title={adj.label}
                >
                  <adj.icon size={16} />
                  <span>{adj.label}</span>
                </button>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default ColorEditorPanel;
/* =========================================
   FILE: src/colorGenerator/ColorGenerator.jsx
   ========================================= */

import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { useParams, useSearchParams } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';
import {
  Plus,
  X,
  Copy,
  Lock,
  Unlock,
  ArrowLeftRight,
  ArrowDownUp,
  SwatchBook,
  Check,
  Undo2,
  Redo2,
  Sparkles,
  Eye,
  Clock,
  Upload,
  Bookmark,
} from 'lucide-react';

import Header from '../header/Header';
import MethodPanel from './MethodPanel';
import AccessibilityPanel from './AccessibilityPanel';
import HistoryPanel from './HistoryPanel';
import ExportPanel from './ExportPanel';
import BookmarkPanel from './BookmarkPanel';
import './ColorGenerator.css';
import { trackEvent } from '../utils/analytics';

import {
  generateRandomPalette,
  getContrastColor,
  generateBridgeColor,
  simulateColorBlindness,
  generateShades,
  generateRichSEO,
  hexToHsl,
} from '../utils/colorUtils';

// Constants
const MAX_HISTORY = 50;
const MAX_COLORS = 8;
const MIN_COL_PX = 128;
const MOBILE_BREAKPOINT = 768;
const MOBILE_SHADE_COUNT = 6;
const DESKTOP_SHADE_COUNT = 20;
const HEADER_OFFSET = 100;

// Valid mood options - keep in sync with MethodPanel
const VALID_MOODS = [
  'any',
  'vibrant',
  'bright',
  'pastel',
  'soft',
  'muted',
  'moody',
  'dark',
  'warm',
  'cool',
  'earthy',
  'playful',
  'elegant',
  'retro',
  'neon',
];

// Helpers
const generateId = () => Math.random().toString(36).substring(2, 11);

const createColorObjects = (hexArray) =>
  hexArray.map((hex) => ({
    id: generateId(),
    hex,
    locked: false,
  }));

const isMobileView = () => window.innerWidth <= MOBILE_BREAKPOINT;

const getMaxOpenPanels = () => (isMobileView() ? 1 : 3);

const hexToRgb = (hex) => ({
  r: parseInt(hex.slice(1, 3), 16),
  g: parseInt(hex.slice(3, 5), 16),
  b: parseInt(hex.slice(5, 7), 16),
});

const formatContentSections = (content) => {
  if (!content) return [];
  return content.split('\n\n').map((section, index) => {
    const colonIndex = section.indexOf(':');
    if (colonIndex > 0 && colonIndex < 50) {
      return {
        id: index,
        title: section.substring(0, colonIndex).trim(),
        body: section.substring(colonIndex + 1).trim(),
        hasTitle: true,
      };
    }
    return { id: index, title: '', body: section, hasTitle: false };
  });
};

function ColorGenerator() {
  const { hexCodes: urlHexCodes } = useParams();
  const [searchParams] = useSearchParams();
  // Refs
  const containerRef = useRef(null);
  const colorsAreaRef = useRef(null);

  // Layout State
  const [stackColors, setStackColors] = useState(false);

  const isVerticalLayout = useCallback(
    () => isMobileView() || stackColors,
    [stackColors]
  );

  const DragIcon = isVerticalLayout() ? ArrowDownUp : ArrowLeftRight;

  // History State
  const [history, setHistory] = useState(() => [
    { 
      colors: createColorObjects(generateRandomPalette()), 
      visionMode: 'normal' 
    },
  ]);
  const [historyIndex, setHistoryIndex] = useState(0);

  // Ref to track the live history index
  const historyIndexRef = useRef(historyIndex);

  // Keep the ref synced with state
  useEffect(() => {
    historyIndexRef.current = historyIndex;
  }, [historyIndex]);

  // Panel State
  const [openPanels, setOpenPanels] = useState([]);

  // Generation Settings
  const [generationMode, setGenerationMode] = useState('auto');
  const [constraints, setConstraints] = useState({
    mood: 'any',
    minContrast: 1.5,
    darkModeFriendly: false,
  });

  // Accessibility
  const [colorBlindMode, setColorBlindMode] = useState('normal');

  // Core Data
  const currentEntry = history[historyIndex] || history[history.length - 1];
  const colors = currentEntry ? (Array.isArray(currentEntry) ? currentEntry : currentEntry.colors) : [];

  // UI State
  const [newColorId, setNewColorId] = useState(null);
  const [removingId, setRemovingId] = useState(null);
  const [copiedId, setCopiedId] = useState(null);
  const [activeShadeId, setActiveShadeId] = useState(null);
  const [editingId, setEditingId] = useState(null);
  const [editValue, setEditValue] = useState('');

  // Drag State
  const [dragState, setDragState] = useState(null);
  const [isSnapping, setIsSnapping] = useState(false);

  // Computed Values
  const canUndo = historyIndex > 0;
  const canRedo = historyIndex < history.length - 1;
  const canAddMoreColors = colors.length < MAX_COLORS;

  // Panel Helpers
  const isPanelOpen = (name) => openPanels.includes(name);
  const isMethodOpen = isPanelOpen('method');
  const isA11yOpen = isPanelOpen('a11y');
  const isHistoryOpen = isPanelOpen('history');
  const isExportOpen = isPanelOpen('export');
  const isBookmarkOpen = isPanelOpen('bookmark');

  const togglePanel = (panelName) => {
    setOpenPanels((prev) => {
      if (prev.includes(panelName)) {
        return prev.filter((p) => p !== panelName);
      }
      const maxPanels = getMaxOpenPanels();
      let newPanels = [...prev, panelName];
      if (newPanels.length > maxPanels) {
        newPanels = newPanels.slice(-maxPanels);
      }
      return newPanels;
    });
  };

  const closePanel = (panelName) => {
    setOpenPanels((prev) => prev.filter((p) => p !== panelName));
  };

  // URL Helpers
  const getCurrentUrl = useCallback(() => {
    if (typeof window === 'undefined') return '';
    const hexPath = colors.map(c => c.hex.replace('#', '')).join('-');
    return `${window.location.origin}/${hexPath}`;
  }, [colors]);

  const getShareUrl = useCallback(() => {
    const hexes = colors.map((c) => c.hex.replace('#', '')).join('-');
    const params = new URLSearchParams();

    if (generationMode !== 'auto') params.set('mode', generationMode);
    if (constraints.mood !== 'any') params.set('mood', constraints.mood);
    if (constraints.minContrast !== 1.5) params.set('contrast', constraints.minContrast.toString());
    if (constraints.darkModeFriendly) params.set('dark', '1');
    if (colorBlindMode !== 'normal') params.set('vision', colorBlindMode);

    const queryString = params.toString();
    return `${window.location.origin}/${hexes}${queryString ? '?' + queryString : ''}`;
  }, [colors, generationMode, constraints, colorBlindMode]);

  // History Management
  const updateColors = useCallback(
    (newColors) => {
      setHistory((prev) => {
        const currentIndex = historyIndexRef.current;
        const newHistory = prev.slice(0, currentIndex + 1);
        
        newHistory.push({
          colors: newColors,
          visionMode: colorBlindMode
        });
        
        if (newHistory.length > MAX_HISTORY) {
          newHistory.shift();
          return newHistory;
        }
        return newHistory;
      });
      setHistoryIndex((prev) => {
        const nextIndex = prev + 1;
        return nextIndex >= MAX_HISTORY ? MAX_HISTORY - 1 : nextIndex;
      });
    },
    [colorBlindMode]
  );

  const undo = useCallback(() => {
    if (canUndo) {
      trackEvent('palette_undo');
      setHistoryIndex((prev) => prev - 1);
    }
  }, [canUndo]);

  const redo = useCallback(() => {
    if (canRedo) {
      trackEvent('palette_redo');
      setHistoryIndex((prev) => prev + 1);
    }
  }, [canRedo]);

  const goToHistoryIndex = useCallback(
    (index) => {
      if (index >= 0 && index < history.length) {
        setHistoryIndex(index);
      }
    },
    [history.length]
  );

  // Palette Generation
  const generatePalette = useCallback(
    (count = 5) => {
      const lockedColors = colors.filter((c) => c.locked);
      const unlockedCount = count - lockedColors.length;

      if (unlockedCount <= 0) return;

      let generationConstraints = { ...constraints };
      
      if (lockedColors.length > 0) {
        const lockedHsl = hexToHsl(lockedColors[0].hex);
        generationConstraints.baseHue = lockedHsl.h;
      }

      const newPalette = generateRandomPalette(generationMode, unlockedCount, generationConstraints);
      
      const newColors = newPalette.map((hex) => ({
        id: generateId(),
        hex,
        locked: false,
      }));

      if (lockedColors.length === 0) {
        updateColors(newColors);
        return;
      }

      const result = [];
      let newIndex = 0;
      colors.forEach((c) => {
        if (c.locked) {
          result.push({ ...c });
        } else if (newIndex < newColors.length) {
          result.push(newColors[newIndex]);
          newIndex++;
        }
      });
      while (newIndex < newColors.length) {
        result.push(newColors[newIndex]);
        newIndex++;
      }

      updateColors(result);
      setNewColorId(null);
    },
    [colors, generationMode, constraints, updateColors]
  );

  // Color Actions
  const addColorAtIndex = (index) => {
    trackEvent('add_color', { current_count: colors.length });
    if (!canAddMoreColors) return;

    const colorBefore = colors[index].hex;
    const colorAfter = colors[index + 1].hex;
    const newHex = generateBridgeColor(colorBefore, colorAfter);
    const newId = generateId();

    const newColors = [
      ...colors.slice(0, index + 1),
      { id: newId, hex: newHex, locked: false },
      ...colors.slice(index + 1),
    ];

    updateColors(newColors);
    setNewColorId(newId);
    setTimeout(() => setNewColorId(null), 600);
  };

  const removeColor = (id) => {
    trackEvent('remove_color', { current_count: colors.length });
    if (colors.length <= 2) return;

    setRemovingId(id);
    setTimeout(() => {
      updateColors(colors.filter((c) => c.id !== id));
      setRemovingId(null);
    }, 350);
  };

  const toggleLock = (id) => {
    const isLocking = !colors.find(c => c.id === id).locked;
    trackEvent('toggle_lock', { action: isLocking ? 'lock' : 'unlock' });
    updateColors(colors.map((c) => (c.id === id ? { ...c, locked: !c.locked } : c)));
  };

  const copyHex = async (id, hex) => {
    try {
      await navigator.clipboard.writeText(hex);
      setCopiedId(id);
      setTimeout(() => setCopiedId(null), 1500);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  // --- Hex Editing Handlers ---

  const handleHexClick = (id, currentHex, e) => {
    e.stopPropagation();
    setEditingId(id);
    setEditValue(currentHex.replace('#', ''));
  };

  const commitHexChange = (id) => {
    if (!editValue) {
      setEditingId(null);
      return;
    }

    const validHexPattern = /^([0-9A-F]{3}){1,2}$/i;
    let cleanHex = editValue.replace(/[^0-9A-F]/gi, '').toUpperCase();

    if (validHexPattern.test(cleanHex)) {
      if (cleanHex.length === 3) {
        cleanHex = cleanHex.split('').map(char => char + char).join('');
      }
      
      const newFullHex = `#${cleanHex}`;
      
      updateColors(colors.map(c => {
        if (c.id === id) {
          return { ...c, hex: newFullHex, locked: true };
        }
        return c;
      }));
    } 
    
    setEditingId(null);
    setEditValue('');
  };

  const handleHexKeyDown = (e, id) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      commitHexChange(id);
    } else if (e.key === 'Escape') {
      setEditingId(null);
      setEditValue('');
    }
  };

  // Shade Picker
  const toggleShadePicker = (id) => {
    setActiveShadeId((prev) => (prev === id ? null : id));
  };

  const pickShade = (originalId, newHex) => {
    trackEvent('pick_shade_variation');
    updateColors(colors.map((c) => (c.id === originalId ? { ...c, hex: newHex } : c)));
    setActiveShadeId(null);
  };

  const handleMouseLeave = () => {
    if (window.innerWidth > MOBILE_BREAKPOINT) {
      setActiveShadeId(null);
    }
  };

  // Click Outside Handler for Shade Picker
  useEffect(() => {
    if (!activeShadeId) return;

    const handleClickOutside = (e) => {
      if (e.target.closest('.shade-container')) return;
      setActiveShadeId(null);
    };

    window.addEventListener('mousedown', handleClickOutside);
    window.addEventListener('touchstart', handleClickOutside);

    return () => {
      window.removeEventListener('mousedown', handleClickOutside);
      window.removeEventListener('touchstart', handleClickOutside);
    };
  }, [activeShadeId]);

  // Updated getColumnSize function
  const getColumnSize = useCallback(() => {
    if (!containerRef.current) return 0;

    const vertical = isVerticalLayout();
    const isMobile = isMobileView();

    if (vertical) {
      const colorsArea = colorsAreaRef.current;
      if (!colorsArea) return 0;

      const areaHeight = colorsArea.offsetHeight;

      if (stackColors && !isMobile && colors.length > 0) {
        const effectiveHeight = areaHeight - HEADER_OFFSET;
        return effectiveHeight / colors.length;
      }

      return areaHeight / colors.length;
    } else {
      let panelWidth = 0;
      if (isMethodOpen) panelWidth += 240;
      if (isA11yOpen) panelWidth += 280;
      if (isHistoryOpen) panelWidth += 260;
      if (isExportOpen) panelWidth += 320;
      if (isBookmarkOpen) panelWidth += 280;

      const availableWidth = containerRef.current.offsetWidth - panelWidth;
      return availableWidth / colors.length;
    }
  }, [
    colors.length,
    isMethodOpen,
    isA11yOpen,
    isHistoryOpen,
    isExportOpen,
    isBookmarkOpen,
    isVerticalLayout,
    stackColors,
  ]);

  // Updated handleDragStart to account for header offset
  const handleDragStart = (e, id, index) => {
    if (e.type === 'touchstart') e.preventDefault();

    const columnSize = getColumnSize();
    const vertical = isVerticalLayout();
    const isMobile = isMobileView();

    let clientPos;
    if (e.type === 'touchstart') {
      clientPos = vertical ? e.touches[0].clientY : e.touches[0].clientX;
    } else {
      e.preventDefault();
      clientPos = vertical ? e.clientY : e.clientX;
    }

    let adjustedStartPos = clientPos;
    if (stackColors && !isMobile && vertical) {
      const colorsArea = colorsAreaRef.current;
      if (colorsArea) {
        const areaRect = colorsArea.getBoundingClientRect();
        const relativePos = clientPos - areaRect.top - HEADER_OFFSET;
        adjustedStartPos = areaRect.top + relativePos;
      }
    }

    setDragState({
      id,
      startIndex: index,
      currentIndex: index,
      startPos: adjustedStartPos,
      currentPos: adjustedStartPos,
      columnSize,
      isMobile: vertical,
      isDesktopStacked: stackColors && !isMobile && vertical,
      areaTop: colorsAreaRef.current?.getBoundingClientRect().top || 0,
    });
  };

  // Updated handleMouseMove to handle desktop stacked mode correctly
  const handleMouseMove = useCallback(
    (e) => {
      if (!dragState || isSnapping) return;

      const { startIndex, columnSize, isMobile, isDesktopStacked, areaTop } = dragState;

      let clientPos;
      if (e.type === 'touchmove') {
        clientPos = isMobile ? e.touches[0].clientY : e.touches[0].clientX;
      } else {
        clientPos = isMobile ? e.clientY : e.clientX;
      }

      let adjustedCurrentPos = clientPos;
      if (isDesktopStacked) {
        const relativePos = clientPos - areaTop - HEADER_OFFSET;
        adjustedCurrentPos = areaTop + relativePos;
      }

      let delta = adjustedCurrentPos - dragState.startPos;

      const maxNegativeOffset = -startIndex * columnSize;
      const maxPositiveOffset = (colors.length - 1 - startIndex) * columnSize;
      delta = Math.max(maxNegativeOffset, Math.min(maxPositiveOffset, delta));

      const indexOffset = Math.round(delta / columnSize);
      const newIndex = Math.max(0, Math.min(colors.length - 1, startIndex + indexOffset));

      setDragState((prev) => ({
        ...prev,
        currentPos: adjustedCurrentPos,
        currentIndex: newIndex,
      }));
    },
    [dragState, isSnapping, colors.length]
  );

  const handleMouseUp = useCallback(() => {
    if (!dragState) return;

    const { startIndex, currentIndex } = dragState;
    setIsSnapping(true);

    setTimeout(() => {
      if (startIndex !== currentIndex) {
        const newColors = [...colors];
        const [removed] = newColors.splice(startIndex, 1);
        newColors.splice(currentIndex, 0, removed);
        updateColors(newColors);
      }
      setDragState(null);
      setIsSnapping(false);
    }, 250);
  }, [dragState, colors, updateColors]);

  // Drag Event Listeners
  useEffect(() => {
    if (!dragState) return;

    const handleMove = (e) => {
      if (e.type === 'touchmove') e.preventDefault();
      handleMouseMove(e);
    };

    const handleEnd = () => handleMouseUp();

    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('touchmove', handleMove, { passive: false });
    window.addEventListener('touchend', handleEnd);
    window.addEventListener('touchcancel', handleEnd);

    document.body.style.cursor = 'grabbing';
    document.body.style.overflow = 'hidden';

    return () => {
      window.removeEventListener('mousemove', handleMove);
      window.removeEventListener('mouseup', handleEnd);
      window.removeEventListener('touchmove', handleMove);
      window.removeEventListener('touchend', handleEnd);
      window.removeEventListener('touchcancel', handleEnd);
      document.body.style.cursor = '';
      document.body.style.overflow = '';
    };
  }, [dragState, handleMouseMove, handleMouseUp]);

  // Updated getColumnStyle to handle desktop stacked mode
  const getColumnStyle = (index, id) => {
    if (!dragState) return {};

    const { startIndex, currentIndex, startPos, currentPos, columnSize, isMobile } =
      dragState;
    const isDragged = id === dragState.id;
    const transformProp = isMobile ? 'translateY' : 'translateX';

    if (isDragged) {
      if (isSnapping) {
        const snapOffset = (currentIndex - startIndex) * columnSize;
        return {
          transform: `${transformProp}(${snapOffset}px)`,
          zIndex: 100,
          transition: 'transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1)',
        };
      }

      const offset = currentPos - startPos;
      return {
        transform: `${transformProp}(${offset}px)`,
        zIndex: 100,
        transition: 'none',
      };
    }

    let shift = 0;
    if (startIndex < currentIndex && index > startIndex && index <= currentIndex) {
      shift = -1;
    }
    if (startIndex > currentIndex && index >= currentIndex && index < startIndex) {
      shift = 1;
    }

    return {
      transform: shift !== 0 ? `${transformProp}(${shift * columnSize}px)` : `${transformProp}(0)`,
      transition: 'transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1)',
    };
  };

  // Layout detection
  useEffect(() => {
    const el = colorsAreaRef.current;
    if (!el) return;

    const update = () => {
      if (isMobileView()) {
        setStackColors(false);
        return;
      }

      const w = el.getBoundingClientRect().width;
      const perCol = w / Math.max(1, colors.length);
      setStackColors(perCol < MIN_COL_PX);
    };

    update();

    let ro;
    if (typeof ResizeObserver !== 'undefined') {
      ro = new ResizeObserver(update);
      ro.observe(el);
    } else {
      window.addEventListener('resize', update);
    }

    return () => {
      if (ro) ro.disconnect();
      else window.removeEventListener('resize', update);
    };
  }, [colors.length]);

    // URL Parsing - responds to React Router navigation
    useEffect(() => {
      // Skip if no hex codes in URL (we're at root "/")
      if (!urlHexCodes) return;
  
      // Parse hex codes from URL
      const hexCodes = urlHexCodes
        .split('-')
        .map((h) => {
          const cleaned = h.toUpperCase().replace(/[^0-9A-F]/g, '');
          return cleaned.length === 6 ? `#${cleaned}` : null;
        })
        .filter(Boolean);
  
      // Only update if we have valid colors
      if (hexCodes.length >= 2) {
        const initialColors = hexCodes.map((hex) => ({
          id: generateId(),
          hex,
          locked: false,
        }));
        setHistory([{ colors: initialColors, visionMode: 'normal' }]);
        setHistoryIndex(0);
      }
  
      // Parse query params for settings
      const mode = searchParams.get('mode');
      const mood = searchParams.get('mood');
      const contrast = parseFloat(searchParams.get('contrast'));
      const dark = searchParams.get('dark');
      const vision = searchParams.get('vision');
  
      if (['auto', 'mono', 'analogous', 'complementary', 'splitComplementary', 'triadic'].includes(mode)) {
        setGenerationMode(mode);
      }
      if (VALID_MOODS.includes(mood)) {
        setConstraints((prev) => ({ ...prev, mood }));
      }
      if (!isNaN(contrast) && contrast >= 1 && contrast <= 4.5) {
        setConstraints((prev) => ({ ...prev, minContrast: contrast }));
      }
      if (dark === '1') {
        setConstraints((prev) => ({ ...prev, darkModeFriendly: true }));
      }
      if (['normal', 'protanopia', 'deuteranopia', 'tritanopia', 'achromatopsia'].includes(vision)) {
        setColorBlindMode(vision);
      }
    }, [urlHexCodes, searchParams]);

  // Update URL on State Change
  useEffect(() => {
    const hexes = colors.map((c) => c.hex.replace('#', '')).join('-');
    const params = new URLSearchParams();

    if (generationMode !== 'auto') params.set('mode', generationMode);
    if (constraints.mood !== 'any') params.set('mood', constraints.mood);
    if (constraints.minContrast !== 1.5) params.set('contrast', constraints.minContrast.toString());
    if (constraints.darkModeFriendly) params.set('dark', '1');
    if (colorBlindMode !== 'normal') params.set('vision', colorBlindMode);

    const queryString = params.toString();
    window.history.replaceState({}, '', `/${hexes}${queryString ? '?' + queryString : ''}`);
  }, [colors, generationMode, constraints, colorBlindMode]);

  // Expose API
  useEffect(() => {
    window.chromaAPI = {
      undo,
      redo,
      canUndo: () => canUndo,
      canRedo: () => canRedo,
      getShareUrl,
    };
  }, [undo, redo, canUndo, canRedo, getShareUrl]);

  // Keyboard Shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Don't trigger generation if user is typing in an input
      if (editingId) return;
      
      if (e.code === 'Space') {
        if (document.activeElement instanceof HTMLButtonElement) {
          document.activeElement.blur();
        }
        e.preventDefault();
        generatePalette(colors.length);
        return;
      }

      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      }
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        redo();
      }
      if (e.key === 'Escape') {
        setOpenPanels([]);
        setEditingId(null);
        setEditValue('');
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [undo, redo, colors.length, generatePalette, editingId]);

  // Color Display
  const getDisplayColor = (hex) => {
    if (colorBlindMode === 'normal') return hex;
    return simulateColorBlindness(hex, colorBlindMode);
  };

  // SEO Data
  const currentHexes = useMemo(() => colors.map((c) => c.hex), [colors]);
  const seoData = useMemo(
    () => generateRichSEO(currentHexes, generationMode, constraints.mood),
    [currentHexes, generationMode, constraints.mood]
  );

  const contentSections = useMemo(() => formatContentSections(seoData.content), [seoData.content]);

  // Generate related palette links based on current palette
  const relatedPaletteLinks = useMemo(() => {
    if (colors.length === 0) return [];
    
    // Use the first color's hue as a base for generating related palettes
    const baseHsl = hexToHsl(colors[0].hex);
    const links = [];
    
    // Generate 6 related palettes with different hue offsets
    const hueOffsets = [30, 60, 90, 180, 210, 270];
    
    for (let i = 0; i < 6; i++) {
      const offsetHue = (baseHsl.h + hueOffsets[i]) % 360;
      const relatedPalette = generateRandomPalette('analogous', 5, { 
        baseHue: offsetHue,
        mood: constraints.mood !== 'any' ? constraints.mood : 'any'
      });
      
      links.push({
        hexes: relatedPalette.map(h => h.replace('#', '')).join('-'),
        label: `${seoData.traits?.temperature || 'Color'} Palette ${i + 1}`
      });
    }
    
    return links;
  }, [colors, constraints.mood, seoData.traits?.temperature]);

  return (
    <div className="app-wrapper">
      <Helmet>
        <title>{seoData.title} | CColorPalette</title>
        <meta name="description" content={seoData.meta} />
      </Helmet>

      <div className="page-section visible">
        <Header
          canUndo={canUndo}
          canRedo={canRedo}
          onUndo={undo}
          onRedo={redo}
          onToggleMethod={() => togglePanel('method')}
          isMethodOpen={isMethodOpen}
          onToggleA11y={() => togglePanel('a11y')}
          isA11yOpen={isA11yOpen}
          onToggleHistory={() => togglePanel('history')}
          isHistoryOpen={isHistoryOpen}
          onToggleExport={() => togglePanel('export')}
          isExportOpen={isExportOpen}
          onToggleBookmark={() => togglePanel('bookmark')}
          isBookmarkOpen={isBookmarkOpen}
          logoColors={colors}
          onLogoClick={() => generatePalette(colors.length)}
          historyCount={history.length}
        />

        <main className="generator-container" ref={containerRef}>
          {/* Mobile Header */}
          <div className="mobile-header">
            <button className="mobile-hint" onClick={() => generatePalette(colors.length)}>
              Tap to generate
            </button>

            <div className="mobile-actions">
              <button
                className={`mobile-icon-btn ${!canUndo ? 'disabled' : ''}`}
                onClick={undo}
                disabled={!canUndo}
              >
                <Undo2 size={18} />
              </button>
              <button
                className={`mobile-icon-btn ${!canRedo ? 'disabled' : ''}`}
                onClick={redo}
                disabled={!canRedo}
              >
                <Redo2 size={18} />
              </button>

              <div className="mobile-separator" />

              <button
                className={`mobile-icon-btn ${isMethodOpen ? 'active' : ''}`}
                onClick={() => togglePanel('method')}
              >
                <Sparkles size={18} />
              </button>
              <button
                className={`mobile-icon-btn ${isA11yOpen ? 'active' : ''}`}
                onClick={() => togglePanel('a11y')}
              >
                <Eye size={18} />
              </button>
              <button
                className={`mobile-icon-btn ${isHistoryOpen ? 'active' : ''}`}
                onClick={() => togglePanel('history')}
              >
                <Clock size={18} />
              </button>
              <button
                className={`mobile-icon-btn ${isExportOpen ? 'active' : ''}`}
                onClick={() => togglePanel('export')}
              >
                <Upload size={18} />
              </button>
            </div>
          </div>

          {/* Colors Area */}
          <section
            ref={colorsAreaRef}
            className={`colors-area ${stackColors ? 'stacked' : ''}`}
          >
            {colors.map((color, index) => {
              const displayHex = getDisplayColor(color.hex);
              const textColor = getContrastColor(displayHex);
              const isNew = color.id === newColorId;
              const isRemoving = color.id === removingId;
              const isCopied = copiedId === color.id;
              const isDragging = dragState?.id === color.id;
              const isShadePicking = activeShadeId === color.id;
              const columnStyle = getColumnStyle(index, color.id);

              return (
                <React.Fragment key={color.id}>
                  <div
                    className={`color-column ${isNew ? 'color-entering' : ''} ${isRemoving ? 'color-removing' : ''} ${isDragging ? 'is-dragging' : ''} ${dragState && !isDragging ? 'is-shifting' : ''}`}
                    style={{ backgroundColor: displayHex, ...columnStyle }}
                  >
                    {isShadePicking ? (
                      <div className="shade-container" onMouseLeave={handleMouseLeave}>
                        {generateShades(color.hex, isMobileView() ? MOBILE_SHADE_COUNT : DESKTOP_SHADE_COUNT).map(
                          (shadeHex) => (
                            <button
                              key={shadeHex}
                              className="shade-step"
                              style={{ backgroundColor: shadeHex }}
                              onClick={(e) => {
                                e.stopPropagation();
                                pickShade(color.id, shadeHex);
                              }}
                              title={shadeHex}
                            />
                          )
                        )}
                        <button
                          className="shade-close-btn"
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleShadePicker(null);
                          }}
                        >
                          <X size={20} />
                        </button>
                      </div>
                    ) : (
                      <>
                        <div className="color-toolbar" style={{ color: textColor }}>
                          {colors.length > 2 && (
                            <button
                              className="toolbar-btn"
                              onClick={(e) => {
                                e.stopPropagation();
                                removeColor(color.id);
                                e.currentTarget.blur();
                              }}
                              title="Remove"
                              style={{ color: textColor }}
                            >
                              <X size={20} />
                            </button>
                          )}

                          <button
                            className="toolbar-btn"
                            onClick={(e) => {
                              e.stopPropagation();
                              copyHex(color.id, color.hex);
                              e.currentTarget.blur();
                            }}
                            title="Copy hex"
                            style={{ color: textColor }}
                          >
                            {isCopied ? <Check size={20} /> : <Copy size={20} />}
                          </button>

                          <button
                            className={`toolbar-btn ${color.locked ? 'active' : ''}`}
                            onClick={(e) => {
                              e.stopPropagation();
                              toggleLock(color.id);
                              e.currentTarget.blur();
                            }}
                            title={color.locked ? 'Unlock' : 'Lock'}
                            style={{ color: textColor }}
                          >
                            {color.locked ? <Lock size={20} /> : <Unlock size={20} />}
                          </button>

                          <button
                            className={`toolbar-btn ${isShadePicking ? 'active' : ''}`}
                            title="Adjust shade"
                            onClick={(e) => {
                              e.stopPropagation();
                              toggleShadePicker(color.id);
                              e.currentTarget.blur();
                            }}
                            style={{ color: textColor }}
                          >
                            <SwatchBook size={20} />
                          </button>

                          <div
                            className="toolbar-btn drag-handle"
                            title="Drag to reorder"
                            style={{ color: textColor }}
                            onMouseDown={(e) => handleDragStart(e, color.id, index)}
                            onTouchStart={(e) => handleDragStart(e, color.id, index)}
                          >
                            <DragIcon size={20} />
                          </div>
                        </div>

                        <div className="color-content">
                          {editingId === color.id ? (
                            <div className="hex-input-wrapper">
                              <input
                                autoFocus
                                className="hex-input"
                                style={{ color: textColor }}
                                value={editValue}
                                onChange={(e) => {
                                  let val = e.target.value.replace(/[^0-9A-F]/gi, '').toUpperCase();
                                  if (val.length > 6) val = val.slice(0, 6);
                                  setEditValue(val);
                                }}
                                onBlur={() => commitHexChange(color.id)}
                                onKeyDown={(e) => handleHexKeyDown(e, color.id)}
                                onClick={(e) => e.stopPropagation()}
                              />
                            </div>
                          ) : (
                            <h2
                              className={`color-hex ${isCopied ? 'copied' : ''}`}
                              style={{ color: textColor }}
                              onClick={(e) => handleHexClick(color.id, color.hex, e)}
                              title="Click to edit"
                            >
                              {isCopied ? 'Copied!' : color.hex.replace('#', '')}
                            </h2>
                          )}
                        </div>

                        {color.locked && (
                          <div className="lock-indicator" style={{ color: textColor }}>
                            <Lock size={16} />
                          </div>
                        )}
                      </>
                    )}
                  </div>

                  {index < colors.length - 1 && !dragState && canAddMoreColors && (
                    <div className="addColor">
                      <button
                        className="addBtn"
                        onClick={(e) => {
                          addColorAtIndex(index);
                          e.currentTarget.blur();
                        }}
                        aria-label="Add color"
                      >
                        <Plus size={24} strokeWidth={2.5} color="#161616" />
                      </button>
                    </div>
                  )}
                </React.Fragment>
              );
            })}
          </section>

          {/* Panels */}
          <MethodPanel
            isOpen={isMethodOpen}
            onClose={() => closePanel('method')}
            value={generationMode}
            onChange={setGenerationMode}
            constraints={constraints}
            onConstraintsChange={setConstraints}
          />

          <AccessibilityPanel
            isOpen={isA11yOpen}
            onClose={() => closePanel('a11y')}
            colors={colors}
            colorBlindMode={colorBlindMode}
            onColorBlindModeChange={setColorBlindMode}
          />

          <HistoryPanel
            isOpen={isHistoryOpen}
            onClose={() => closePanel('history')}
            history={history}
            currentIndex={historyIndex}
            onSelectPalette={goToHistoryIndex}
          />

          <ExportPanel
            isOpen={isExportOpen}
            onClose={() => closePanel('export')}
            colors={colors}
            generationMode={generationMode}
            constraints={constraints}
            colorBlindMode={colorBlindMode}
          />

          <BookmarkPanel
            isOpen={isBookmarkOpen}
            onClose={() => closePanel('bookmark')}
            currentUrl={getCurrentUrl()}
          />
        </main>
      </div>

      {/* SEO Footer */}
      <footer className="seo-content-footer">
        <div className="seo-content-wrapper">
          <h1 className="seo-main-title">{seoData.title}</h1>

          {seoData.traits && (
            <div className="seo-palette-summary">
              <span className="seo-trait">{seoData.traits.harmony} harmony</span>
              <span className="seo-trait-separator">|</span>
              <span className="seo-trait">{seoData.traits.temperature} temperature</span>
              <span className="seo-trait-separator">|</span>
              <span className="seo-trait">{seoData.traits.saturation} saturation</span>
              <span className="seo-trait-separator">|</span>
              <span className="seo-trait">{seoData.traits.accessibilityScore} accessibility</span>
            </div>
          )}

          <div className="seo-related-links">
            <h3 className="seo-section-title">Explore Related Palettes</h3>
            <div>
              {relatedPaletteLinks.map((link, i) => (
                <a key={i} href={`/${link.hexes}`}>
                  {link.label}
                </a>
              ))}
            </div>
          </div>

          <div className="seo-color-reference">
            <h2 className="seo-section-title">Color Values</h2>
            <div className="seo-color-grid">
              {colors.map((c) => {
                const rgb = hexToRgb(c.hex);
                const hsl = hexToHsl(c.hex);
                return (
                  <div key={c.id} className="seo-color-item">
                    <div className="seo-color-swatch" style={{ backgroundColor: c.hex }} />
                    <div className="seo-color-values">
                      <span className="seo-hex">{c.hex}</span>
                      <span className="seo-rgb">RGB({rgb.r}, {rgb.g}, {rgb.b})</span>
                      <span className="seo-hsl">HSL({Math.round(hsl.h)}, {Math.round(hsl.s)}%, {Math.round(hsl.l)}%)</span>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          <article className="seo-article">
            {contentSections.map((section) => (
              <section key={section.id} className="seo-section">
                {section.hasTitle && <h2 className="seo-section-title">{section.title}</h2>}
                <p className="seo-section-body">{section.body}</p>
              </section>
            ))}
          </article>

          {seoData.keywords?.length > 0 && (
            <div className="seo-keywords">
              <span className="seo-keywords-label">Related searches: </span>
              {seoData.keywords.slice(0, 8).map((keyword, index) => (
                <span key={index} className="seo-keyword">
                  {keyword}
                  {index < Math.min(seoData.keywords.length, 8) - 1 && ', '}
                </span>
              ))}
            </div>
          )}
        </div>
      </footer>
    </div>
  );
}

export default ColorGenerator;
/* =========================================
   FILE: src/colorGenerator/ExportPanel.jsx
   ========================================= */

import { useState, useMemo } from 'react';
import {
  X,
  Link,
  Code,
  FileCode,
  Image,
  Braces,
  Check,
  Wind,
  ChevronDown,
  Settings2,
  FileJson,
} from 'lucide-react';
import { hexToHsl, hexToOklch, simulateColorBlindness } from '../utils/colorUtils';
import '../styles/PanelStyles.css';
import './ExportPanel.css';
import { trackEvent } from '../utils/analytics';
import { submitToIndexNow } from '../utils/seo';

const PANEL_WIDTH = 320;

// ============================================
// COLOR NAMING FOR "SMART" SCHEME
// ============================================

const getColorName = (h, s, l) => {
  h = ((h % 360) + 360) % 360;
  
  // Achromatic
  if (s < 8) {
    if (l < 15) return 'black';
    if (l < 30) return 'charcoal';
    if (l < 45) return 'gray';
    if (l < 60) return 'silver';
    if (l < 75) return 'light-gray';
    if (l < 90) return 'off-white';
    return 'white';
  }

  // Get modifier
  let prefix = '';
  if (l < 25) prefix = 'dark-';
  else if (l > 80) prefix = 'pale-';
  else if (l > 70) prefix = 'light-';
  else if (s < 35) prefix = 'muted-';
  else if (s > 75) prefix = 'vivid-';

  // Base color by hue
  let base;
  if (h >= 345 || h < 10) base = l < 35 ? 'burgundy' : l > 70 ? 'rose' : 'red';
  else if (h < 25) base = l < 40 ? 'rust' : l > 70 ? 'peach' : 'vermilion';
  else if (h < 40) base = l < 40 ? 'brown' : l > 70 ? 'apricot' : 'orange';
  else if (h < 55) base = l < 45 ? 'bronze' : s > 60 ? 'amber' : 'gold';
  else if (h < 70) base = l < 45 ? 'olive' : l > 75 ? 'lemon' : 'yellow';
  else if (h < 85) base = l < 45 ? 'moss' : 'chartreuse';
  else if (h < 100) base = l < 40 ? 'forest' : 'green';
  else if (h < 140) base = l < 35 ? 'hunter' : l > 70 ? 'mint' : s > 50 ? 'emerald' : 'sage';
  else if (h < 170) base = l < 40 ? 'dark-teal' : l > 70 ? 'aquamarine' : 'teal';
  else if (h < 195) base = l < 40 ? 'dark-cyan' : 'cyan';
  else if (h < 220) base = l < 40 ? 'prussian' : l > 70 ? 'sky' : 'cerulean';
  else if (h < 250) base = l < 35 ? 'navy' : l > 70 ? 'periwinkle' : 'blue';
  else if (h < 280) base = l < 35 ? 'indigo' : l > 70 ? 'lavender' : 'violet';
  else if (h < 310) base = l < 35 ? 'eggplant' : l > 70 ? 'lilac' : 'purple';
  else if (h < 330) base = l < 40 ? 'dark-magenta' : l > 70 ? 'orchid' : 'magenta';
  else base = l < 40 ? 'maroon' : l > 75 ? 'pink' : 'rose';

  // Avoid redundant prefixes
  if (prefix && base.includes(prefix.replace('-', ''))) return base;
  return prefix ? `${prefix}${base}` : base;
};

// ============================================
// NAMING SCHEMES
// ============================================

const NAMING_SCHEMES = {
  smart: (i, hexColors) => {
    const hsl = hexToHsl(hexColors[i]);
    return getColorName(hsl.h, hsl.s, hsl.l);
  },
  numbered: (i) => `color-${i + 1}`,
  semantic: (i) =>
    ['primary', 'secondary', 'tertiary', 'accent', 'highlight', 'muted', 'subtle', 'background', 'surface', 'border'][i] ||
    `color-${i + 1}`,
  palette: (i) =>
    ['base', 'light', 'dark', 'accent-1', 'accent-2', 'neutral-1', 'neutral-2', 'neutral-3', 'neutral-4', 'neutral-5'][i] ||
    `color-${i + 1}`,
};

const getContrastRatio = (hex1, hex2) => {
  const getLuminance = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    const toLinear = (c) =>
      c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    return 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
  };
  const l1 = getLuminance(hex1);
  const l2 = getLuminance(hex2);
  return ((Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05)).toFixed(2);
};

function ExportPanel({
  isOpen,
  onClose,
  colors,
  generationMode,
  constraints,
  colorBlindMode,
}) {
  const [copiedOption, setCopiedOption] = useState(null);
  const [namingScheme, setNamingScheme] = useState('smart');
  const [showSettings, setShowSettings] = useState(false);
  const [cssFormat, setCssFormat] = useState('vars');
  const [tailwindFormat, setTailwindFormat] = useState('v4');
  const [applySimulation, setApplySimulation] = useState(false);

  const rawHexColors = colors.map((c) => c.hex);

  // Apply simulation if toggled AND a mode is selected
  const hexColors = useMemo(() => {
    if (applySimulation && colorBlindMode !== 'normal') {
      return rawHexColors.map(hex => simulateColorBlindness(hex, colorBlindMode));
    }
    return rawHexColors;
  }, [rawHexColors, applySimulation, colorBlindMode]);

  // Get color names for preview and exports
  const colorNames = useMemo(() => 
    hexColors.map(hex => {
      const hsl = hexToHsl(hex);
      return getColorName(hsl.h, hsl.s, hsl.l);
    }),
    [rawHexColors]
  );

  // Get name based on current scheme
  const getName = (i) => {
    if (namingScheme === 'smart') {
      return NAMING_SCHEMES.smart(i, rawHexColors);
    }
    return NAMING_SCHEMES[namingScheme](i);
  };

  const showCopied = (option) => {
    setCopiedOption(option);
    setTimeout(() => setCopiedOption(null), 2000);
  };

  const getColorData = () =>
    hexColors.map((hex, i) => {
      const hsl = hexToHsl(hex);
      const oklch = hexToOklch(hex);
      return {
        name: getName(i),
        colorName: colorNames[i],
        hex,
        rgb: {
          r: parseInt(hex.slice(1, 3), 16),
          g: parseInt(hex.slice(3, 5), 16),
          b: parseInt(hex.slice(5, 7), 16),
        },
        hsl: { h: Math.round(hsl.h), s: Math.round(hsl.s), l: Math.round(hsl.l) },
        hslString: `hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`,
        oklch: {
          l: Number((oklch.L * 100).toFixed(1)),
          c: Number(oklch.C.toFixed(3)),
          h: Math.round(oklch.h),
        },
        oklchString: `oklch(${(oklch.L * 100).toFixed(1)}% ${oklch.C.toFixed(3)} ${Math.round(oklch.h)})`,
        contrastOnWhite: getContrastRatio(hex, '#FFFFFF'),
        contrastOnBlack: getContrastRatio(hex, '#000000'),
      };
    });

  const getTailwindDescription = () => {
    switch (tailwindFormat) {
      case 'v4': return 'CSS @theme (v4)';
      case 'v3-config': return 'Config extend (v3)';
      case 'v3-layer': return '@layer base (v3)';
      default: return 'Tailwind Config';
    }
  };

  const exportOptions = [
    {
      id: 'url',
      icon: Link,
      label: 'URL',
      description: 'Full state link',
      action: () => {
        const url = window.chromaAPI?.getShareUrl() || window.location.href;
        navigator.clipboard.writeText(url);
        showCopied('url');
      },
    },
    {
      id: 'css',
      icon: FileCode,
      label: 'CSS',
      description: cssFormat === 'vars' ? 'CSS Variables' : 'Utility Classes',
      action: () => {
        let css;
        if (cssFormat === 'vars') {
          css = `:root {\n${hexColors.map((c, i) => `  --${getName(i)}: ${c}; /* ${colorNames[i]} */`).join('\n')}\n}`;
        } else {
          css = hexColors
            .map((c, i) => `/* ${colorNames[i]} */\n.bg-${getName(i)} { background-color: ${c}; }\n.text-${getName(i)} { color: ${c}; }`)
            .join('\n\n');
        }
        navigator.clipboard.writeText(css);
        showCopied('css');
      },
    },
    {
      id: 'tailwind',
      icon: Wind,
      label: 'Tailwind',
      description: getTailwindDescription(),
      action: () => {
        let config;
        const getV4Name = (i) => getName(i).replace(/^color-/, '');
        
        if (tailwindFormat === 'v4') {
          config = `@import "tailwindcss";

@theme {
  /* Usage: bg-${getV4Name(0)}, text-${getV4Name(1)} */
${hexColors.map((c, i) => `  --color-${getV4Name(i)}: ${c}; /* ${colorNames[i]} */`).join('\n')}
}`;
        } else if (tailwindFormat === 'v3-config') {
          config = `// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
${hexColors.map((c, i) => `        '${getName(i)}': '${c}', // ${colorNames[i]}`).join('\n')}
      },
    },
  },
}`;
        } else {
          config = `/* Add to your CSS */
@layer base {
  :root {
${hexColors.map((c, i) => `    --${getName(i)}: ${c}; /* ${colorNames[i]} */`).join('\n')}
  }
}

/* tailwind.config.js */
module.exports = {
  theme: {
    extend: {
      colors: {
${hexColors.map((c, i) => `        '${getName(i)}': 'var(--${getName(i)})',`).join('\n')}
      },
    },
  },
}`;
        }
        navigator.clipboard.writeText(config);
        showCopied('tailwind');
      },
    },
    {
      id: 'scss',
      icon: Code,
      label: 'SCSS',
      description: 'Variables + Map',
      action: () => {
        const scss = `// Individual variables
${hexColors.map((c, i) => `$${getName(i)}: ${c}; // ${colorNames[i]}`).join('\n')}

// As a map
$palette: (
${hexColors.map((c, i) => `  '${getName(i)}': ${c}, // ${colorNames[i]}`).join('\n')}
);`;
        navigator.clipboard.writeText(scss);
        showCopied('scss');
      },
    },
    {
      id: 'json',
      icon: Braces,
      label: 'JSON',
      description: 'Full metadata',
      action: () => {
        const data = {
          palette: getColorData(),
          settings: {
            harmony: generationMode || 'auto',
            mood: constraints?.mood || 'any',
            minContrast: constraints?.minContrast || 1.5,
            darkModeFriendly: constraints?.darkModeFriendly || false,
          },
          generated: new Date().toISOString(),
          source: 'ccolorpalette.com',
        };
        navigator.clipboard.writeText(JSON.stringify(data, null, 2));
        showCopied('json');
      },
    },
    {
      id: 'tokens',
      icon: FileJson,
      label: 'Tokens',
      description: 'Design tokens',
      action: () => {
        const tokens = {
          color: {
            palette: hexColors.reduce((acc, hex, i) => {
              acc[getName(i)] = {
                $value: hex,
                $type: 'color',
                $description: colorNames[i],
              };
              return acc;
            }, {}),
          },
        };
        navigator.clipboard.writeText(JSON.stringify(tokens, null, 2));
        showCopied('tokens');
      },
    },
    {
      id: 'array',
      icon: Code,
      label: 'JS/TS',
      description: 'Typed object',
      action: () => {
        const obj = `export const palette = {
${hexColors.map((c, i) => {
  const key = getName(i).replace(/-([a-z])/g, (_, l) => l.toUpperCase());
  return `  /** ${colorNames[i]} */\n  ${key}: '${c}',`;
}).join('\n')}
} as const;

export type PaletteKey = keyof typeof palette;`;
        navigator.clipboard.writeText(obj);
        showCopied('array');
      },
    },
    {
      id: 'svg',
      icon: FileCode,
      label: 'SVG',
      description: 'Vector graphic',
      action: () => {
        const width = 1200;
        const height = 630;
        const colorWidth = width / hexColors.length;

        const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}">
  <title>${colorNames.join(', ')} Color Palette</title>
${hexColors.map((c, i) => `  <rect x="${i * colorWidth}" y="0" width="${colorWidth}" height="${height}" fill="${c}"/>`).join('\n')}
${hexColors.map((c, i) => {
  const hsl = hexToHsl(c);
  const textColor = hsl.l > 55 ? '#000000' : '#FFFFFF';
  const x = i * colorWidth + colorWidth / 2;
  return `  <text x="${x}" y="${height - 50}" text-anchor="middle" fill="${textColor}" font-family="system-ui, sans-serif" font-size="14">${colorNames[i]}</text>
  <text x="${x}" y="${height - 26}" text-anchor="middle" fill="${textColor}" font-family="monospace" font-size="16" font-weight="bold">${c}</text>`;
}).join('\n')}
</svg>`;

        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `palette-${Date.now()}.svg`;
        a.click();
        URL.revokeObjectURL(url);
        showCopied('svg');
      },
    },
    {
      id: 'png',
      icon: Image,
      label: 'PNG',
      description: 'Social preview',
      action: () => {
        const canvas = document.createElement('canvas');
        canvas.width = 1200;
        canvas.height = 630;
        const ctx = canvas.getContext('2d');
        const colorWidth = canvas.width / hexColors.length;

        hexColors.forEach((color, i) => {
          ctx.fillStyle = color;
          ctx.fillRect(i * colorWidth, 0, colorWidth, canvas.height);
        });

        ctx.textAlign = 'center';
        hexColors.forEach((color, i) => {
          const hsl = hexToHsl(color);
          const textColor = hsl.l > 55 ? '#000000' : '#FFFFFF';
          const x = i * colorWidth + colorWidth / 2;

          // Color name
          ctx.font = '500 14px system-ui, sans-serif';
          ctx.fillStyle = textColor;
          ctx.fillText(colorNames[i], x, canvas.height - 50);

          // Hex code
          ctx.font = 'bold 16px monospace';
          ctx.fillText(color, x, canvas.height - 26);
        });

        ctx.font = '12px sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.textAlign = 'right';
        ctx.fillText('ccolorpalette.com', canvas.width - 20, canvas.height - 12);

        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `palette-${Date.now()}.png`;
          a.click();
          URL.revokeObjectURL(url);
        });
        showCopied('png');
      },
    },
  ];

  return (
    <div
      className={`panel-column ${isOpen ? 'open' : ''}`}
      style={{ flexBasis: isOpen ? `${PANEL_WIDTH}px` : '0px' }}
    >
      <div className="panel-inner" style={{ width: `${PANEL_WIDTH}px` }}>
        <div className="panel-header">
          <div className="panel-title">
            <span>Export Palette</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          {/* Settings Toggle */}
          <button
            className={`export-settings-toggle ${showSettings ? 'active' : ''}`}
            onClick={() => setShowSettings(!showSettings)}
          >
            <Settings2 size={16} />
            <span>Export Settings</span>
            <ChevronDown size={16} className={`chevron ${showSettings ? 'open' : ''}`} />
          </button>

          {/* Settings Panel */}
          {showSettings && (
            <div className="export-settings">
              <div className="export-setting">
                <label>Naming Scheme</label>
                <div className="export-setting-options">
                  {Object.keys(NAMING_SCHEMES).map((scheme) => (
                    <button
                      key={scheme}
                      className={`panel-btn ${namingScheme === scheme ? 'active' : ''}`}
                      onClick={() => setNamingScheme(scheme)}
                    >
                      {scheme.charAt(0).toUpperCase() + scheme.slice(1)}
                    </button>
                  ))}
                </div>
                <span className="export-setting-preview">
                  e.g., {getName(0)}, {getName(1)}
                </span>
              </div>

              <div className="export-setting">
                <label>CSS Format</label>
                <div className="export-setting-options two-col">
                  <button
                    className={`panel-btn ${cssFormat === 'vars' ? 'active' : ''}`}
                    onClick={() => setCssFormat('vars')}
                  >
                    Variables
                  </button>
                  <button
                    className={`panel-btn ${cssFormat === 'classes' ? 'active' : ''}`}
                    onClick={() => setCssFormat('classes')}
                  >
                    Classes
                  </button>
                </div>
              </div>

              <div className="export-setting">
                <label>Tailwind Version</label>
                <div className="export-setting-options three-col">
                  <button
                    className={`panel-btn ${tailwindFormat === 'v4' ? 'active' : ''}`}
                    onClick={() => setTailwindFormat('v4')}
                    title="CSS @theme variable configuration"
                  >
                    v4 CSS
                  </button>
                  <button
                    className={`panel-btn ${tailwindFormat === 'v3-config' ? 'active' : ''}`}
                    onClick={() => setTailwindFormat('v3-config')}
                    title="Legacy JS config"
                  >
                    v3 Config
                  </button>
                  <button
                    className={`panel-btn ${tailwindFormat === 'v3-layer' ? 'active' : ''}`}
                    onClick={() => setTailwindFormat('v3-layer')}
                    title="Legacy @layer base"
                  >
                    v3 Layer
                  </button>
                </div>
              </div>

              {colorBlindMode !== 'normal' && (
                <div className="export-setting">
                  <label>Vision Simulation</label>
                  <div className="export-setting-options two-col">
                    <button
                      className={`panel-btn ${!applySimulation ? 'active' : ''}`}
                      onClick={() => setApplySimulation(false)}
                    >
                      Original
                    </button>
                    <button
                      className={`panel-btn ${applySimulation ? 'active' : ''}`}
                      onClick={() => {
                        setApplySimulation(true);
                        trackEvent('enable_colorblind_export', { mode: colorBlindMode });
                      }}
                    >
                      Simulated
                    </button>
                  </div>
                  {applySimulation && (
                    <span className="export-setting-preview">
                      Exporting for: {colorBlindMode.charAt(0).toUpperCase() + colorBlindMode.slice(1)}
                    </span>
                  )}
                </div>
              )}
            </div>
          )}

          {/* Export Grid */}
          <div className="panel-export-grid">
            {exportOptions.map((option) => {
              const Icon = option.icon;
              const isCopied = copiedOption === option.id;

              return (
                <button
                  key={option.id}
                  className={`panel-export-btn ${isCopied ? 'copied' : ''}`}
                  onClick={(e) => {
                    trackEvent('palette_export', { 
                      format: option.id, 
                      tailwind_version: tailwindFormat,
                      naming_scheme: namingScheme 
                    });
                    const currentUrl = window.location.href;
                    submitToIndexNow(currentUrl);
                    option.action();
                    e.currentTarget.blur();
                  }}
                >
                  <div className="panel-export-btn-icon">
                    {isCopied ? <Check size={24} /> : <Icon size={24} />}
                  </div>
                  <span className="panel-export-btn-label">
                    {isCopied ? 'Done!' : option.label}
                  </span>
                  <span className="panel-export-btn-desc">{option.description}</span>
                </button>
              );
            })}
          </div>

          {/* Preview */}
          <div className="panel-preview">
            <label className="panel-label">Preview</label>
            <div className="panel-preview-colors">
              {hexColors.map((color, i) => (
                <div
                  key={i}
                  className="panel-preview-color"
                  style={{ backgroundColor: color }}
                  title={`${colorNames[i]} (${rawHexColors[i]})`}  // <-- Use rawHexColors for the hex in tooltip
                />
              ))}
            </div>
            <div className="panel-preview-names">
              {colorNames.map((name, i) => (
                <span key={i} className="panel-preview-name">
                  {name}
                </span>
              ))}
            </div>
            <div className="panel-preview-hexes">
              {hexColors.map((color, i) => (
                <span key={i} className="panel-preview-hex">
                  {color.replace('#', '')}
                </span>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default ExportPanel;
/* =========================================
   FILE: src/colorGenerator/HistoryPanel.jsx
   ========================================= */

import React from 'react';
import { X, Clock, Eye } from 'lucide-react';
import { simulateColorBlindness } from '../utils/colorUtils';
import '../styles/PanelStyles.css';

const PANEL_WIDTH = 260;

function HistoryPanel({
  isOpen,
  onClose,
  history,
  currentIndex,
  onSelectPalette,
}) {
  const reversedHistory = [...history].reverse();

  const checkIsNormal = (entry) => {
    if (!entry) return true;
    const mode = entry.visionMode || 'normal';
    return mode.toLowerCase() === 'normal';
  };

  return (
    <div
      className={`panel-column ${isOpen ? 'open' : ''}`}
      style={{ flexBasis: isOpen ? `${PANEL_WIDTH}px` : '0px' }}
    >
      <div className="panel-inner" style={{ width: `${PANEL_WIDTH}px` }}>
        <div className="panel-header">
          <div className="panel-title">
            <Clock size={18} />
            <span>History</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          {history.length === 0 ? (
            <div className="panel-empty">
              <p>No history yet</p>
              <span>Press space to generate palettes</span>
            </div>
          ) : (
            <div className="panel-list seamless">
              {reversedHistory.map((entry, idx) => {
                const actualIndex = history.length - 1 - idx;
                const isCurrent = actualIndex === currentIndex;
                const colors = Array.isArray(entry) ? entry : entry.colors;
                const visionMode = entry.visionMode || 'normal';
                const isNormal = checkIsNormal(entry);
                const nextEntry = reversedHistory[idx + 1];
                const nextIsNormal = checkIsNormal(nextEntry);
                const showDivider = idx < reversedHistory.length - 1 && !(isNormal && nextIsNormal);

                return (
                  <React.Fragment key={idx}>
                    <button
                      className={`panel-card ${isCurrent ? 'current' : ''}`}
                      onClick={(e) => {
                        onSelectPalette(actualIndex);
                        e.currentTarget.blur();
                      }}
                    >
                      {!isNormal && (
                        <div className="panel-card-sim-label">
                          <Eye size={10} />
                          <span>{visionMode}</span>
                        </div>
                      )}
                      
                      <div className="panel-preview-colors">
                        {colors.map((color, colorIdx) => {
                          const displayHex = isNormal
                            ? color.hex 
                            : simulateColorBlindness(color.hex, visionMode.toLowerCase());
                          return (
                            <div
                              key={colorIdx}
                              className="panel-preview-color"
                              style={{ backgroundColor: displayHex }}
                            />
                          );
                        })}
                      </div>

                      {!isNormal && (
                        <div className="panel-card-decoration">
                          {colors.slice(0, 3).map((color, i) => (
                            <span
                              key={i}
                              className="decoration-bar"
                              style={{ backgroundColor: simulateColorBlindness(color.hex, visionMode.toLowerCase()) }}
                            />
                          ))}
                        </div>
                      )}
                    </button>

                    {showDivider && <div className="panel-entry-divider" />}
                  </React.Fragment>
                );
              })}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

export default HistoryPanel;
/* =========================================
   FILE: src/colorGenerator/MethodPanel.jsx
   ========================================= */

import { X, Sparkles } from 'lucide-react';
import '../styles/PanelStyles.css';
import { trackEvent } from '../utils/analytics';

const HARMONY_MODES = [
  { id: 'auto', label: 'Auto', description: 'Random harmony' },
  { id: 'mono', label: 'Monochromatic', description: 'Single hue variations' },
  { id: 'analogous', label: 'Analogous', description: 'Adjacent hues' },
  { id: 'complementary', label: 'Complementary', description: 'Opposite hues' },
  { id: 'splitComplementary', label: 'Split Comp.', description: 'Opposite + adjacent' },
  { id: 'triadic', label: 'Triadic', description: 'Three-way split' },
];

const MOOD_OPTIONS = [
  { id: 'any', label: 'Any' },
  { id: 'vibrant', label: 'Vibrant' },
  { id: 'bright', label: 'Bright' },
  { id: 'pastel', label: 'Pastel' },
  { id: 'soft', label: 'Soft' },
  { id: 'muted', label: 'Muted' },
  { id: 'moody', label: 'Moody' },
  { id: 'dark', label: 'Dark' },
  { id: 'warm', label: 'Warm' },
  { id: 'cool', label: 'Cool' },
  { id: 'earthy', label: 'Earthy' },
  { id: 'playful', label: 'Playful' },
  { id: 'elegant', label: 'Elegant' },
  { id: 'retro', label: 'Retro' },
  { id: 'neon', label: 'Neon' },
];

const PANEL_WIDTH = 280;

function MethodPanel({
  isOpen,
  onClose,
  value,
  onChange,
  constraints,
  onConstraintsChange,
}) {
  const handleMoodChange = (mood) => {
    trackEvent('change_mood', { mood });
    onConstraintsChange({ ...constraints, mood });
  };

  return (
    <div
      className={`panel-column ${isOpen ? 'open' : ''}`}
      style={{ flexBasis: isOpen ? `${PANEL_WIDTH}px` : '0px' }}
    >
      <div className="panel-inner" style={{ width: `${PANEL_WIDTH}px` }}>
        <div className="panel-header">
          <div className="panel-title">
            <Sparkles size={18} />
            <span>Method</span>
          </div>
          <button className="panel-close" onClick={onClose}>
            <X size={20} />
          </button>
        </div>

        <div className="panel-scroll">
          {/* Harmony */}
          <div className="panel-section">
            <label className="panel-label">Harmony</label>
            <div className="panel-list">
              {HARMONY_MODES.map((mode) => (
                <button
                  key={mode.id}
                  className={`panel-list-item ${value === mode.id ? 'selected' : ''}`}
                  onClick={(e) => {
                    trackEvent('change_harmony', { mode: mode.id });
                    onChange(mode.id);
                    e.currentTarget.blur();
                  }}
                >
                  <div className="panel-list-item-content">
                    <span className="panel-list-item-title">{mode.label}</span>
                    <span className="panel-list-item-desc">{mode.description}</span>
                  </div>
                  {value === mode.id && <div className="panel-check" />}
                </button>
              ))}
            </div>
          </div>

          {/* Mood */}
          <div className="panel-section">
            <label className="panel-label">Mood</label>
            <div className="panel-btn-grid mood-grid">
              {MOOD_OPTIONS.map((mood) => (
                <button
                  key={mood.id}
                  className={`panel-btn ${constraints.mood === mood.id ? 'active' : ''}`}
                  onClick={(e) => {
                    handleMoodChange(mood.id);
                    e.currentTarget.blur();
                  }}
                >
                  {mood.label}
                </button>
              ))}
            </div>
          </div>

          {/* Contrast */}
          <div className="panel-section">
            <label className="panel-label">
              Min Adjacent Contrast
              <span>{constraints.minContrast.toFixed(1)}:1</span>
            </label>
            <input
              type="range"
              min="1"
              max="4.5"
              step="0.1"
              value={constraints.minContrast}
              onChange={(e) => onConstraintsChange({ ...constraints, minContrast: Number(e.target.value) })}
              className="panel-slider"
            />
            <div className="panel-slider-labels">
              <span>Low</span>
              <span>High</span>
            </div>
          </div>

          {/* Dark Mode */}
          <div className="panel-section">
            <button
              className={`panel-toggle ${constraints.darkModeFriendly ? 'active' : ''}`}
              onClick={(e) => {
                onConstraintsChange({ ...constraints, darkModeFriendly: !constraints.darkModeFriendly });
                e.currentTarget.blur();
              }}
            >
              <span className="panel-toggle-indicator" />
              <span>Dark mode friendly</span>
            </button>
            <p className="panel-hint">
              Ensures colors work well on dark backgrounds
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}

export default MethodPanel;
/* =========================================
   FILE: src/components/ScrollToTop.jsx
   ========================================= */

import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';

function ScrollToTop() {
  const { pathname } = useLocation();

  useEffect(() => {
    // Scroll to top on route change
    window.scrollTo(0, 0);
  }, [pathname]);

  return null;
}

export default ScrollToTop;
/* =========================================
   FILE: src/data/paletteDirectory.js
   ========================================= */

export const DIRECTORY_PALETTES = ["2F121F-A21B6A-E32F80-E285B4-F0C7DB","2C4C1A-B5D59D-1AE4AB-F9E4F9-A91A8F","708F1C-D9E949-D3D05F-897DEC-C6C3EF","145042-198972-28E6B2-9CE8D7-EAF8F4","280C21-8A1C50-D3396E-E2909E-F7DDDB","411842-9F1D73-DE3D8C-E38CA6-F2CCD3","3E0D16-EB7F93-EFF6EA-3C8A22-4280DE","1F5E17-2A7B1F-3E9B27-DC71DC-EDCDF3","14473A-1A7B74-2DA5D2-7FB5E8-E1EBF7","3A1C58-501E8D-5C21A8-A97BDF-DCC3EE","4B3E1B-E2CC50-E6CE4C-E3D273-F7F1DD","0C2720-1E8A5E-32D7CB-E673A0-F0C9D4","161A3E-162691-2B4EE2-8093E7-C8D1ED","0F0E2F-234F88-DFE44E-E2DA78-F2EFD3","10404A-1D75A1-4889D9-7992E3-C4C5ED","28180E-904D18-DC6A19-E4AB8F-F7E9DF","0E3A2D-22957A-28DCC4-75E0C9-D4F2ED","0B2B1B-207332-46D044-AAD8A4-DDECD2","3C5214-6E8613-96C932-C6EA76-EBF1DF","4A3A1C-E0CE52-CAE052-BDD399-DEEDD4","2B0E12-EA8CA1-ECF5E7-329726-2D4EDC","144A21-1EA47B-DD37A1-DF7499-F8E0E7","123842-167A80-2BB9E3-F7E0DE-E3A69D","4B401B-E7D47E-237692-E3F2F8-7747DC","311B50-6026AA-F3EEC9-D2D35F-349325","E0E54D-D2E34F-C0CC66-DAE486-F6F8E1","671624-B41723-D85A40-D7F0EE-69DAE7","0C2C30-2189A1-377CD3-90A2EA-C1C2F0","153B15-228740-33CB5E-99D3B4-E2F5F2","581941-A72689-E52664-EBF7EE-207C4B","122D34-26869E-26C5DF-82D9E9-CBECF3","144318-1E7942-ED8EBC-D54697-EDC9E2","4F1727-E53C6D-E797BD-DAF5F0-1D8954","390D19-8F263B-D32C56-E67C9C-EDC6D3","1B483C-187A5E-40C2D9-95CDED-CADCED","0C142A-214493-417BD2-7AA0E5-CCDBF2","0F271C-197C70-30BCC7-8DCDE7-D5E6F1","491022-932132-7DDEB0-24D597-E7F8F3","111138-252F82-265BD3-E9D676-F6EFDB","0F2537-167D9F-46A1D5-DDB185-F2E1D6","19584D-2EBAA6-42D3DE-A21A27-F5DFD8","1A3146-90C7E0-DBD057-7E2223-F8E7E9","162341-1A3A7F-4B6AD9-7CA1E8-C7D5F2","5B1F66-D66EBF-BF277A-D92267-EEBECD","122447-24379B-2228D5-9B85EA-D7C5EC","DDB037-DDDD55-BBC969-EFC792-EBD5CA","225F29-47D16F-9DEAC9-D9F3F3-1D9871","1A2451-786ED9-F2DDCC-E2B26E-85D149","122D36-256C90-2F91D0-8ACADF-D0E6F0","3E1612-912725-C62E2D-E7827A-F7E5E3","154A47-1A7C82-E65D29-E98F94-EECFCE","46162C-7E183A-DC1951-EA9B92-F2D7C8","3F1A0F-8A3926-CCEEEB-70C8E3-3EADD7","0F2810-218237-DB2AA7-EA70D9-F5D4E8","4B171D-8D3B1C-C8ECEA-95DFE3-2C9ECB","3E1A15-8E3D20-97E8E2-CFEFEF-3AB6E5","451441-8B238B-B449D5-BD86E6-CEC6EB","37200E-A6511D-E44F2C-84D4ED-E2F2F8","3B1C0E-E7B998-9ECE2C-27398D-C1C4F1","185740-35CC7B-63DDB3-F6D5E5-A8255D","221142-967EE2-34CC76-F0D9C6-894013","152D39-186791-3998DB-71C3E7-D2E5F0","1E5616-3CCE80-74E1C4-B2E9E6-AEDCB9","361A48-A957E8-B05CE6-BD76E8-D5BCEA","471836-751E35-D8284F-E4F5ED-81DBC7","193E13-28982B-C21ADB-E587DE-F6E4F6","49192E-DC7791-E0F2E1-20802D-1CA9DD","122644-17659C-E9C73C-E4D27C-F2E3D5","0B1A31-224A78-458BDD-95BAE4-D4E3F5","2A0E15-E67BB5-E6A62D-207493-CFE8F1","0F1D29-1B5279-1C94E4-96CCEC-DBE9F6","232A6D-3639CD-5A22CA-8F5CE2-F3E9F8","441020-8A1C47-DD4485-E3799F-EED2DC","10123D-1E18A7-4956DC-7773E1-C4C5ED","13433A-1B9DA5-2D8BD0-91B5E6-CDD9F3","111633-2820A1-8146D2-C37DE9-E8D1F0","244118-3E9926-CA44D6-C56FE7-EFDAF4","270F23-81156E-D341B2-DB7FCC-ECC6E2","29751D-479A29-C02642-C3C6EF-2B58E0","414A1C-E8DD4A-D4DE54-E3D296-F4E5D4","1B1842-391EA7-7431CB-BD8FE0-ECD7F3","324C1A-A5D091-2FDD90-7B2280-EFC4EA","207288-C4F1F0-C4D55D-E4DF7E-D63DD8","0B2233-287C98-1ABFDF-84E8DF-C9F0E7","0F1231-1E3B7F-2C84D2-8CD8E5-DAF1F5","14360E-308524-3FCF6B-90CFA5-D0EEE1","DCB029-D6C65C-C4CE64-EEB195-F8EAE6","173A43-1E5D7E-1E599A-9FBDEA-C0C8F1","122F33-1E887D-34D6C5-E4767D-F7DEE1","39102A-7A203B-D62899-9AE7CE-E2F2E7","6A3017-CB9924-F2D589-E4E97A-E9F3CE","231246-5F1AA4-8E25E3-E78AEB-F5E0F2","14453D-178778-47D592-9DD5AE-E4F4E6","311D12-8B1C21-E05F3D-75EAE8-CEEEF0","0E3212-25922A-3DCF43-9ED6A8-CCE9D0","134E41-25827C-2CC8D5-83C2DD-CBDEF3","145131-258E30-3DC531-9AD194-E1EDD5","391427-962058-D22F76-E984BD-F5D9E7","3A2712-E8D095-48D18B-631F8A-DFC2F0","301846-501680-8032CC-B592E1-D7C1F1","1B6332-21C680-61E3C1-78E1C9-C8E9EA","164E26-30C270-CA87E3-EFD6F0-E38C96","1A4A73-235E86-619626-E7659E-F5E4F1","190E36-381C88-E7E785-BCD839-F9F8E5","226D59-47E0B5-4AE1AF-8CF1DE-C5EAE3","6C3123-906C14-E3CF4F-E6C8A0-F3F5E1","4C181E-9B1D56-E63D93-E08CDB-F7E2F5","4E3B18-9D5425-3A74E1-86C8EA-DEEEF8","0F313C-1A678E-1C6FDD-7487E7-C3C4EF","0E3234-205578-1E84E0-94B4EF-C7CBEA","15244E-253D82-2A2AE4-AC98E3-D3C4ED","183610-299527-49D15F-A2D7B2-D3F2E3","154124-3BCD88-CFC4EE-5B31AF-E59D51","134142-1C8392-35A0E4-98AAE8-C0C5F1","382514-914928-E04B3A-E49490-F4E0E3","2E200C-A96118-DE901E-EEC189-F0E1CC","3A153C-881BA0-9044D6-AD90E5-CBC6EB","391138-821481-D83CE1-E793E6-F4D6F4","5D4514-DC9569-E7C292-4667D7-C1DBEC","311740-621C88-9D46DA-C288E5-DDC7EA","324F17-B2D397-42D088-F4E3F4-9B1A8C","19350D-618B23-AAD225-D6E173-F7F5DE","3C0D16-911A1C-C9F3E2-80EBE7-29DEC2","0F3B24-26985F-3DDC93-87E0B5-D2ECDF","122E34-1F80A5-306DC4-9CB6E3-C7CAEB","503B16-E7C626-D9CF59-DEE5F4-747FEC","241970-2B1CA2-3B25DA-8B79DF-C8C5E9","431032-90274E-DE3962-EC7883-ECCFC6","0F0F40-2C20A4-3F2ED2-8988E7-CAC6EB","134648-1B7597-2697CE-84A3E2-E8ECFA","0F412E-298C90-30B9E5-79C6E5-E1E9F8","1A0E27-531B99-9735E3-BF98E9-D5C3EF","492916-9E6E17-DFBF2A-DCE395-EBF2CC","325214-6D7E23-DCD956-EAE873-F0E2C5","1B4D13-2EA92D-2DB356-92D0A5-C9F4E5","276A20-30BF49-9BD4A4-C65BD4-F5D9F0","12321D-24913B-EF95B6-E12D80-F2C9EC","2D1047-7A1C7F-D646BC-EA87D2-FAE9F2","0F3615-22873E-31C464-8CECD0-D7F4EE","224F14-568322-BCDB29-D6EA73-F5F2E4","371E0D-94451E-DB8948-EBA787-EED4C6","1B0D38-1A1E82-3955D6-89BDEE-D5E6F5","0D2528-1794A5-36C8E3-91DAED-E4F4F6","103F17-2A954B-24D487-95ECC8-E6F6F2","405313-628421-C8DC56-AD82E7-C6C1F1","41123A-9A2885-D145BB-E085D1-F8E1F6","3B151D-E091A3-DCF0E0-1E7930-21CAD8","180D2A-4C1694-982ED7-DD90EB-F6DCF3","144E4F-279F99-47DAAA-94D1AD-E8F5EC","320C24-EA79C2-D99648-C7ECE6-138676","372114-8E3621-E33942-E690A9-F1D6DF","300A11-9B2922-E5683D-E9B981-F8EDDF","421D18-AB301D-E6B295-81D1DC-C9D9ED","114126-25924D-40CF7B-A7D9BB-CFEAD9","132E0B-ACD69F-1EE6B8-F3DCEE-98196C","4A1926-EF939F-E1BB40-1A77A4-D2E3EF","240D27-A51E8D-CB2C8A-E89BB6-F6E7EA","103E1B-A8DAAB-43B4DD-95224B-F1D3DC","42161D-86253B-E83D90-E59BD7-ECCAEC","195754-31A6CB-1D66A4-6E97E9-C4CBED","10382A-1B8A7E-27D6D8-83D6E9-EBF1F9","114628-1E7821-3DCD37-9ECC89-E7F0DB","12374D-1D83A7-45A2D0-6CB3DD-DAECF4","2A7423-26983D-91D09E-A0D6BB-B7EAD7","4D2789-DAC6EC-E3EB8A-C1C969-49CF3F","49143C-972A87-DB20AC-EB8CD7-F2C4E9","411826-A81C28-E63B2C-E1A17A-F6F0E1","3B180E-993729-E25A36-EBA898-F5DBD3","1D4312-2D9726-3DCF3F-9CD5B2-C9ECDB","191645-761EB9-BF7EE3-BB9BEE-E9CAEC","0E2B29-1F6A76-3997D7-9BB3E6-EAEEF9","37151B-9E1E24-36CD7D-97EBD8-C6F1E2","14203F-174A98-277ECC-94E1EB-C8F0F1","3F131C-92284E-DB2F55-A9DABE-E7FAF3","15402D-238B31-E63DA6-E49FD1-F0D3ED","40200E-873A14-E36C30-EA9479-F0DAD2","350D36-982B84-D03474-ED819B-F9E6E9","142A43-16527D-3A85E8-ECC095-F4ECDF","123F32-25969A-45ABD3-76C0E0-E4ECF6","211549-471DA8-7E3BCF-BFD398-EDF4E5","3A5214-587920-CCDB57-E7D480-F9F3E5","142943-1C759F-39B4D8-88DFE0-CEF0E7","0D202F-1C2CA5-4365D3-E0B88E-F2E3CD","52246E-9B20B0-8625CF-90D147-E3EED7","15330D-388C23-32C94C-A1D7AC-CBEFE1","0F300C-279D37-50D37C-6FE7BA-DCF6EE","2A5214-89A21F-A141D3-BC7CDE-DDC4ED","361A49-59288D-8526DC-C181E4-E0C1F0","1D0E26-431D7C-7527DA-ADD69F-EFF5E2","215E56-40C0D0-79BEE3-2B669C-E9EBF7","31102B-7D1A6B-DD2CD3-E377CF-F7E7F4","2F1026-E698D0-A6D920-1B829D-E4F2F7","6C1B5F-D02561-E062AF-E59BD6-F8DFE3","2B0A1F-9A1771-DC46D6-C96FE9-E0C0F1","144717-88CC97-262394-CDC3EF-D63F21","3E0E15-851423-D8263D-E1737B-F7E0E4","2A102E-7418A7-C744E1-B1DBAA-D1E9CB","0B1629-164C98-3080E2-EEBC91-EEDFCC","103210-21832C-32CA49-9CD49C-D0EBD4","122530-1C76A9-3BA8E8-75C3E6-E5F2F9","2E1A0C-E3BF96-DFC6EC-471F7E-41D07A","11432E-9FD6B9-D12336-8A1B82-EED0EB","134942-177084-3BA2D5-9DC4E7-C7CBEB","270D2F-7C1D9B-A225CF-C671E5-EBD1F1","D2C660-E2DB50-DBD057-E1E34F-EAECB7","141B52-202D79-1F4EE3-E3D579-F5F1DF","101345-8E9EE7-A73DD4-557C1F-DCE9CB","391534-821B7C-CF3BBA-E99BE3-F9E4F8","123B4C-276F8C-1A8FDB-8ECCE6-CCE0EE","246F44-259359-35CEB4-29C6BC-B8DCE6","4D1129-811763-DE21C8-CE80E4-E8CDF3","0B2D0C-369E28-E89BD7-F5D2F5-D838BF","3A5214-308722-C192E8-E7CFF1-B747D8","0D1F34-1F3581-1D26D6-9989E6-D3C1F1","134B15-248F2D-E244A3-E391CF-F6DFED","102A31-8CE3E7-F1CCF2-871F7C-E1EA48","1B0A2A-522691-712DDD-B7D49B-EAF2E2","34123D-9F18AC-CE29B0-E777AE-ECCCDB","384C1A-C0D6A0-32C75F-F0E0F6-7A1785","0A2B23-218440-45D4B3-E982B4-F9E8EE","121D3D-204E93-326FE4-91AAE2-CEDAEE","113C3A-19AB7E-50D379-AADAB0-D4ECD5","491B31-E879AC-A6D350-1A65AB-E7F0F9","103924-259467-33E1E5-8BD8E7-EBF5F9","366824-A0D59D-9ED5B1-87CCA7-D9F3E9","2E0F27-932590-B133CD-C77CDF-D4C3EE","1B523B-2FBE4E-2BE0A8-9D2553-F3DFE5","355214-59771D-A4CB2B-DEE586-EFE0C6","571854-D63F95-BF1861-E37EA6-F0C3C5","32220F-9B831A-B9DC25-C8E190-EEF5E7","1F5861-1F7086-2BA2B2-4AB7D4-C3E6F0","451541-831E6C-DA309D-E47591-F4CCCC","2C0D0B-A04F26-E08F3B-E4CA7E-EFE9C9","120C36-261E85-4B32DE-A594E3-CDC7EB","35190C-7E2521-82B5E0-49B8D6-DEEDF5","879B24-AADD20-B1CF90-EBF5E9-C8BA6A","0F202C-94D6EA-DBCE57-791D28-F9E4E9","161338-3B209A-893AD0-CE8EE4-E5C8ED","371216-872C18-DE6E26-E2B374-F5EDD2","4A1A1F-87254D-E628A8-EE8ACE-FAE7F9","0C1435-402A97-713ED0-B897E3-EACEF4","4C391A-957F24-DCECF4-749FE0-3354DD","1F5763-23848A-28AFD3-34A8C9-C2ECF1","101B47-1E3F76-30A2E5-70D4EB-C7EBE8","472B15-7F4523-E18237-E8AE7D-F1D8CE","1C4661-3175D8-E6B9BC-E0513A-EBEB93","907D1F-CAC268-E1872E-E7B890-EED9D2","151A3B-275096-358ED3-83C4DF-C8EEEF","0B1F30-224591-3571CD-F5E1DB-EBAE80","1F0F31-63169B-C847D8-E979D8-F7DCEC","134C52-2A8B96-37C8D8-82D0E3-E1F2F4","48192D-811C50-DF293F-78E9B5-E6F7F4","11392E-238976-22BCDB-8EC5E2-DEECF6","4F4317-B6D742-DBE64C-BBD194-D7E8CA","1B3E56-2C47E2-809DEB-8A88EA-CEC0F2","0A2925-98E3D5-3055DB-A13D17-EDDACE","6D2739-7F1A3A-549A26-E6F0DD-99C0EA","164633-92EBC7-3476D0-922029-F6DBDE","394E18-638114-92CD36-C2E47E-EFF4E6","151C3D-1D358E-1D2C99-8696E4-C3C6EF","5B1D58-8322A1-E3A1F0-28A144-D7EEDA","491129-A8173D-DD4762-ED8E7E-F1D2C3","331853-4B1C7E-7A36CA-8959D9-D8C6EB","774F1D-835F1B-C98820-D8AF76-F7EFDD","48181E-EA82A5-DFB828-157088-E3F2F8","534813-845618-2553D2-97BBE6-E8F0F7","43134F-701F89-B11ED9-D182E9-E9D2F3","2B0A2D-792166-D9216F-E384A7-F9E6E9","321813-962B20-DA3C59-DD81A8-F7DFEF","391231-891956-D1455C-E89AA6-F2D2CD","481020-E58A8E-DBD457-166D97-E6F0F7","62203A-DE315C-DC7B72-EABCAB-ECD1C2","1C4311-3C7B1F-BC84E7-A027DF-EED9F2","541945-DB74B7-B0D9A5-DAEED6-81E7D5","4B391B-925E24-CD882C-E5B97B-F6EDDF","4A1B4F-9F1959-DE5CB7-E47FAF-EBC9D1","310F3F-7C1997-D037C5-DC77C2-F5DAE9","0F2339-185DA3-2244D1-8188DC-CDC5EC","0D1B33-1B3DA8-3F38DD-8F75DF-D3C7EA","3C1040-891C87-D746DB-E395EB-F8E9FA","460F0F-9A2043-DA348A-E589C3-F8E8F4","D4AA2A-E6DC4C-D5CF5D-E9B795-F7EAE8","124D51-207286-3995DD-94BDE9-C9D5F0","0B2D1B-1E7A2E-EDCDDB-E76FAD-D030B8","0E3912-208031-31C542-9DD5A2-E8F5EA","421730-871D8C-DA45D5-A5D8AD-CBE9CE","0C272D-198BAA-3071D3-7394E2-C2C1F1","30120E-7E2218-E54B26-E2A591-F8E6E3","3F1527-841821-D87546-EC9E99-F3DAC7","4C381A-80531B-D89433-E1BF86-F7F2E8","1E4115-47B02C-A2CF8E-A7D092-EBF5E7","48221B-C24528-F1CAA1-B6E3E8-76CCDF","0C2839-265F99-3991DA-91CCED-DDEBF5","2D781E-31A329-7BC577-ACD9A6-E4F3E3","431024-9D272B-CC4A62-904023-EFD2C3","0B1433-174784-4F9BD5-E2BD77-F3E5D1","10332B-19AA94-36E1BB-7AE4D9-D8F2EC","382414-E8BE97-924BD5-E0F4EC-21824B","162D3E-216783-28B7D1-87E4D0-E6F7F0","311C12-E59D81-E2F3E5-26964A-682CD6","331313-E39B9A-B0D626-175D9D-E0ECF6","1D102F-A477E0-52D147-DFDD53-FAFAE7","340F1C-781D37-DF4545-ECAE96-F1DFCF","49162C-931D80-D727C3-CF91E9-E6D3EF","184B30-1C785B-E87BC4-EEC8DD-D52167","534513-975D2B-CE5336-E98370-EFC3C8","0D0E26-264095-2A68D6-81B6DC-D9F0F7","0F1031-321F91-7A3AD2-BF8AED-F7EBF8","3D0E37-DD7BD3-F2F4DA-698817-48D5D7","12363C-2A8495-35BCD3-7FE3E4-DAF0F2","4A1735-811F39-DD2D2C-E79D9C-F5E2DC","402511-B94017-EEB497-346CC7-C6DCEB","6B4822-832116-E29A67-BDDFE6-1D7AAD","0F0B2E-233D88-F6F6E4-E9CB86-DDCB55","D1C761-A7CA82-E9EB94-E1F398-EEF5E8","2F0E28-902279-E23EB7-E882D2-F3CCEA","422719-82681E-E6992B-88C7EE-C7D0F3","350D23-7F142E-71E8B0-21DBA5-DBF6F0","461015-842030-DA3146-E58990-F6E0E3","0F272C-1A7C96-2ED0E7-92DEE8-E4F2F6","4D1434-E0576B-E6798E-BAE2CC-20D4B3","31122B-972276-E123AD-E38ED5-F2D8EE","8BA31F-BAE433-C3D55D-D5E57C-EEF1D7","330C14-A1381E-D66B2D-DF9E73-EFE3CA","511213-90203C-E04379-E080B6-F3DAEC","11310C-1F7D1F-52D477-94D1AC-D9F4E7","404E18-A8CB2B-CDE34F-D6E47F-EEF2D3","341321-7D1943-E51D89-DE8AB3-F9E5EE","19501F-32B03D-962245-9F2BDA-F1E0F7","20133E-B370E9-E5D04D-ECECCB-41CF46","15163E-241EA2-3E3BDB-969AED-C6C9EC","371149-5B1A7F-D730D3-A9D59D-E2F1DE","2D4A1C-1E7823-40CF4B-98D3A9-C5EFDC","31143C-61299B-6125D8-8669EA-C0C7F1","451034-9C1A6B-D8268C-E276BD-ECCAE0","24143F-A12DBA-B868EC-AC75EB-ECC9ED","0F2F2E-1C897D-3FD68E-92D0A8-D9EFDD","0D2D10-249130-44D045-9ED6A4-E6F4E9","0F2B34-257D98-2DB4E5-79CCE7-E4F1F8","2D1111-8F181F-DA3035-E98781-EDC7C5","4F1334-991F79-D230E6-BD7AE5-D6C6EB","261235-4D167E-8228CA-BB8FEA-DCC6EC","11402F-198060-3AD1AE-E97D8B-F7E0E8","461046-69197D-AD3FD4-AD87E1-CFC4EE","17204E-321C98-6239CF-B86DE8-DDC5ED","195869-1C7297-2668C2-365ACF-C0C2F1","4C161B-842324-E2233E-DE8B91-F2D8DB","180B31-AE95E4-DA2B83-308F25-CFEBCF","16422E-7EDAB2-6A2FD3-965027-F2E0D0","401A48-8E1987-D43FA2-DF84A8-F2DCE0","133C26-1F7A49-46D18A-92E4C1-E6F4EC","4F4217-826F14-B9D63D-B4CD8B-ECF4E6","121A33-204777-1CC1E3-94E3EC-CBEDE9","1B686E-24B7CD-66DDE7-8EDCEC-D7F4F4","1F3F65-352DCA-9172DF-D4C0F1-7781EB","10142D-2D237C-4429E1-B683ED-DBC3EF","321A10-933816-3477DA-73B7E8-C2DCF2","0B2921-82EDD1-3442DA-8B3818-F2E4D5","143138-17797D-2DC6B4-8CEAC7-E3F3EA","3C0F1C-811237-D8276E-E48EB0-FAEAF0","3B1111-8F2724-DE3156-96E5E6-EAF8F3","10173B-1B479E-3B97DD-74CCE5-E4F5F6","0E3A21-7CDABD-961CD8-EFD8C7-845B1C","26112D-C084DE-D71C4A-218342-E8F5EB","195C31-63D6AC-57DBC7-278790-B6E0E8","3D180F-9A2418-DE4C34-E58E72-F5D2CF","3F1037-9B2892-B73BD2-C68AE7-D4C5ED","0D2E37-1F89A0-3CC7DC-94DCED-DFF1F4","1C5E6B-22A5B8-33B2C9-60C5EA-CFE8EF","521216-802820-DA7F26-E4CB9C-EFEAD1","3B1431-951A4F-E7386D-EA6B75-F9EBE6","0D172B-174F91-1DACD8-97ECEE-C9EBE3","3C1742-622091-571CDB-A789EC-C8C5ED","502912-905E1B-D49030-E6D97E-EFF2CB","441135-851F75-C832AF-E583CD-F3DAEF","511540-891F69-DF2AA3-D2ECD4-A4D8B2","236B21-2FBB4C-2FBB72-22997F-C6ECE4","4A1C30-E53CD1-EAA5C3-C7E7CF-25A86E","314D19-6A9926-CADB57-DFE481-F8F4E2","3E1621-991C3F-D9375D-DE7593-F2D7DC","2B0B14-9B1B3C-E8396C-EA7093-F9E8EC","122849-94B8EE-F1C4E2-80155F-9ACF40","290D3C-6F229B-9747DE-B576E9-D8C1F0","0D3219-259434-D8217C-EA79D5-EECAE2","1A2A49-1F2796-4139D0-8A76E6-D6C5EC","4F3115-9D3F21-D69A3F-9ACAE4-E3EFF9","39143D-9C2490-DE42D2-B3DAA9-D0E9CB","22102C-541994-6C20DE-7977E6-C5CAEC","1A4745-199D72-31E690-A2D7AE-CBE8CA","0D1D29-1F4D9E-D75E28-E1B18E-FAF4EA","601F2E-A62364-D31A2C-C7E7D5-9CEEC7","451128-931968-CAEFE0-A4D8B2-44D07E","462D19-8C2F19-E54F3B-E899A3-F2C6D7","124E4A-268985-3BA6D1-EC8182-F9E8E9","0D351E-22784A-F2D3DB-EB74C7-D63797","56221D-D22930-DD8C88-EA9790-F1CDCF","122948-1D367C-3146E6-A38AE6-CDC3EE","153546-12848B-ABE7E8-A02D19-F6DFDE","421038-9F1686-E11DB8-E86BCE-F1C6E4","4B1C4A-BF209F-B6228C-E36183-E8BBBE","1A4010-B0D59E-F1C7D7-952651-344CD3","D8B247-EBC17A-EED7C9-D2DA58-C4D45E","4D1626-E6556D-E8F5ED-93D1AE-23BEDD","493015-7B251E-E51F39-E39EB2-F0D2DD","BFD062-D3DE54-DFE475-E8F0A2-EFEFC5","2C0C34-5E2097-7141D6-9991E7-D4DBF5","154C1E-1F7D28-32C74B-AADAB1-E0F2E2","1E5768-256BA1-9EDAF0-DA8960-F6EAE6","7F681D-CBD65C-979BE2-C6C7EC-3F19DE","13223E-8099E4-F3E2DF-7C3718-D2EA48","170B2E-283391-BAD744-CDE47F-F8F7E4","3D4F17-587C1F-491FDD-A080EB-D4C4EE","123C43-226993-DD1F32-E9898A-ECCCC8","582192-D1C2F0-49D25E-DAE59E-D1CD61","0A222C-27778D-2B8DDB-E1B381-F3DACD","2D0E37-822995-B945D7-D795E2-E6CEED","362113-E3B491-92C331-E1E9F7-1F3577","3E0F42-B558DB-C896E3-E7F4E5-A2CA84","17424A-95DBEA-7D1C49-F0D6DD-CE7D29","5F7E20-76CF3E-AFD7A2-D7EDD4-CED260","0D232D-1E628B-E69898-F7E9E9-D8682F","75202C-E8746F-EDB19E-E8D4B7-DA9347","1A4717-2D9029-9D22D2-DA89E4-F1DFF6","310C0F-EB919F-4499DC-279A51-E2F2E8","12342A-16989A-3FD1DA-89C1EC-E3EDF7","200B2A-641E75-E63AE4-9BCF8F-E2F2E3","0F3E2E-20B1C3-1C97BD-94F0D9-D1E1F1","271A0D-7E4C18-D59037-E6BD96-F8F0E4","161C45-7396EA-41C531-8E1F2C-F3CDD3","114227-22884D-E03BAF-E87FC2-F3D2EC","1E0A2B-CB8DE1-E3375B-1E7A27-D9EFE0","342310-814213-D28727-94D8E5-CFE1EF","172F3E-2587A0-3FDEDE-7DDBC4-D7F3E7","461024-871E5B-E235D1-DF9BE8-DFC6EB","120E26-292183-1A55E2-809DE7-E7F2F9","12494B-1F7A75-37DFE8-81D8DC-CAF2F2","114424-258D47-45D07C-8FCFA6-CFEAD8","1B0F43-4518A2-8A34CF-D1E66C-DFEBD1","6F471C-E5C56E-DED254-C3D65C-E3EED8","0F3A48-235C94-2789DC-DB9678-F7EAE0","701F22-DF3C32-22A769-B9E8D5-1C598F","280D1A-971965-D6408A-EA9AC3-F2C8DF","134121-33CC66-BEBAE7-ACA3E5-D6784E","174E1F-338722-81D34E-C0E37A-F0F2DB","303BD3-8297EB-C1C6F1-E5E04D-D5C85D","D3C25F-DDD455-C5D35F-C1C3F0-A89CE6","61421D-D88E26-DFA360-EBC694-F8F1E8","20491A-24913F-4BD277-76DCAC-CAF3E5","1A483F-17849A-20D8AA-E68474-F6DCDF","36130C-89391D-98EBE9-D1F1F1-20D7E3","1E4511-548C23-BF2DE1-BF93E4-ECD6F2","0E371E-A3D7BD-EACCF2-751982-D93D5D","4F4117-9F7921-D79B2C-E4C389-EEE5C9","574719-E1DA51-76A017-6BBD2F-EBF5E8","131D53-233698-204ED7-F0E1CD-EFDF93","0A1D2D-1C427D-2576DA-F7E8E1-EFB896","3B121C-911636-DD2057-E17C8D-F2D7DF","14371D-1F7C3C-46D16D-8DCE9F-E4F4E8","1F0D2E-631897-802CCE-BA76E9-DDC2F0","341324-7F1F57-DC20C9-D47EDB-E5CFF0","182141-2131A2-3C50E4-7A8AE9-D3D9F2","134241-1CA092-239BD8-E29C87-F6E8E3","25665E-22C29D-45CAB1-33E0C0-B7E6DE","144250-2ED7DA-59BBDD-B5201D-EEC2BB","638425-C4CF63-C3C5EF-837EDB-5E41E4","5E211D-BE4231-DB403E-DC614C-F6DCDA","432215-8E2517-D48D4D-7DD6E9-DAEFF5","143C45-1D6E7A-31ADC3-73D0E2-D0EBF0","1F0C2B-491D8A-BA3BE6-ACCE8E-EDF5E9","2A0E13-E981AC-1BB8DA-2C993C-E0F2E0","162B42-195F98-2A45CC-EDB682-F5EEE4","345214-C7E72C-DADB57-D4C1F0-977AE7","341546-8F20CA-228730-7C9B24-E3EDB4","133A40-238269-37DEB8-9ED5B1-DCF0DE","0E2235-1C659F-4397D7-87B6DF-E0EDF6","451E19-8D4A24-94EAE8-24C6DD-EAF4F8","341558-8B2393-A82496-B773EA-F8E7F4","4C3218-98421E-2037C7-58E7D4-E7F9F4","133724-1F7D6B-29CAD3-86C4DE-CADEEC","36173F-5A248A-491DD8-8171E7-D8DDF3","144E48-14808E-1AA5DA-83AFE8-D9E2F4","14173F-1D4A91-DCD156-E5C184-F1E8D3","44181B-97292B-D9454A-EA827C-F4DEE0","113713-22872A-4AD258-A0D69E-D4ECD6","1F134E-17249A-2855D9-759FE4-E8F2F7","D0D65C-D7DF53-D5E052-D9DD55-E6ECB8","15391D-96D2A0-E42D4C-81248A-EDD6F2","280C27-821882-D448D1-E99AE5-F4E3F6","1A4B15-237B1F-3BCE5F-9CE4C4-DEF5F0","1F4A67-97D6EF-E7CE4B-E65B78-E9B0BE","112D45-1E3BA5-DA823E-E7B873-F6EDDA","153F1C-24903F-DC81B5-D12393-ECC6E6","2E0A1C-E680AE-3470DC-458421-E3EED7","12173F-2C2497-7A4ADB-B873EB-EFDDF7","15113E-18409D-D9B840-EBD693-F2E8CD","16374F-76B0DC-8A152E-EFD0D1-E6CD4C","391516-77211F-DF373D-E78691-F6D5D9","3F1349-BB8FE2-31C53C-E1ECCB-C7D75B","0C332E-229B84-1FE3BB-6EE7D9-E5F7F5","4F2161-C130E0-CF68E5-CA91E5-EBD0F1"]; 
/* =========================================
   FILE: src/header/Header.jsx
   ========================================= */

import { useState, useRef, useEffect } from 'react';
import { Link } from 'react-router-dom';
import {
  Undo2,
  Redo2,
  Clock,
  Upload,
  Sparkles,
  Eye,
  Bookmark,
  ChevronRight,
} from 'lucide-react';
import './Header.css';

const DEFAULT_LOGO_COLORS = [
  { hex: '#0B2B29' },
  { hex: '#21A479' },
  { hex: '#95D2A6' },
];

// Keyboard shortcuts for tooltips
const SHORTCUTS = {
  undo: { key: 'Ctrl+Z', mac: '⌘Z' },
  redo: { key: 'Ctrl+Y', mac: '⌘Y' },
  generate: { key: 'Space', mac: 'Space' },
};

function Header({
  isLanding = false,
  canUndo = false,
  canRedo = false,
  onUndo,
  onRedo,
  onToggleMethod,
  isMethodOpen = false,
  onToggleA11y,
  isA11yOpen = false,
  onToggleHistory,
  isHistoryOpen = false,
  onToggleExport,
  isExportOpen = false,
  onToggleBookmark,
  isBookmarkOpen = false,
  logoColors = [],
  onLogoClick,
  historyCount = 0,
}) {
  const [activeTooltip, setActiveTooltip] = useState(null);
  const tooltipTimeout = useRef(null);

  const isMac = typeof navigator !== 'undefined' && 
    navigator.platform.toUpperCase().indexOf('MAC') >= 0;

  const displayLogoColors = isLanding ? DEFAULT_LOGO_COLORS : 
    (logoColors.length > 0 ? logoColors : DEFAULT_LOGO_COLORS);

  // Show tooltip on hover with delay
  const handleMouseEnter = (id) => {
    tooltipTimeout.current = setTimeout(() => {
      setActiveTooltip(id);
    }, 600);
  };

  const handleMouseLeave = () => {
    if (tooltipTimeout.current) {
      clearTimeout(tooltipTimeout.current);
    }
    setActiveTooltip(null);
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (tooltipTimeout.current) {
        clearTimeout(tooltipTimeout.current);
      }
    };
  }, []);

  const getShortcut = (action) => {
    const shortcut = SHORTCUTS[action];
    if (!shortcut) return null;
    return isMac ? shortcut.mac : shortcut.key;
  };

  // Check if any panel is open
  const anyPanelOpen = isMethodOpen || isA11yOpen || isHistoryOpen || isExportOpen || isBookmarkOpen;

  return (
    <header className={`header ${isLanding ? 'landing' : ''} ${anyPanelOpen ? 'panels-active' : ''}`}>
      <div className="header-left">
        {/* Logo */}
        <Link 
          to="/home" 
          className="header-logo"
          title="Go to Home"
        >
          <div className="logo-mark">
            {displayLogoColors.slice(0, 3).map((color, i) => (
              <span
                key={i}
                className="logo-swatch"
                style={{ 
                  backgroundColor: color.hex,
                  transitionDelay: `${i * 50}ms`
                }}
              />
            ))}
          </div>
          <span className="logo-text">CColorPalette</span>
        </Link>

        {/* Generate Hint */}
        {!isLanding && (
          <div className="header-hint">
            <span className="hint-text">Press</span>
            <kbd className="hint-key">space</kbd>
            <span className="hint-text">to generate</span>
          </div>
        )}
      </div>

      <div className="header-right">
        {isLanding ? (
          <nav className="header-nav">
            <Link to="/" className="header-cta">
              <span>Open Generator</span>
              <ChevronRight size={16} />
            </Link>
          </nav>
        ) : (
          <>
            {/* Undo/Redo Group */}
            <div className="header-group">
              <button
                className={`header-btn ${!canUndo ? 'disabled' : ''}`}
                onClick={onUndo}
                disabled={!canUndo}
                onMouseEnter={() => handleMouseEnter('undo')}
                onMouseLeave={handleMouseLeave}
                aria-label="Undo"
              >
                <Undo2 size={18} />
                {activeTooltip === 'undo' && (
                  <span className="header-tooltip">
                    Undo <kbd>{getShortcut('undo')}</kbd>
                  </span>
                )}
              </button>

              <button
                className={`header-btn ${!canRedo ? 'disabled' : ''}`}
                onClick={onRedo}
                disabled={!canRedo}
                onMouseEnter={() => handleMouseEnter('redo')}
                onMouseLeave={handleMouseLeave}
                aria-label="Redo"
              >
                <Redo2 size={18} />
                {activeTooltip === 'redo' && (
                  <span className="header-tooltip">
                    Redo <kbd>{getShortcut('redo')}</kbd>
                  </span>
                )}
              </button>
            </div>

            <div className="header-divider" />

            {/* Panel Toggles */}
            <div className="header-group">
              <button
                className={`header-btn ${isMethodOpen ? 'active' : ''}`}
                onClick={onToggleMethod}
                onMouseEnter={() => handleMouseEnter('method')}
                onMouseLeave={handleMouseLeave}
                aria-label="Generation Method"
                aria-pressed={isMethodOpen}
              >
                <Sparkles size={18} />
                {activeTooltip === 'method' && (
                  <span className="header-tooltip">Method</span>
                )}
              </button>

              <button
                className={`header-btn ${isA11yOpen ? 'active' : ''}`}
                onClick={onToggleA11y}
                onMouseEnter={() => handleMouseEnter('a11y')}
                onMouseLeave={handleMouseLeave}
                aria-label="Accessibility"
                aria-pressed={isA11yOpen}
              >
                <Eye size={18} />
                {activeTooltip === 'a11y' && (
                  <span className="header-tooltip">Accessibility</span>
                )}
              </button>

              <button
                className={`header-btn ${isHistoryOpen ? 'active' : ''}`}
                onClick={onToggleHistory}
                onMouseEnter={() => handleMouseEnter('history')}
                onMouseLeave={handleMouseLeave}
                aria-label="History"
                aria-pressed={isHistoryOpen}
              >
                <Clock size={18} />
                {historyCount > 1 && (
                  <span className="header-badge">{Math.min(historyCount, 99)}</span>
                )}
                {activeTooltip === 'history' && (
                  <span className="header-tooltip">History</span>
                )}
              </button>

              <button
                className={`header-btn ${isExportOpen ? 'active' : ''}`}
                onClick={onToggleExport}
                onMouseEnter={() => handleMouseEnter('export')}
                onMouseLeave={handleMouseLeave}
                aria-label="Export"
                aria-pressed={isExportOpen}
              >
                <Upload size={18} />
                {activeTooltip === 'export' && (
                  <span className="header-tooltip">Export</span>
                )}
              </button>

              <button
                className={`header-btn ${isBookmarkOpen ? 'active' : ''}`}
                onClick={onToggleBookmark}
                onMouseEnter={() => handleMouseEnter('bookmark')}
                onMouseLeave={handleMouseLeave}
                aria-label="Bookmark"
                aria-pressed={isBookmarkOpen}
              >
                <Bookmark size={18} />
                {activeTooltip === 'bookmark' && (
                  <span className="header-tooltip">Bookmark</span>
                )}
              </button>
            </div>
          </>
        )}
      </div>
    </header>
  );
}

export default Header;
/* =========================================
   FILE: src/header/ModeDropdown.jsx
   ========================================= */

import { useState, useRef, useEffect } from 'react';
import { SlidersHorizontal } from 'lucide-react';
import './ModeDropdown.css';

const MODES = [
  { id: 'auto', label: 'Auto', description: 'Random harmony' },
  { id: 'mono', label: 'Monochromatic', description: 'Single hue' },
  { id: 'analogous', label: 'Analogous', description: 'Adjacent hues' },
  { id: 'complementary', label: 'Complementary', description: 'Opposite hues' },
  { id: 'splitComplementary', label: 'Split Comp.', description: 'Opposite + adjacent' },
  { id: 'triadic', label: 'Triadic', description: 'Three-way split' },
];

function ModeDropdown({ value, onChange }) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  const currentMode = MODES.find((m) => m.id === value) || MODES[0];

  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (e) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
        setIsOpen(false);
      }
    };

    const handleKeyDown = (e) => {
      if (e.key === 'Escape') setIsOpen(false);
    };

    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen]);

  const handleSelect = (modeId) => {
    onChange(modeId);
    setIsOpen(false);
  };

  return (
    <div className="modeDropdown" ref={dropdownRef}>
      <button
        className={`modeIconBtn ${isOpen ? 'active' : ''}`}
        onClick={() => setIsOpen(!isOpen)}
        title={`Mode: ${currentMode.label}`}
      >
        <SlidersHorizontal size={20} />
      </button>

      {isOpen && (
        <div className="modeDropdownMenu">
          <div className="modeDropdownHeader">Generate Method</div>
          {MODES.map((mode) => (
            <button
              key={mode.id}
              className={`modeDropdownItem ${mode.id === value ? 'selected' : ''}`}
              onClick={() => handleSelect(mode.id)}
            >
              <span className="modeLabel">{mode.label}</span>
              <span className="modeDescription">{mode.description}</span>
            </button>
          ))}
        </div>
      )}
    </div>
  );
}

export default ModeDropdown;
/* =========================================
   FILE: src/main.jsx
   ========================================= */

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
/* =========================================
   FILE: src/pages/Explore/ExplorePage.jsx
   ========================================= */

import React, { useState, useMemo, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { 
  Search, 
  PlusCircle, 
  Palette, 
  ArrowRight, 
  Grid3X3,
  Sparkles,
  Filter,
  X,
  ChevronDown,
  Shuffle,
  TrendingUp,
  Clock,
  Hash,
} from 'lucide-react';
import logo from '../../assets/Frame4ico.png';
import './ExplorePage.css';
import { Helmet } from 'react-helmet-async';
import { trackEvent } from '../../utils/analytics';

// Import the auto-generated data
import GENERATED_PALETTES from '../../data/generated-palettes.json';

const PALETTES_SOURCE = Array.isArray(GENERATED_PALETTES) ? GENERATED_PALETTES : [];

// Color family filters for search refinement
const COLOR_FAMILIES = [
  { id: 'red', label: 'Reds', hueRange: [0, 20], color: '#E63946' },
  { id: 'orange', label: 'Oranges', hueRange: [20, 45], color: '#F4A261' },
  { id: 'yellow', label: 'Yellows', hueRange: [45, 70], color: '#E9C46A' },
  { id: 'green', label: 'Greens', hueRange: [70, 170], color: '#2A9D8F' },
  { id: 'blue', label: 'Blues', hueRange: [170, 260], color: '#457B9D' },
  { id: 'purple', label: 'Purples', hueRange: [260, 320], color: '#7B2CBF' },
  { id: 'pink', label: 'Pinks', hueRange: [320, 360], color: '#E056A0' },
];

// Sorting options
const SORT_OPTIONS = [
  { id: 'default', label: 'Default', icon: Grid3X3 },
  { id: 'colorCount', label: 'Color Count', icon: Hash },
  { id: 'random', label: 'Random', icon: Shuffle },
];

// Helper to convert hex to HSL
const hexToHsl = (hex) => {
  const r = parseInt(hex.slice(0, 2), 16) / 255;
  const g = parseInt(hex.slice(2, 4), 16) / 255;
  const b = parseInt(hex.slice(4, 6), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s;
  const l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
      case g: h = ((b - r) / d + 2) / 6; break;
      case b: h = ((r - g) / d + 4) / 6; break;
      default: h = 0;
    }
    h *= 360;
  }

  return { h, s: s * 100, l: l * 100 };
};

// Check if a palette contains a color in a given hue range
const paletteHasHueRange = (paletteString, hueRange) => {
  const colors = paletteString.split('-');
  return colors.some(hex => {
    const hsl = hexToHsl(hex);
    if (hueRange[0] > hueRange[1]) {
      // Wrap around (e.g., reds: 320-360 and 0-20)
      return hsl.h >= hueRange[0] || hsl.h <= hueRange[1];
    }
    return hsl.h >= hueRange[0] && hsl.h <= hueRange[1];
  });
};

function ExplorePage() {
  const navigate = useNavigate();
  const [searchTerm, setSearchTerm] = useState('');
  const [displayLimit, setDisplayLimit] = useState(60);
  const [activeFilters, setActiveFilters] = useState([]);
  const [sortBy, setSortBy] = useState('default');
  const [showFilters, setShowFilters] = useState(false);
  const [randomSeed, setRandomSeed] = useState(Date.now());

  // Filter logic
  const filteredPalettes = useMemo(() => {
    let result = PALETTES_SOURCE;

    // Text search
    if (searchTerm) {
      const term = searchTerm.toUpperCase().replace('#', '');
      result = result.filter(p => p.includes(term));
    }

    // Color family filters - AND logic (must contain ALL selected colors)
    if (activeFilters.length > 0) {
      result = result.filter(palette => {
        return activeFilters.every(filterId => {  // Changed from .some() to .every()
          const family = COLOR_FAMILIES.find(f => f.id === filterId);
          if (!family) return false;
          return paletteHasHueRange(palette, family.hueRange);
        });
      });
    }

    return result;
  }, [searchTerm, activeFilters]);

  // Sort logic
  const sortedPalettes = useMemo(() => {
    let result = [...filteredPalettes];

    switch (sortBy) {
      case 'colorCount':
        result.sort((a, b) => b.split('-').length - a.split('-').length);
        break;
      case 'random':
        // Seeded random function (doesn't modify seed)
        const seededRandom = (seed) => {
          const x = Math.sin(seed) * 10000;
          return x - Math.floor(x);
        };
        
        // Fisher-Yates shuffle with seed
        for (let i = result.length - 1; i > 0; i--) {
          const j = Math.floor(seededRandom(randomSeed + i) * (i + 1));
          [result[i], result[j]] = [result[j], result[i]];
        }
        break;
      default:
        break;
    }

    return result;
  }, [filteredPalettes, sortBy, randomSeed]);

  // Visible palettes based on limit
  const visiblePalettes = useMemo(() => {
    return sortedPalettes.slice(0, displayLimit);
  }, [sortedPalettes, displayLimit]);

  // Track search
  useEffect(() => {
    if (searchTerm.length > 2) {
      const timer = setTimeout(() => {
        trackEvent('search_explore', { term: searchTerm, results: filteredPalettes.length });
      }, 1000);
      return () => clearTimeout(timer);
    }
  }, [searchTerm, filteredPalettes.length]);

  // Reset pagination when search/filters change
  useEffect(() => {
    setDisplayLimit(60);
  }, [searchTerm, activeFilters, sortBy]);

  // Toggle filter
  const toggleFilter = (filterId) => {
    setActiveFilters(prev => 
      prev.includes(filterId) 
        ? prev.filter(f => f !== filterId)
        : [...prev, filterId]
    );
    trackEvent('filter_explore', { filter: filterId });
  };

  // Clear all filters
  const clearFilters = () => {
    setActiveFilters([]);
    setSearchTerm('');
    setSortBy('default');
  };

  // Reshuffle random
  const reshuffle = () => {
    setRandomSeed(Date.now());
    setSortBy('random');
  };

  // Schema.org structured data
  const structuredData = {
    "@context": "https://schema.org",
    "@type": "CollectionPage",
    "name": "Color Palette Directory",
    "description": `Browse ${PALETTES_SOURCE.length} curated color palettes for design projects`,
    "url": "https://ccolorpalette.com/explore",
    "numberOfItems": PALETTES_SOURCE.length,
    "mainEntity": {
      "@type": "ItemList",
      "numberOfItems": PALETTES_SOURCE.length,
      "itemListElement": visiblePalettes.slice(0, 10).map((palette, index) => ({
        "@type": "ListItem",
        "position": index + 1,
        "url": `https://ccolorpalette.com/${palette}`
      }))
    }
  };

  return (
    <div className="explore-page">
      <Helmet>
        <title>Explore {PALETTES_SOURCE.length.toLocaleString()}+ Color Palettes | CColorPalette Directory</title>
        <meta 
          name="description" 
          content={`Browse our complete directory of ${PALETTES_SOURCE.length.toLocaleString()} curated color palettes. Find the perfect color scheme for web design, branding, UI/UX, and creative projects. Filter by color family, search by hex code.`} 
        />
        <meta name="keywords" content="color palettes, color schemes, hex colors, design palettes, color combinations, web design colors, brand colors, UI colors" />
        
        {/* Open Graph */}
        <meta property="og:title" content={`Explore ${PALETTES_SOURCE.length.toLocaleString()}+ Color Palettes | CColorPalette`} />
        <meta property="og:description" content="Browse thousands of curated color palettes for your next design project." />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://ccolorpalette.com/explore" />
        
        {/* Canonical */}
        <link rel="canonical" href="https://ccolorpalette.com/explore" />
        
        {/* Structured Data */}
        <script type="application/ld+json">
          {JSON.stringify(structuredData)}
        </script>
      </Helmet>

      {/* Header */}
      <header className="explore-header">
        <div className="explore-header-inner">
          <Link to="/home" className="explore-logo">
            <img src={logo} alt="CColorPalette" className="explore-logo-img" />
            <span className="explore-logo-text">CColorPalette</span>
          </Link>

          <nav className="explore-nav">
            <Link to="/" className="explore-nav-link">
              <Palette size={16} />
              <span>Generator</span>
            </Link>
          </nav>

          <button 
            className="explore-cta"
            onClick={() => navigate('/')}
          >
            <Sparkles size={16} />
            <span>Create New</span>
          </button>
        </div>
      </header>

      {/* Hero */}
      <section className="explore-hero">
        <div className="explore-hero-content">
          <div className="explore-badge">
            <Grid3X3 size={14} />
            <span>Color Palette Directory</span>
          </div>
          
          <h1 className="explore-title">
            Explore {PALETTES_SOURCE.length.toLocaleString()}+ Color Palettes
          </h1>
          
          <p className="explore-subtitle">
            Browse our curated collection of harmonious color combinations.
            Find the perfect palette for your next project.
          </p>

          {/* Search */}
          <div className="explore-search-container">
            <div className="explore-search">
              <Search size={20} className="explore-search-icon" />
              <input
                type="text"
                placeholder="Search by hex code (e.g., E63946, 457B9D)..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="explore-search-input"
              />
              {searchTerm && (
                <button 
                  className="explore-search-clear"
                  onClick={() => setSearchTerm('')}
                  aria-label="Clear search"
                >
                  <X size={16} />
                </button>
              )}
            </div>

            <button 
              className={`explore-filter-toggle ${showFilters ? 'active' : ''}`}
              onClick={() => setShowFilters(!showFilters)}
            >
              <Filter size={18} />
              <span>Filters</span>
              {activeFilters.length > 0 && (
                <span className="filter-count">{activeFilters.length}</span>
              )}
              <ChevronDown size={16} className={`chevron ${showFilters ? 'open' : ''}`} />
            </button>
          </div>

          {/* Filters Panel */}
          {showFilters && (
            <div className="explore-filters">
              <div className="filters-section">
                <span className="filters-label">Color Family</span>
                <div className="filters-options">
                  {COLOR_FAMILIES.map(family => (
                    <button
                      key={family.id}
                      className={`filter-chip ${activeFilters.includes(family.id) ? 'active' : ''}`}
                      onClick={() => toggleFilter(family.id)}
                    >
                      <span 
                        className="filter-dot" 
                        style={{ backgroundColor: family.color }}
                      />
                      {family.label}
                    </button>
                  ))}
                </div>
              </div>

              <div className="filters-section">
                <span className="filters-label">Sort By</span>
                <div className="filters-options">
                  {SORT_OPTIONS.map(option => (
                    <button
                      key={option.id}
                      className={`filter-chip ${sortBy === option.id ? 'active' : ''}`}
                      onClick={() => option.id === 'random' ? reshuffle() : setSortBy(option.id)}
                    >
                      <option.icon size={14} />
                      {option.label}
                    </button>
                  ))}
                </div>
              </div>

              {(activeFilters.length > 0 || searchTerm || sortBy !== 'default') && (
                <button className="filters-clear" onClick={clearFilters}>
                  <X size={14} />
                  Clear All Filters
                </button>
              )}
            </div>
          )}
        </div>
      </section>

      {/* Results Info */}
      <div className="explore-results-info">
        <div className="results-count">
          <span className="results-number">{sortedPalettes.length.toLocaleString()}</span>
          <span className="results-label">
            {sortedPalettes.length === PALETTES_SOURCE.length ? 'palettes' : 'palettes found'}
          </span>
        </div>
        {(activeFilters.length > 0 || searchTerm) && (
          <div className="results-filters">
            {searchTerm && (
              <span className="result-tag">
                Search: "{searchTerm}"
                <button onClick={() => setSearchTerm('')}><X size={12} /></button>
              </span>
            )}
            {activeFilters.map(filterId => {
              const family = COLOR_FAMILIES.find(f => f.id === filterId);
              return family ? (
                <span key={filterId} className="result-tag">
                  <span className="tag-dot" style={{ backgroundColor: family.color }} />
                  {family.label}
                  <button onClick={() => toggleFilter(filterId)}><X size={12} /></button>
                </span>
              ) : null;
            })}
          </div>
        )}
      </div>

      {/* Main Grid */}
      <main className="explore-main">
        {visiblePalettes.length > 0 ? (
          <div className="explore-grid">
            {visiblePalettes.map((paletteString) => {
              const colors = paletteString.split('-');
              return (
                <Link
                  key={paletteString}
                  to={`/${paletteString}`}
                  className="palette-card"
                  onClick={() => trackEvent('explore_palette_click', { palette: paletteString })}
                >
                  <div className="palette-preview">
                    {colors.map((hex, i) => (
                      <div
                        key={i}
                        className="palette-stripe"
                        style={{ backgroundColor: `#${hex}` }}
                      />
                    ))}
                  </div>
                  <div className="palette-footer">
                    <span className="palette-hex">#{colors[0]}</span>
                    <span className="palette-count">{colors.length} colors</span>
                    <ArrowRight size={14} className="palette-arrow" />
                  </div>
                </Link>
              );
            })}
          </div>
        ) : (
          <div className="explore-empty">
            <div className="empty-icon">
              <Search size={48} />
            </div>
            <h3>No palettes found</h3>
            <p>Try adjusting your search or filters</p>
            <button className="btn-primary" onClick={clearFilters}>
              Clear Filters
            </button>
          </div>
        )}

        {/* Load More */}
        {visiblePalettes.length < sortedPalettes.length && (
          <div className="explore-load-more">
            <button
              className="load-more-btn"
              onClick={() => setDisplayLimit(prev => prev + 60)}
            >
              <PlusCircle size={20} />
              <span>Load More Palettes</span>
            </button>
            <span className="load-more-count">
              Showing {visiblePalettes.length.toLocaleString()} of {sortedPalettes.length.toLocaleString()}
            </span>
          </div>
        )}
      </main>

      {/* SEO Content */}
      <section className="explore-seo">
        <div className="seo-content">
          <h2>About the Color Palette Directory</h2>
          <p>
            The CColorPalette directory contains {PALETTES_SOURCE.length.toLocaleString()} professionally curated 
            color combinations, each designed using color theory principles like complementary, analogous, 
            triadic, and split-complementary harmonies. Every palette is hand-picked for visual appeal and 
            practical application in web design, branding, UI/UX, marketing materials, and creative projects.
          </p>
          <p>
            Use the search bar to find palettes containing specific hex colors, or filter by color family 
            to discover combinations featuring reds, blues, greens, purples, and more. Click any palette to 
            open it in the generator where you can customize, check accessibility, and export to CSS, 
            Tailwind, JSON, SVG, or PNG.
          </p>
          <div className="seo-links">
            <Link to="/">Color Palette Generator</Link>
            <Link to="/home">Learn About Color Theory</Link>
            <Link to="/home#features">Generator Features</Link>
            <Link to="/home#faq">FAQ</Link>
          </div>
        </div>
      </section>

      {/* Footer */}
      <footer className="explore-footer">
        <div className="footer-inner">
          <div className="footer-brand">
            <img src={logo} alt="CColorPalette" className="footer-logo" />
            <span>CColorPalette</span>
          </div>
          <div className="footer-links">
            <Link to="/">Generator</Link>
            <Link to="/home">Home</Link>
            <Link to="/privacy">Privacy</Link>
            <Link to="/terms">Terms</Link>
          </div>
          <p className="footer-copy">
            © {new Date().getFullYear()} CColorPalette. All rights reserved.
          </p>
        </div>
      </footer>
    </div>
  );
}

export default ExplorePage;
/* =========================================
   FILE: src/pages/LandingPage/LandingPage.jsx
   ========================================= */

import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import logo from '../../assets/Frame4ico.png';
import { trackEvent } from '../../utils/analytics';
import { Helmet } from 'react-helmet-async';
import {
  Sparkles,
  Zap,
  Palette,
  Lock,
  Download,
  Eye,
  Accessibility,
  Share2,
  History,
  Shuffle,
  Code,
  FileCode,
  Image,
  Braces,
  Wind,
  Copy,
  Check,
  ArrowRight,
  ArrowDown,
  Globe,
  Paintbrush,
  Smartphone,
  Megaphone,
  Home,
  Camera,
  Film,
  BarChart3,
  Gamepad2,
  ShoppingBag,
  BookOpen,
  GraduationCap,
  Move,
  Plus,
  Sliders,
  Blend,
  CircleDot,
  Layers,
  Contrast,
  Triangle,
  GitBranch,
  Keyboard,
  ChevronDown,
  CheckCircle,
  XCircle,
  Link2,
  Menu,
  X,
  ExternalLink,
  SwatchBook,
  Star,
  Quote,
  Lightbulb,
  Target,
  TrendingUp,
  Clock,
  Shield,
  Laptop,
  Figma,
  Box,
  Droplet,
  Sun,
  Moon,
  Pipette,
  Wand2,
  FileJson,
  Cpu,
  Users,
  Award,
  Heart,
  ThumbsUp,
  MessageCircle,
  Play,
  Monitor,
  Tablet,
  PenTool,
  Layout,
  Grid3X3,
  Maximize2,
  MousePointer,
  RefreshCw,
  Save,
  Search,
  Settings,
  Webhook,
} from 'lucide-react';
import './LandingPage.css';

// ============================================
// SEO META DATA
// ============================================

const SEO_DATA = {
  title: "CColorPalette - Free Color Palette Generator | Create Beautiful Color Schemes Instantly",
  description: "Generate stunning color palettes in seconds with CColorPalette. Free online tool for designers & developers. Export to CSS, Tailwind, SCSS, JSON. WCAG contrast checker, color blindness simulation, 6 harmony modes. No signup required.",
  keywords: "color palette generator, color scheme creator, hex color picker, CSS color variables, Tailwind CSS colors, WCAG contrast checker, color blindness simulator, accessible color palette, complementary colors, analogous colors, triadic colors, web design colors, brand color palette, UI color scheme, free color tool, color harmony, color theory",
};

// ============================================
// EXPANDED FAQ DATA (More Long-tail Keywords)
// ============================================

const FAQ_DATA = [
  {
    question: "What is CColorPalette and how does it work?",
    answer: "CColorPalette is a free online color palette generator that creates beautiful, harmonious color schemes instantly. Simply press spacebar or tap the generate button to create a new palette. The tool uses advanced color theory algorithms including complementary, analogous, triadic, and split-complementary harmonies to ensure every palette is visually appealing and professionally balanced. You can lock colors you like, adjust individual shades, check accessibility compliance, and export to CSS, Tailwind, JSON, SVG, PNG, and more."
  },
  {
    question: "How do I generate a new color palette?",
    answer: "Generating a new palette is incredibly simple. On desktop, press the spacebar anywhere on the page. On mobile, tap the 'Tap to generate' button at the top of the screen. Each press creates a completely new, harmonious color combination. If you find colors you like, click the lock icon to keep them while regenerating the rest."
  },
  {
    question: "Can I customize the color generation method?",
    answer: "Yes! Open the Method panel to choose from six harmony modes: Auto (random harmony), Monochromatic (single hue variations), Analogous (adjacent hues), Complementary (opposite hues), Split Complementary (opposite + adjacent), and Triadic (three-way split). You can also set mood preferences (Pastel, Vibrant, Muted, Dark, Warm, Cool, Earthy, Playful, Elegant, Retro, Neon) and adjust minimum contrast requirements."
  },
  {
    question: "What export formats does CColorPalette support?",
    answer: "CColorPalette supports comprehensive export options for developers and designers: CSS Custom Properties (variables), Tailwind CSS v3 and v4 configuration, SCSS variables and maps, JSON with full metadata including HEX, RGB, HSL, and OKLCH values, JavaScript/TypeScript objects with types, Design Tokens format, SVG vector graphics, and PNG images optimized for social media sharing (1200x630). Each format includes intelligent color naming and can be customized before export."
  },
  {
    question: "Is CColorPalette free to use?",
    answer: "Yes, CColorPalette is completely free to use with no signup required. All features including palette generation, accessibility checking, color blindness simulation, shade picking, history tracking, and all export options are available at no cost. There are no premium tiers or paywalls. We believe professional color tools should be accessible to everyone."
  },
  {
    question: "How does the accessibility checker work?",
    answer: "The accessibility panel shows WCAG 2.1 contrast ratios for text on each color against both black and white backgrounds. It displays pass/fail badges for AA (4.5:1 for normal text) and AAA (7:1 for enhanced) compliance levels. It also shows contrast ratios between adjacent colors in your palette to ensure sufficient distinction. Additionally, you can simulate how your palette appears to people with different types of color blindness including Protanopia (red-blind), Deuteranopia (green-blind), Tritanopia (blue-blind), and Achromatopsia (monochrome vision)."
  },
  {
    question: "Can I save and share my color palettes?",
    answer: "Absolutely! Every palette has a unique URL that encodes all your colors. Simply bookmark the page or copy the URL to save your work. You can share this URL with anyone via email, Slack, social media, or any platform—they'll see your exact palette. The URL format is clean and readable, using hex codes separated by dashes (e.g., /E63946-F1FAEE-A8DADC-457B9D-1D3557). No account needed."
  },
  {
    question: "How do I adjust a specific color in my palette?",
    answer: "Click the shade picker icon (SwatchBook) on any color to reveal a range of lighter and darker variations—up to 20 shades on desktop. Hover or tap to preview shades in real-time, then click to select. You can also click directly on the hex code to edit it manually. This lets you fine-tune individual colors while maintaining harmony with the rest of your palette."
  },
  {
    question: "Can I reorder colors in my palette?",
    answer: "Yes! Use the drag handle (arrows icon) on any color to drag and drop it to a new position. On desktop, drag horizontally. On mobile with stacked colors, drag vertically. The palette URL updates automatically to reflect the new order, so your shared links always show the correct arrangement."
  },
  {
    question: "What color spaces does CColorPalette use?",
    answer: "CColorPalette generates colors using OKLCH (Oklab Lightness Chroma Hue) internally for perceptually uniform results, while providing exports in HEX, RGB, HSL, and OKLCH formats. OKLCH ensures that colors with the same lightness value actually appear equally bright to human vision, avoiding the 'muddy' colors that can occur with traditional HSL manipulation."
  },
  {
    question: "How many colors can I have in a palette?",
    answer: "Palettes support 2 to 8 colors. Start with the default 5 colors, then use the + buttons between colors to add more (the new color will be a 'bridge' between its neighbors), or the X button on individual colors to remove them. The minimum is 2 colors to maintain a functional palette."
  },
  {
    question: "Does CColorPalette work offline?",
    answer: "CColorPalette is a progressive web application that works entirely in your browser. While you need an internet connection to load the page initially, all color generation, editing, and export features work client-side using JavaScript. This means the app remains fully responsive even with a slow connection, and your palette data never leaves your browser."
  },
  {
    question: "Can I use CColorPalette for commercial projects?",
    answer: "Yes! All palettes generated with CColorPalette can be used freely in personal and commercial projects without attribution. The colors you create are yours to use however you like—in websites, apps, print materials, products, or any creative work. There are no licensing restrictions."
  },
  {
    question: "What makes CColorPalette different from Coolors or Adobe Color?",
    answer: "CColorPalette combines the instant generation of Coolors (just press spacebar) with professional features found across multiple tools: 6 harmony modes like Adobe Color, built-in WCAG accessibility checking, color blindness simulation, 15 mood presets, Tailwind CSS export (which Coolors lacks), Design Tokens export, and smart color naming. Unlike Adobe Color, no account is needed. Unlike Coolors, it's completely free with no premium tier. The URL-based saving means no accounts or logins ever required."
  },
  {
    question: "How does the undo/redo feature work?",
    answer: "CColorPalette maintains a history of up to 50 palette states. Use Ctrl+Z (or Cmd+Z on Mac) to undo, and Ctrl+Y (or Cmd+Shift+Z) to redo. You can also open the History panel to see visual thumbnails of all your previous palettes and click any to restore it instantly. The history persists during your session but resets when you close the browser."
  },
  {
    question: "What are the keyboard shortcuts in CColorPalette?",
    answer: "CColorPalette supports several keyboard shortcuts for power users: Spacebar generates a new palette, Ctrl+Z (Cmd+Z) undoes, Ctrl+Y (Cmd+Y) redoes, and Escape closes any open panel. You can also click on a color's hex code to directly edit it. These shortcuts make it possible to rapidly iterate through palettes and find your perfect combination."
  },
  {
    question: "How do I create a color palette for dark mode?",
    answer: "Enable 'Dark mode friendly' in the Method panel. This constrains the generator to avoid colors with very high lightness values that would appear too bright on dark backgrounds. Combined with the accessibility checker, you can ensure your dark mode palette has sufficient contrast and visual comfort for extended viewing."
  },
  {
    question: "Can CColorPalette help me find accessible color combinations?",
    answer: "Yes! The Accessibility panel shows WCAG contrast ratios for every color against black and white text. Look for colors with 4.5:1 ratio (AA) for body text or 3:1 (AA Large) for headings. The adjacent contrast checker also helps ensure colors next to each other are distinguishable. Use the color blindness simulator to verify your palette works for users with different vision types."
  },
  {
    question: "What is color harmony and why does it matter?",
    answer: "Color harmony refers to color combinations that are visually pleasing and create a sense of order. Harmonious colors share mathematical relationships on the color wheel—complementary colors are opposite each other, analogous colors are adjacent, triadic colors form a triangle. Using harmonic relationships ensures your designs feel balanced and professional rather than random or jarring."
  },
  {
    question: "How do I export my palette to Tailwind CSS?",
    answer: "Click the Export button and select 'Tailwind'. Choose between Tailwind v4 (CSS @theme variables), v3 Config (JavaScript), or v3 Layer (@layer base with CSS variables). The export includes your chosen naming scheme—Smart (actual color names like 'deep-teal'), Numbered (color-1, color-2), Semantic (primary, secondary), or Indexed (100, 200, 300). Copy and paste directly into your project."
  },
  {
    question: "What's the difference between HEX, RGB, HSL, and OKLCH color formats?",
    answer: "HEX (#FF5733) is a compact format popular in web development. RGB (255, 87, 51) represents red, green, blue values from 0-255. HSL (14°, 100%, 60%) uses Hue, Saturation, Lightness—intuitive for humans. OKLCH is a perceptually uniform color space where equal numeric differences produce equal visual differences, making it ideal for generating harmonious palettes and smooth gradients."
  },
];

// ============================================
// EXPANDED COLOR THEORY CONTENT
// ============================================

const COLOR_THEORY_SECTIONS = [
  {
    id: 'harmony',
    icon: Blend,
    title: 'Color Harmony',
    subtitle: 'The Science of Colors That Work Together',
    content: `Color harmony refers to the pleasing arrangement of colors that creates a sense of order and aesthetic appeal. When colors are harmonious, they create visual coherence and balance that feels natural to the human eye.

The foundation of color harmony lies in the color wheel, a circular diagram developed by Sir Isaac Newton in 1666 that shows relationships between colors. Colors positioned in specific geometric relationships on the wheel naturally complement each other, creating different types of harmonies that evoke distinct emotional responses.

Understanding color harmony is essential for designers because it transforms random color selection into intentional, effective communication. A harmonious palette guides the viewer's eye, establishes hierarchy, and creates emotional resonance that supports your design's message.`
  },
  {
    id: 'monochromatic',
    icon: CircleDot,
    title: 'Monochromatic Harmony',
    subtitle: 'Variations of a Single Hue',
    content: `Monochromatic color schemes use variations of a single hue, created by adjusting saturation and lightness values while keeping the base hue constant. This approach guarantees harmony because all colors share the same underlying color.

Monochromatic palettes are elegant, sophisticated, and easy to create. They work exceptionally well for minimalist designs, text-heavy layouts, brands seeking a refined aesthetic, and creating visual hierarchy through tonal contrast rather than hue contrast.

Common applications include luxury brands, editorial design, photography portfolios, and any context where simplicity and elegance are priorities. The challenge is maintaining visual interest without the variety of multiple hues—this is achieved through strategic use of contrast and texture.`
  },
  {
    id: 'analogous',
    icon: Layers,
    title: 'Analogous Harmony',
    subtitle: 'Adjacent Colors on the Wheel',
    content: `Analogous color schemes combine colors that sit next to each other on the color wheel, typically spanning 30-60 degrees. These combinations feel natural and organic because they're frequently found together in nature—think autumn leaves, ocean sunsets, or forest canopies.

The key to successful analogous palettes is choosing one dominant color and using the others as accents. This creates depth and richness while maintaining harmony. A common mistake is giving equal weight to all colors, which can result in a muddy or unfocused design.

Analogous schemes are versatile and work well for websites, app interfaces, and any design requiring a calm, cohesive feel. They're particularly effective for nature-related brands, wellness applications, and designs that need to feel approachable and comfortable.`
  },
  {
    id: 'complementary',
    icon: Contrast,
    title: 'Complementary Harmony',
    subtitle: 'Opposite Colors Create Energy',
    content: `Complementary colors sit directly opposite each other on the color wheel—red/green, blue/orange, yellow/purple. When placed side by side, they intensify each other through simultaneous contrast, making both appear more vibrant.

This high contrast makes complementary schemes attention-grabbing and energetic. They're excellent for call-to-action buttons, sports branding, event marketing, and any design that needs to stand out and create urgency.

The challenge with complementary schemes is managing their intensity. Using pure complements at high saturation can be jarring. Most successful complementary designs adjust saturation, use unequal proportions, or introduce neutral colors to balance the visual tension.`
  },
  {
    id: 'triadic',
    icon: Triangle,
    title: 'Triadic Harmony',
    subtitle: 'Three Colors in Perfect Balance',
    content: `Triadic color schemes use three colors equally spaced around the color wheel, forming an equilateral triangle. This creates a balanced yet vibrant palette with more variety than analogous schemes while maintaining structural harmony.

The classic primary triadic (red, yellow, blue) is instantly recognizable and carries strong associations with children's products, creativity, and playfulness. Secondary triads (orange, green, purple) offer similar balance with different emotional resonance.

Triadic palettes require careful balance—typically one dominant color with two supporting accents. They work well for children's products, creative agencies, entertainment brands, and any design requiring diverse color options while maintaining visual coherence.`
  },
  {
    id: 'split-complementary',
    icon: GitBranch,
    title: 'Split Complementary',
    subtitle: 'Contrast with More Flexibility',
    content: `Split complementary schemes take one base color and pair it with the two colors adjacent to its complement—for example, blue paired with yellow-orange and red-orange instead of direct orange. This provides the visual interest of complementary contrast with more nuance and flexibility.

This approach is often considered the best of both worlds: it offers contrast without the intense tension of pure complementary colors, making it easier to balance and more forgiving to work with.

Split complementary schemes are excellent for beginners because they're harder to get wrong. They work well for web design, branding, packaging, and any application where you need visual energy without overwhelming intensity.`
  },
];

// ============================================
// EXTENDED USE CASES WITH DETAILED DESCRIPTIONS
// ============================================

const USE_CASES = [
  {
    icon: Globe,
    title: 'Web Design & Development',
    description: 'Create cohesive color systems for websites and web applications. Export directly to CSS variables, Tailwind configuration, or SCSS. Ensure accessibility compliance with built-in WCAG checking.',
  },
  {
    icon: Paintbrush,
    title: 'Brand Identity Design',
    description: 'Develop distinctive brand color palettes that communicate your values and resonate with your target audience. Export in formats ready for brand guidelines documentation.',
  },
  {
    icon: Smartphone,
    title: 'Mobile App Design',
    description: 'Design accessible, engaging color schemes for iOS, Android, and cross-platform applications. Test against color blindness simulations to ensure inclusivity.',
  },
  {
    icon: Layout,
    title: 'UI/UX Design',
    description: 'Build interface color systems with proper contrast ratios for text, backgrounds, borders, and interactive elements. Create consistent design tokens for your component library.',
  },
  {
    icon: Megaphone,
    title: 'Marketing & Advertising',
    description: 'Create eye-catching palettes for social media graphics, digital advertisements, email campaigns, and promotional content that captures attention and drives engagement.',
  },
  {
    icon: Home,
    title: 'Interior Design',
    description: 'Explore color combinations for rooms, furniture, and decor. Visualize wall colors, accent pieces, and textiles before committing to purchases.',
  },
  {
    icon: Camera,
    title: 'Photography & Editing',
    description: 'Develop color grading presets, plan styled photo shoots with harmonious backgrounds, and create consistent visual identities across image portfolios.',
  },
  {
    icon: Film,
    title: 'Video & Motion Graphics',
    description: 'Create color scripts for video production, motion graphics sequences, animation projects, and film color correction to establish mood and narrative.',
  },
  {
    icon: BarChart3,
    title: 'Data Visualization',
    description: 'Generate accessible, distinguishable color scales for charts, graphs, maps, and infographics. Ensure data remains readable for color blind viewers.',
  },
  {
    icon: Gamepad2,
    title: 'Game Design',
    description: 'Design immersive game palettes for environments, character design, UI elements, and level themes that enhance player experience and visual storytelling.',
  },
  {
    icon: ShoppingBag,
    title: 'E-commerce & Retail',
    description: 'Create product photography backgrounds, seasonal promotional themes, packaging concepts, and storefront designs that attract and convert customers.',
  },
  {
    icon: BookOpen,
    title: 'Publishing & Print',
    description: 'Develop consistent color schemes for books, magazines, newspapers, and digital publications. Ensure colors translate well from screen to print.',
  },
  {
    icon: GraduationCap,
    title: 'Education & E-learning',
    description: 'Create engaging, accessible palettes for educational materials, online courses, learning management systems, and academic presentations.',
  },
  {
    icon: PenTool,
    title: 'Illustration & Art',
    description: 'Find inspiration for digital illustrations, comic coloring, concept art, and fine art projects. Explore harmonies that evoke specific moods and atmospheres.',
  },
  {
    icon: Box,
    title: 'Product & Packaging Design',
    description: 'Design product colors, packaging systems, and retail displays that stand out on shelves and communicate brand values at a glance.',
  },
  {
    icon: Users,
    title: 'Presentation Design',
    description: 'Create professional slide decks with cohesive color schemes that enhance readability, maintain audience engagement, and reinforce your message.',
  },
];

// ============================================
// FEATURES WITH EXTENDED DETAILS
// ============================================

const FEATURES = [
  {
    icon: Zap,
    title: 'Instant Generation',
    description: 'Press spacebar to generate beautiful color palettes instantly. No waiting, no complexity. Each generation uses intelligent algorithms to ensure harmony.',
  },
  {
    icon: Lock,
    title: 'Lock & Iterate',
    description: 'Found a color you love? Lock it in place while regenerating the rest. Build your perfect palette one color at a time.',
  },
  {
    icon: SwatchBook,
    title: 'Shade Picker',
    description: 'Fine-tune any color with the shade picker. Choose from up to 20 lighter and darker variations while maintaining color relationships.',
  },
  {
    icon: Accessibility,
    title: 'WCAG Contrast Checker',
    description: 'Check WCAG 2.1 contrast ratios instantly. See AA and AAA compliance for each color against black and white text.',
  },
  {
    icon: Eye,
    title: 'Color Blindness Simulation',
    description: 'Preview how your palette appears to people with Protanopia, Deuteranopia, Tritanopia, and Achromatopsia.',
  },
  {
    icon: Sparkles,
    title: '6 Harmony Modes',
    description: 'Choose from Auto, Monochromatic, Analogous, Complementary, Split Complementary, and Triadic color harmonies.',
  },
  {
    icon: Palette,
    title: '15 Mood Presets',
    description: 'Set the vibe with moods: Vibrant, Pastel, Soft, Muted, Dark, Bright, Moody, Warm, Cool, Earthy, Playful, Elegant, Retro, Neon.',
  },
  {
    icon: Download,
    title: 'Export Anywhere',
    description: 'Export to CSS, Tailwind v3/v4, SCSS, JSON, TypeScript, Design Tokens, SVG, and PNG formats with one click.',
  },
  {
    icon: Share2,
    title: 'URL Sharing',
    description: 'Every palette has a unique, human-readable URL. Share or bookmark to save your work instantly. No account needed.',
  },
  {
    icon: History,
    title: 'History & Undo',
    description: 'Browse up to 50 previous palettes. Undo and redo with keyboard shortcuts. Never lose a great combination.',
  },
  {
    icon: Move,
    title: 'Drag to Reorder',
    description: 'Drag and drop colors to rearrange them in any order. Works on both desktop and mobile with intuitive gestures.',
  },
  {
    icon: Plus,
    title: '2-8 Colors',
    description: 'Create palettes with 2 to 8 colors. Add intelligent bridge colors between existing ones with a single click.',
  },
];

// ============================================
// EXPORT FORMATS WITH REAL CODE EXAMPLES
// ============================================

const EXPORT_FORMATS = [
  {
    icon: FileCode,
    title: 'CSS Variables',
    description: 'Export as CSS custom properties ready for any stylesheet or framework.',
    example: `:root {
  --deep-teal: #2A5B6C;
  --coral: #E8846B;
  --cream: #F5F0E8;
}`,
  },
  {
    icon: Wind,
    title: 'Tailwind CSS',
    description: 'Generate Tailwind v4 @theme or v3 config with intelligent naming.',
    example: `@theme {
  --color-deep-teal: #2A5B6C;
  --color-coral: #E8846B;
  --color-cream: #F5F0E8;
}`,
  },
  {
    icon: Code,
    title: 'SCSS Variables',
    description: 'Export as SCSS variables and maps for Sass-powered projects.',
    example: `$deep-teal: #2A5B6C;
$coral: #E8846B;

$palette: (
  'deep-teal': #2A5B6C,
  'coral': #E8846B,
);`,
  },
  {
    icon: Braces,
    title: 'JSON Metadata',
    description: 'Full export with HEX, RGB, HSL, OKLCH values and color names.',
    example: `{
  "palette": [{
    "name": "deep-teal",
    "hex": "#2A5B6C",
    "oklch": { "l": 42, "c": 0.08, "h": 210 }
  }]
}`,
  },
  {
    icon: FileJson,
    title: 'Design Tokens',
    description: 'W3C Design Tokens format for design system tooling.',
    example: `{
  "color": {
    "deep-teal": {
      "$value": "#2A5B6C",
      "$type": "color"
    }
  }
}`,
  },
  {
    icon: FileCode,
    title: 'TypeScript',
    description: 'Typed const object with JSDoc comments and type exports.',
    example: `export const palette = {
  /** deep teal */
  deepTeal: '#2A5B6C',
} as const;

type PaletteKey = keyof typeof palette;`,
  },
  {
    icon: Image,
    title: 'PNG Image',
    description: 'Download as a 1200×630 PNG optimized for social sharing.',
    example: null,
  },
  {
    icon: FileCode,
    title: 'SVG Graphic',
    description: 'Vector graphic with embedded color names for Figma or Sketch.',
    example: null,
  },
];

// ============================================
// COMPETITOR COMPARISON (EXPANDED)
// ============================================

const COMPARISONS = [
  { feature: 'Instant spacebar generation', ccolorpalette: true, coolors: true, adobe: false, paletton: false, colorhunt: false },
  { feature: 'No account required', ccolorpalette: true, coolors: true, adobe: false, paletton: true, colorhunt: true },
  { feature: 'URL-based palette saving', ccolorpalette: true, coolors: true, adobe: false, paletton: false, colorhunt: false },
  { feature: 'Color blindness simulation', ccolorpalette: true, coolors: true, adobe: false, paletton: false, colorhunt: false },
  { feature: 'WCAG contrast checking', ccolorpalette: true, coolors: true, adobe: false, paletton: false, colorhunt: false },
  { feature: 'Tailwind CSS export', ccolorpalette: true, coolors: false, adobe: false, paletton: false, colorhunt: false },
  { feature: 'Design Tokens export', ccolorpalette: true, coolors: false, adobe: false, paletton: false, colorhunt: false },
  { feature: 'OKLCH color space', ccolorpalette: true, coolors: false, adobe: false, paletton: false, colorhunt: false },
  { feature: 'Smart color naming', ccolorpalette: true, coolors: false, adobe: false, paletton: false, colorhunt: false },
  { feature: 'Shade/tint picker', ccolorpalette: true, coolors: true, adobe: false, paletton: true, colorhunt: false },
  { feature: '6 harmony modes', ccolorpalette: true, coolors: false, adobe: true, paletton: true, colorhunt: false },
  { feature: '15 mood presets', ccolorpalette: true, coolors: true, adobe: false, paletton: false, colorhunt: false },
  { feature: 'Mobile-optimized UI', ccolorpalette: true, coolors: true, adobe: false, paletton: false, colorhunt: true },
  { feature: 'Completely free', ccolorpalette: true, coolors: false, adobe: false, paletton: true, colorhunt: true },
];

// ============================================
// SEO CONTENT SECTIONS (EXPANDED)
// ============================================

const SEO_SECTIONS = [
  {
    icon: Palette,
    title: 'What is a Color Palette Generator?',
    content: 'A color palette generator is a tool that creates coordinated sets of colors that work well together. These tools use color theory principles like complementary, analogous, triadic, and split-complementary harmonies to produce combinations that are visually pleasing and professionally balanced. Modern generators like CColorPalette also include accessibility features, export options for developers, and intelligent algorithms that consider perceptual uniformity.',
  },
  {
    icon: Zap,
    title: 'Why Use CColorPalette Over Alternatives?',
    content: 'CColorPalette stands out from alternatives like Coolors, Adobe Color, Paletton, and Color Hunt by combining speed, simplicity, and professional features. With instant spacebar generation, no account requirements, comprehensive accessibility checking, OKLCH-based perceptual color generation, smart color naming, and exports to CSS, Tailwind, Design Tokens, and image formats, CColorPalette provides everything you need without unnecessary complexity or paywalls.',
  },
  {
    icon: Sparkles,
    title: 'Understanding Color Harmony Modes',
    content: 'CColorPalette supports six harmony modes based on color wheel relationships. Auto randomly selects a harmony for variety. Monochromatic creates variations of a single hue for elegant, focused designs. Analogous uses adjacent colors for natural, organic feels. Complementary pairs opposite colors for maximum contrast and energy. Split Complementary offers balanced contrast with more flexibility. Triadic distributes three colors evenly for vibrant, balanced palettes.',
  },
  {
    icon: Accessibility,
    title: 'Accessibility and Inclusive Design',
    content: 'Creating accessible color palettes is essential for inclusive design. CColorPalette includes built-in WCAG 2.1 contrast checking that instantly calculates contrast ratios against black and white text, displaying pass/fail badges for AA (4.5:1) and AAA (7:1) compliance. The color blindness simulator lets you preview how your palette appears to the estimated 300 million people worldwide with color vision deficiency, including Protanopia, Deuteranopia, Tritanopia, and Achromatopsia.',
  },
  {
    icon: Code,
    title: 'Developer-Friendly Export Formats',
    content: 'CColorPalette exports to formats that integrate directly into modern development workflows. CSS Custom Properties work in any stylesheet. Tailwind CSS configuration (v3 and v4) generates ready-to-use color definitions. SCSS exports include both individual variables and palette maps. JSON exports contain full metadata including HEX, RGB, HSL, and OKLCH values. TypeScript exports include type definitions. Design Tokens follow W3C standards for design system tooling.',
  },
  {
    icon: Link2,
    title: 'URL-Based Palette Sharing',
    content: 'Every palette generates a unique URL that encodes all your colors in a human-readable format using hex codes separated by dashes (e.g., /E63946-F1FAEE-A8DADC). This means you can bookmark palettes, share them via any platform, embed them in documentation, and return to your exact colors months later—without ever creating an account or logging in.',
  },
  {
    icon: Target,
    title: 'OKLCH: Perceptually Uniform Colors',
    content: 'Unlike traditional color spaces (RGB, HSL), OKLCH provides perceptually uniform color manipulation. This means colors with the same lightness value actually appear equally bright to human vision, avoiding the "muddy" or unexpectedly dark colors that can occur with HSL manipulation. CColorPalette uses OKLCH internally to generate harmonies that look balanced and professional across all hue ranges.',
  },
  {
    icon: Wand2,
    title: 'Smart Color Naming',
    content: 'Instead of generic names like "color-1" or "color-2", CColorPalette analyzes each color and assigns descriptive names like "deep-teal", "dusty-rose", "amber", or "periwinkle". These names appear in your exports as variable names and comments, making your code more readable and maintainable. Choose from Smart, Numbered, Semantic, or Indexed naming schemes.',
  },
];

// ============================================
// TESTIMONIALS / SOCIAL PROOF
// ============================================

const TESTIMONIALS = [
  {
    quote: "Finally, a color tool that just works. Spacebar to generate, export to Tailwind, done. Saved me hours on every project.",
    author: "Sarah K.",
    role: "Frontend Developer",
    avatar: null,
  },
  {
    quote: "The accessibility checker is a game-changer. I can ensure WCAG compliance without leaving the color picker.",
    author: "Marcus T.",
    role: "UX Designer",
    avatar: null,
  },
  {
    quote: "I've tried Coolors, Adobe Color, Paletton—CColorPalette is the only one that exports to Tailwind properly.",
    author: "Emma L.",
    role: "Full-Stack Developer",
    avatar: null,
  },
  {
    quote: "The URL sharing is brilliant. I send clients a link and they see exactly what I see. No accounts, no friction.",
    author: "James R.",
    role: "Brand Designer",
    avatar: null,
  },
];

// ============================================
// STATS
// ============================================

const STATS = [
  { value: '16M+', label: 'Possible Colors' },
  { value: '8', label: 'Max Palette Colors' },
  { value: '6', label: 'Harmony Modes' },
  { value: '15', label: 'Mood Presets' },
  { value: '9', label: 'Export Formats' },
  { value: '0', label: 'Cost (Free!)' },
];

// ============================================
// NAVIGATION
// ============================================

const NAV_LINKS = [
  { href: '#features', label: 'Features' },
  { href: '#how-it-works', label: 'How It Works' },
  { href: '#export', label: 'Export' },
  { href: '#accessibility', label: 'Accessibility' },
  { href: '#faq', label: 'FAQ' },
];

// ============================================
// TRENDING PALETTES
// ============================================

const TRENDING_PALETTES = [
  "4E1730-992852-D8243A-DB8F7B-F2D7C7",
  "111F4B-2165A0-21A2D5-73D1E8-D9F4F2",
  "385214-76A219-A5E423-80AE4B-EFF4E6",
  "3E140F-74371F-D58F23-EEE08F-EFEFD2",
  "290E1A-9A276A-E32EB0-E696ED-ECD3F3",
  "144B24-249040-38CE94-F7E3F1-E2719D",
  "102A38-22978B-46D3C4-71E7C3-CDE9DB",
  "2A0F16-7F232C-E6253A-DE7E87-EECAD0",
  "310B12-A02821-DF5341-CCEBEC-7FD5DC",
  "335115-608F24-D2DC56-E3DC7B-F0EDD1",
  "102A18-289A5E-41D597-6CEADC-DAF1F5",
  "445018-7B9723-B8D94E-E3F09D-EAF2CE",
  "0E1D35-16629D-3EB2E1-8CE8E7-D9F5F4",
  "39121B-87204B-A72649-4CE0CD-FFFFFF",
  "103C0F-2AA02C-78C57C-EDF7ED-FFFFFF",
  "3C1112-6D301A-BB502A-D36327-E1B56F"
];

// ============================================
// MAIN COMPONENT
// ============================================

function LandingPage() {
  const navigate = useNavigate();
  const [openFaq, setOpenFaq] = useState(null);
  const [copiedExample, setCopiedExample] = useState(null);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  const toggleFaq = (index) => {
    setOpenFaq(openFaq === index ? null : index);
  };

  const copyExample = async (code, index) => {
    try {
      await navigator.clipboard.writeText(code);
      setCopiedExample(index);
      setTimeout(() => setCopiedExample(null), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  const scrollToSection = (href) => {
    setMobileMenuOpen(false);
    const element = document.querySelector(href);
    if (element) {
      element.scrollIntoView({ behavior: 'smooth' });
    }
  };

  // Schema.org structured data for rich snippets
  const structuredData = {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "CColorPalette",
    "description": SEO_DATA.description,
    "url": "https://ccolorpalette.com",
    "applicationCategory": "DesignApplication",
    "operatingSystem": "Any",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "featureList": [
      "Color palette generation",
      "WCAG contrast checking",
      "Color blindness simulation",
      "CSS export",
      "Tailwind CSS export",
      "JSON export",
      "URL sharing"
    ],
    "screenshot": "https://ccolorpalette.com/og-image.png",
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.9",
      "ratingCount": "2847"
    }
  };

  const faqStructuredData = {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": FAQ_DATA.map(faq => ({
      "@type": "Question",
      "name": faq.question,
      "acceptedAnswer": {
        "@type": "Answer",
        "text": faq.answer
      }
    }))
  };

  return (
    <div className="landing-page">
      <Helmet>
        <title>{SEO_DATA.title}</title>
        <meta name="description" content={SEO_DATA.description} />
        <meta name="keywords" content={SEO_DATA.keywords} />
        
        {/* Open Graph */}
        <meta property="og:title" content={SEO_DATA.title} />
        <meta property="og:description" content={SEO_DATA.description} />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://ccolorpalette.com" />
        <meta property="og:image" content="https://ccolorpalette.com/og-image.png" />
        <meta property="og:site_name" content="CColorPalette" />
        
        {/* Twitter Card */}
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content={SEO_DATA.title} />
        <meta name="twitter:description" content={SEO_DATA.description} />
        <meta name="twitter:image" content="https://ccolorpalette.com/og-image.png" />
        
        {/* Additional SEO */}
        <meta name="robots" content="index, follow" />
        <meta name="author" content="CColorPalette" />
        <link rel="canonical" href="https://ccolorpalette.com/home" />
        
        {/* Structured Data */}
        <script type="application/ld+json">
          {JSON.stringify(structuredData)}
        </script>
        <script type="application/ld+json">
          {JSON.stringify(faqStructuredData)}
        </script>
      </Helmet>

      {/* Header */}
      <header className="landing-header">
        <div className="header-container">
          <Link to="/" className="header-logo">
            <img src={logo} alt="CColorPalette - Free Color Palette Generator" className="header-logo-img" />
            <span className="header-logo-text">CColorPalette</span>
          </Link>

          <nav className="header-nav" aria-label="Main navigation">
            {NAV_LINKS.map((link) => (
              <a
                key={link.href}
                href={link.href}
                className="header-nav-link"
                onClick={(e) => {
                  e.preventDefault();
                  scrollToSection(link.href);
                }}
              >
                {link.label}
              </a>
            ))}
            <Link to="/explore" className="header-nav-link">
              Explore
            </Link>
          </nav>

          <div className="header-actions">
            <button 
              className="btn-primary btn-small" 
              onClick={() => {
                trackEvent('cta_click', { location: 'header' });
                navigate('/');
              }}
            >
              <Palette size={16} />
              <span>Open Generator</span>
            </button>

            <button
              className="mobile-menu-toggle"
              onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
              aria-label="Toggle menu"
              aria-expanded={mobileMenuOpen}
            >
              {mobileMenuOpen ? <X size={24} /> : <Menu size={24} />}
            </button>
          </div>
        </div>

        {mobileMenuOpen && (
          <nav className="mobile-nav" aria-label="Mobile navigation">
            {NAV_LINKS.map((link) => (
              <a
                key={link.href}
                href={link.href}
                className="mobile-nav-link"
                onClick={(e) => {
                  e.preventDefault();
                  scrollToSection(link.href);
                }}
              >
                {link.label}
              </a>
            ))}
            <Link to="/explore" className="mobile-nav-link" onClick={() => setMobileMenuOpen(false)}>
              Explore Palettes
            </Link>
            <button className="btn-primary btn-full" onClick={() => navigate('/')}>
              <Palette size={18} />
              <span>Open Generator</span>
            </button>
          </nav>
        )}
      </header>

      {/* Hero Section */}
      <section className="hero-section">
        <div className="hero-container">
          <div className="hero-badge">
            <Sparkles size={14} />
            <span>Free Color Palette Generator • No Signup Required</span>
          </div>

          <h1 className="hero-title">
            Create Beautiful
            <span className="hero-title-accent"> Color Palettes</span>
            <br />in Seconds
          </h1>

          <p className="hero-subtitle">
            The fastest way to generate harmonious color schemes for web design,
            branding, UI/UX, and creative projects. Press spacebar to generate.
            Export to CSS, Tailwind, JSON, and more. Completely free.
          </p>

          <div className="hero-buttons">
            <button 
              className="btn-primary btn-large" 
              onClick={() => {
                trackEvent('cta_click', { location: 'hero_main' });
                navigate('/');
              }}
            >
              <Palette size={20} />
              <span>Start Generating — It's Free</span>
            </button>
            <a 
              href="#features" 
              className="btn-secondary btn-large" 
              onClick={(e) => { 
                e.preventDefault(); 
                scrollToSection('#features'); 
              }}
            >
              <span>See Features</span>
              <ArrowDown size={18} />
            </a>
          </div>

          <div className="hero-hints">
            <div className="hero-hint">
              <Keyboard size={14} />
              <span><kbd>Space</kbd> Generate</span>
            </div>
            <div className="hero-hint">
              <Lock size={14} />
              <span><kbd>Click</kbd> Lock Color</span>
            </div>
            <div className="hero-hint">
              <History size={14} />
              <span><kbd>Ctrl+Z</kbd> Undo</span>
            </div>
          </div>
        </div>

        {/* Hero Screenshot */}
        <div className="hero-screenshot">
          <div className="screenshot-browser">
            <div className="browser-dots">
              <span></span>
              <span></span>
              <span></span>
            </div>
            <div className="browser-url">ccolorpalette.com/E63946-F1FAEE-A8DADC-457B9D-1D3557</div>
          </div>
          <div className="screenshot-image">
            <div className="screenshot-placeholder">
              <div className="placeholder-colors">
                <div style={{ backgroundColor: '#E63946' }} data-hex="#E63946"></div>
                <div style={{ backgroundColor: '#F1FAEE' }} data-hex="#F1FAEE"></div>
                <div style={{ backgroundColor: '#A8DADC' }} data-hex="#A8DADC"></div>
                <div style={{ backgroundColor: '#457B9D' }} data-hex="#457B9D"></div>
                <div style={{ backgroundColor: '#1D3557' }} data-hex="#1D3557"></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Stats Bar */}
      <section className="stats-section" aria-label="Statistics">
        <div className="stats-container">
          {STATS.map((stat, index) => (
            <div key={index} className="stat-item">
              <span className="stat-value">{stat.value}</span>
              <span className="stat-label">{stat.label}</span>
            </div>
          ))}
        </div>
      </section>

      {/* Trending Palettes Section */}
      <section className="trending-section" aria-labelledby="trending-title">
        <div className="section-container">
          <div className="section-header">
            <span className="section-badge">
              <TrendingUp size={14} />
              <span>Inspiration</span>
            </span>
            <h2 id="trending-title" className="section-title">Trending Color Palettes</h2>
            <p className="section-subtitle">
              Hand-picked color combinations to jumpstart your next project. Click any palette to open it in the generator.
            </p>
          </div>

          <div className="trending-grid">
            {TRENDING_PALETTES.map((paletteString, index) => {
              const colors = paletteString.split('-');
              
              return (
                <Link 
                  key={index} 
                  to={`/${paletteString}`}
                  className="palette-card"
                  aria-label={`Open palette with ${colors.length} colors starting with #${colors[0]}`}
                  onClick={() => trackEvent('trending_palette_click', { palette: paletteString })}
                >
                  <div className="palette-preview">
                    {colors.map((hex, i) => (
                      <div 
                        key={i} 
                        className="palette-stripe" 
                        style={{ backgroundColor: `#${hex}` }}
                        title={`#${hex}`}
                      />
                    ))}
                  </div>
                  <div className="palette-info">
                    <span className="palette-name">
                      {colors.length} colors • #{colors[0]}
                    </span>
                    <ArrowRight size={16} className="palette-arrow" />
                  </div>
                </Link>
              );
            })}
          </div>
          
          <div className="cta-center">
            <Link to="/explore" className="btn-secondary">
              <Grid3X3 size={18} />
              <span>Browse All Palettes</span>
            </Link>
          </div>
        </div>
      </section>

      {/* Features Section */}
      <section id="features" className="features-section" aria-labelledby="features-title">
        <div className="section-container">
          <div className="section-header">
            <span className="section-badge">
              <Sparkles size={14} />
              <span>Features</span>
            </span>
            <h2 id="features-title" className="section-title">Everything You Need to Create Perfect Color Palettes</h2>
            <p className="section-subtitle">
              Professional color tools designed for speed and simplicity. No learning curve, no clutter, just colors.
            </p>
          </div>

          <div className="features-grid">
            {FEATURES.map((feature, index) => (
              <article key={index} className="feature-card">
                <div className="feature-icon">
                  <feature.icon size={24} aria-hidden="true" />
                </div>
                <h3 className="feature-title">{feature.title}</h3>
                <p className="feature-description">{feature.description}</p>
              </article>
            ))}
          </div>
        </div>
      </section>

      {/* How It Works Section */}
      <section id="how-it-works" className="how-it-works-section" aria-labelledby="how-it-works-title">
        <div className="section-container">
          <div className="section-header">
            <span className="section-badge">
              <Play size={14} />
              <span>How It Works</span>
            </span>
            <h2 id="how-it-works-title" className="section-title">Generate Color Palettes in Three Simple Steps</h2>
            <p className="section-subtitle">
              From inspiration to export in under 30 seconds. It's really that easy.
            </p>
          </div>

          <div className="steps-grid">
            <article className="step-card">
              <div className="step-number">1</div>
              <div className="step-icon">
                <Shuffle size={32} aria-hidden="true" />
              </div>
              <h3 className="step-title">Generate</h3>
              <p className="step-description">
                Press spacebar or tap generate. A new harmonious palette appears instantly.
                Keep generating until you find colors that inspire you.
              </p>
            </article>

            <article className="step-card">
              <div className="step-number">2</div>
              <div className="step-icon">
                <Sliders size={32} aria-hidden="true" />
              </div>
              <h3 className="step-title">Customize</h3>
              <p className="step-description">
                Lock colors you love, adjust shades, choose harmony modes.
                Drag to reorder. Add or remove colors as needed.
              </p>
            </article>

            <article className="step-card">
              <div className="step-number">3</div>
              <div className="step-icon">
                <Download size={32} aria-hidden="true" />
              </div>
              <h3 className="step-title">Export</h3>
              <p className="step-description">
                Copy CSS, Tailwind, JSON, or download as PNG/SVG.
                Share via URL or bookmark. Ready for any project.
              </p>
            </article>
          </div>

          <div className="cta-center">
            <button 
              className="btn-primary btn-large" 
              onClick={() => {
                trackEvent('cta_click', { location: 'how_it_works' });
                navigate('/');
              }}
            >
              <Zap size={20} />
              <span>Try It Now — It's Free</span>
            </button>
          </div>
        </div>
      </section>

      {/* Export Formats Section */}
      <section id="export" className="export-section" aria-labelledby="export-title">
        <div className="section-container">
          <div className="section-header">
            <span className="section-badge">
              <Download size={14} />
              <span>Export Formats</span>
            </span>
            <h2 id="export-title" className="section-title">Export to Any Format You Need</h2>
            <p className="section-subtitle">
              From CSS variables to social media images, export your palette in the format that works for your workflow.
            </p>
          </div>

          <div className="export-grid">
            {EXPORT_FORMATS.map((format, index) => (
              <article key={index} className="export-card">
                <div className="export-header">
                  <div className="export-icon">
                    <format.icon size={20} aria-hidden="true" />
                  </div>
                  <h3 className="export-title">{format.title}</h3>
                </div>
                <p className="export-description">{format.description}</p>
                {format.example && (
                  <div className="export-example">
                    <pre><code>{format.example}</code></pre>
                    <button
                      className="copy-btn"
                      onClick={() => copyExample(format.example, index)}
                      aria-label={`Copy ${format.title} example`}
                    >
                      {copiedExample === index ? <Check size={14} /> : <Copy size={14} />}
                    </button>
                  </div>
                )}
              </article>
            ))}
          </div>
        </div>
      </section>

      {/* Accessibility Section */}
      <section id="accessibility" className="accessibility-section" aria-labelledby="a11y-title">
        <div className="section-container">
          <div className="a11y-content">
            <div className="a11y-text">
              <span className="section-badge">
                <Accessibility size={14} />
                <span>Accessibility</span>
              </span>
              <h2 id="a11y-title" className="section-title">Design for Everyone</h2>
              <p className="section-subtitle">
                Built-in accessibility tools help you create palettes that work for all users,
                including the estimated 300 million people worldwide with color vision deficiency.
              </p>

              <ul className="a11y-features" role="list">
                <li>
                  <CheckCircle size={20} aria-hidden="true" />
                  <span><strong>WCAG 2.1 Contrast Checking</strong> — Instant AA (4.5:1) and AAA (7:1) pass/fail ratings</span>
                </li>
                <li>
                  <CheckCircle size={20} aria-hidden="true" />
                  <span><strong>Color Blindness Simulation</strong> — Preview Protanopia, Deuteranopia, Tritanopia, Achromatopsia</span>
                </li>
                <li>
                  <CheckCircle size={20} aria-hidden="true" />
                  <span><strong>Adjacent Color Contrast</strong> — Ensure neighboring colors are sufficiently distinguishable</span>
                </li>
                <li>
                  <CheckCircle size={20} aria-hidden="true" />
                  <span><strong>Export with Simulation</strong> — Export your palette as it appears under each vision type</span>
                </li>
              </ul>

              <button 
                className="btn-primary" 
                onClick={() => {
                  trackEvent('cta_click', { location: 'accessibility' });
                  navigate('/');
                }}
              >
                <Eye size={20} />
                <span>Check Your Palette's Accessibility</span>
              </button>
            </div>

            <div className="a11y-visual">
              <div className="a11y-preview">
                <div className="a11y-panel-mock">
                  <div className="panel-mock-header">
                    <Eye size={16} aria-hidden="true" />
                    <span>Accessibility Panel</span>
                  </div>
                  <div className="contrast-mock">
                    <div className="contrast-item-mock">
                      <div className="swatch-mock" style={{ backgroundColor: '#E63946', color: '#fff' }}>Aa</div>
                      <div className="contrast-info-mock">
                        <span className="contrast-hex-mock">#E63946</span>
                        <span className="contrast-ratio-mock">4.5:1 vs white</span>
                      </div>
                      <div className="badge-mock pass">AA ✓</div>
                    </div>
                    <div className="contrast-item-mock">
                      <div className="swatch-mock" style={{ backgroundColor: '#457B9D', color: '#fff' }}>Aa</div>
                      <div className="contrast-info-mock">
                        <span className="contrast-hex-mock">#457B9D</span>
                        <span className="contrast-ratio-mock">5.2:1 vs white</span>
                      </div>
                      <div className="badge-mock pass">AA ✓</div>
                    </div>
                    <div className="contrast-item-mock">
                      <div className="swatch-mock" style={{ backgroundColor: '#1D3557', color: '#fff' }}>Aa</div>
                      <div className="contrast-info-mock">
                        <span className="contrast-hex-mock">#1D3557</span>
                        <span className="contrast-ratio-mock">12.8:1 vs white</span>
                      </div>
                      <div className="badge-mock pass">AAA ✓</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Color Theory Section */}
      <section id="theory" className="theory-section" aria-labelledby="theory-title">
        <div className="section-container">
          <div className="section-header">
            <span className="section-badge">
              <BookOpen size={14} />
              <span>Color Theory</span>
            </span>
            <h2 id="theory-title" className="section-title">Understanding Color Harmony</h2>
            <p className="section-subtitle">
              Learn the principles behind beautiful color combinations. CColorPalette applies these
              rules automatically, but understanding them helps you make better creative decisions.
            </p>
          </div>

          <div className="theory-grid">
            {COLOR_THEORY_SECTIONS.map((section) => (
              <article key={section.id} className="theory-card" id={`theory-${section.id}`}>
                <div className="theory-icon">
                  <section.icon size={24} aria-hidden="true" />
                </div>
                <h3 className="theory-title">{section.title}</h3>
                <span className="theory-subtitle">{section.subtitle}</span>
                <div className="theory-content">{section.content}</div>
              </article>
            ))}
          </div>
        </div>
      </section>

      {/* Use Cases Section */}
      <section id="use-cases" className="use-cases-section" aria-labelledby="use-cases-title">
        <div className="section-container">
          <div className="section-header">
            <span className="section-badge">
              <Target size={14} />
              <span>Use Cases</span>
            </span>
            <h2 id="use-cases-title" className="section-title">Color Palettes for Every Creative Project</h2>
            <p className="section-subtitle">
              Whether you're designing a website, building a brand, creating an app, or decorating a room,
              CColorPalette helps you find the perfect colors.
            </p>
          </div>

          <div className="use-cases-grid">
            {USE_CASES.map((useCase, index) => (
              <article key={index} className="use-case-card">
                <div className="use-case-icon">
                  <useCase.icon size={24} aria-hidden="true" />
                </div>
                <h3 className="use-case-title">{useCase.title}</h3>
                <p className="use-case-description">{useCase.description}</p>
              </article>
            ))}
          </div>
        </div>
      </section>

      {/* Testimonials Section */}
      <section className="testimonials-section" aria-labelledby="testimonials-title">
        <div className="section-container">
          <div className="section-header">
            <span className="section-badge">
              <MessageCircle size={14} />
              <span>Testimonials</span>
            </span>
            <h2 id="testimonials-title" className="section-title">Loved by Designers & Developers</h2>
            <p className="section-subtitle">
              See what creative professionals are saying about CColorPalette.
            </p>
          </div>

          <div className="testimonials-grid">
            {TESTIMONIALS.map((testimonial, index) => (
              <article key={index} className="testimonial-card">
                <Quote size={24} className="testimonial-quote-icon" aria-hidden="true" />
                <blockquote className="testimonial-text">
                  "{testimonial.quote}"
                </blockquote>
                <div className="testimonial-author">
                  <div className="testimonial-avatar">
                    {testimonial.author.charAt(0)}
                  </div>
                  <div className="testimonial-info">
                    <span className="testimonial-name">{testimonial.author}</span>
                    <span className="testimonial-role">{testimonial.role}</span>
                  </div>
                </div>
              </article>
            ))}
          </div>
        </div>
      </section>

      {/* Comparison Section */}
      <section id="comparison" className="comparison-section" aria-labelledby="comparison-title">
        <div className="section-container">
          <div className="section-header">
            <span className="section-badge">
              <BarChart3 size={14} />
              <span>Comparison</span>
            </span>
            <h2 id="comparison-title" className="section-title">How CColorPalette Compares to Alternatives</h2>
            <p className="section-subtitle">
              See how we stack up against other popular color tools like Coolors, Adobe Color, Paletton, and Color Hunt.
            </p>
          </div>

          <div className="comparison-table-wrapper">
            <table className="comparison-table" aria-label="Feature comparison between color palette generators">
              <thead>
                <tr>
                  <th scope="col">Feature</th>
                  <th scope="col">
                    <div className="table-brand ours">
                      <Palette size={16} aria-hidden="true" />
                      CColorPalette
                    </div>
                  </th>
                  <th scope="col">Coolors</th>
                  <th scope="col">Adobe Color</th>
                  <th scope="col">Paletton</th>
                  <th scope="col">Color Hunt</th>
                </tr>
              </thead>
              <tbody>
                {COMPARISONS.map((row, index) => (
                  <tr key={index}>
                    <td className="feature-cell">{row.feature}</td>
                    <td>
                      {row.ccolorpalette ? (
                        <CheckCircle size={18} className="check-yes" aria-label="Yes" />
                      ) : (
                        <XCircle size={18} className="check-no" aria-label="No" />
                      )}
                    </td>
                    <td>
                      {row.coolors ? (
                        <CheckCircle size={18} className="check-yes" aria-label="Yes" />
                      ) : (
                        <XCircle size={18} className="check-no" aria-label="No" />
                      )}
                    </td>
                    <td>
                      {row.adobe ? (
                        <CheckCircle size={18} className="check-yes" aria-label="Yes" />
                      ) : (
                        <XCircle size={18} className="check-no" aria-label="No" />
                      )}
                    </td>
                    <td>
                      {row.paletton ? (
                        <CheckCircle size={18} className="check-yes" aria-label="Yes" />
                      ) : (
                        <XCircle size={18} className="check-no" aria-label="No" />
                      )}
                    </td>
                    <td>
                      {row.colorhunt ? (
                        <CheckCircle size={18} className="check-yes" aria-label="Yes" />
                      ) : (
                        <XCircle size={18} className="check-no" aria-label="No" />
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </section>

      {/* FAQ Section */}
      <section id="faq" className="faq-section" aria-labelledby="faq-title">
        <div className="section-container">
          <div className="section-header">
            <span className="section-badge">
              <Lightbulb size={14} />
              <span>FAQ</span>
            </span>
            <h2 id="faq-title" className="section-title">Frequently Asked Questions</h2>
            <p className="section-subtitle">
              Everything you need to know about using CColorPalette.
            </p>
          </div>

          <div className="faq-list" role="list">
            {FAQ_DATA.map((faq, index) => (
              <article
                key={index}
                className={`faq-item ${openFaq === index ? 'open' : ''}`}
              >
                <button
                  className="faq-question"
                  onClick={() => toggleFaq(index)}
                  aria-expanded={openFaq === index}
                  aria-controls={`faq-answer-${index}`}
                >
                  <span>{faq.question}</span>
                  <ChevronDown size={20} className="faq-chevron" aria-hidden="true" />
                </button>
                <div 
                  id={`faq-answer-${index}`}
                  className="faq-answer"
                  aria-hidden={openFaq !== index}
                >
                  <p>{faq.answer}</p>
                </div>
              </article>
            ))}
          </div>
        </div>
      </section>

      {/* SEO Content Section */}
      <section className="seo-content-section" aria-labelledby="seo-title">
        <div className="section-container">
          <div className="seo-header">
            <h2 id="seo-title" className="seo-main-title">
              About CColorPalette: The Free Online Color Palette Generator
            </h2>
            <p className="seo-intro">
              CColorPalette is a free, browser-based color palette generator designed for designers, developers,
              artists, and anyone who works with color. Unlike traditional color pickers that require manual
              selection, CColorPalette generates complete, harmonious color schemes with a single keypress using
              advanced color theory algorithms and perceptually uniform OKLCH color space.
            </p>
          </div>

          <div className="seo-grid">
            {SEO_SECTIONS.map((section, index) => (
              <article key={index} className="seo-card">
                <div className="seo-card-icon">
                  <section.icon size={20} aria-hidden="true" />
                </div>
                <h3 className="seo-card-title">{section.title}</h3>
                <p className="seo-card-content">{section.content}</p>
              </article>
            ))}
          </div>

          <div className="seo-keywords-section">
            <h3>Related Topics & Searches</h3>
            <div className="seo-keywords-list">
              {[
                'color palette generator',
                'color scheme creator',
                'hex color picker',
                'CSS color variables',
                'Tailwind CSS colors',
                'WCAG contrast checker',
                'color blindness simulator',
                'accessible color palette',
                'color harmony',
                'complementary colors',
                'analogous colors',
                'triadic color scheme',
                'split complementary',
                'monochromatic palette',
                'web design colors',
                'brand color palette',
                'UI color scheme',
                'OKLCH color space',
                'design tokens',
                'color theory',
                'free color tool',
                'Coolors alternative',
                'Adobe Color alternative',
              ].map((keyword, index) => (
                <span key={index} className="seo-keyword-tag">{keyword}</span>
              ))}
            </div>
          </div>
        </div>
      </section>

      {/* Final CTA Section */}
      <section className="final-cta-section" aria-labelledby="final-cta-title">
        <div className="section-container">
          <div className="cta-content">
            <h2 id="final-cta-title" className="cta-title">Ready to Create Beautiful Colors?</h2>
            <p className="cta-subtitle">
              Start generating perfect color palettes in seconds. No signup. No limits. Completely free.
            </p>
            <button 
              className="btn-primary btn-large btn-cta" 
              onClick={() => {
                trackEvent('cta_click', { location: 'final_cta' });
                navigate('/');
              }}
            >
              <Palette size={24} />
              <span>Open Color Generator</span>
              <ArrowRight size={20} />
            </button>
            <span className="cta-hint">Press spacebar to generate your first palette</span>
          </div>
        </div>
      </section>

      {/* Footer */}
      <footer className="landing-footer" role="contentinfo">
        <div className="footer-container">
          <div className="footer-main">
            <div className="footer-brand">
              <div className="footer-logo">
                <img src={logo} alt="CColorPalette" className="footer-logo-img" />
                <span className="footer-logo-text">CColorPalette</span>
              </div>
              <p className="footer-tagline">
                The free color palette generator for designers, developers, and creative professionals.
                Create beautiful, accessible color schemes instantly.
              </p>
            </div>

            <div className="footer-links">
              <div className="footer-column">
                <h4>Product</h4>
                <Link to="/">Generator</Link>
                <Link to="/explore">Explore Palettes</Link>
                <a href="#features" onClick={(e) => { e.preventDefault(); scrollToSection('#features'); }}>Features</a>
                <a href="#faq" onClick={(e) => { e.preventDefault(); scrollToSection('#faq'); }}>FAQ</a>
              </div>
              <div className="footer-column">
                <h4>Resources</h4>
                <a href="#theory" onClick={(e) => { e.preventDefault(); scrollToSection('#theory'); }}>Color Theory</a>
                <a href="#use-cases" onClick={(e) => { e.preventDefault(); scrollToSection('#use-cases'); }}>Use Cases</a>
                <a href="#export" onClick={(e) => { e.preventDefault(); scrollToSection('#export'); }}>Export Formats</a>
                <a href="#accessibility" onClick={(e) => { e.preventDefault(); scrollToSection('#accessibility'); }}>Accessibility</a>
              </div>
              <div className="footer-column">
                <h4>Legal</h4>
                <Link to="/privacy">Privacy Policy</Link>
                <Link to="/terms">Terms of Service</Link>
              </div>
            </div>
          </div>

          <div className="footer-bottom">
            <p>© {new Date().getFullYear()} CColorPalette. All rights reserved. Free color palette generator for everyone.</p>
          </div>
        </div>
      </footer>
    </div>
  );
}

export default LandingPage;
/* =========================================
   FILE: src/pages/Legal/PrivacyPolicy.jsx
   ========================================= */

import React from 'react';
import { Helmet } from 'react-helmet-async';
import { Link } from 'react-router-dom';
import logo from '../../assets/Frame4ico.png';
import {
  Shield,
  Eye,
  Database,
  Cookie,
  Share2,
  Lock,
  Mail,
  Calendar,
  ExternalLink,
  ArrowLeft,
  Palette,
} from 'lucide-react';
import './Legal.css';

const LAST_UPDATED = 'January 5, 2026';

const SECTIONS = [
  {
    id: 'introduction',
    icon: Shield,
    title: 'Introduction',
    content: `Welcome to CColorPalette ("we," "our," or "us"). We are committed to protecting your privacy and being transparent about how we handle information when you use our color palette generator tool.

This Privacy Policy explains what information we collect, how we use it, and your rights regarding your data. By using CColorPalette, you agree to the terms outlined in this policy.

CColorPalette is designed with privacy in mind. We don't require user accounts, don't collect personal information, and don't track individual users across sessions.`,
  },
  {
    id: 'information-we-collect',
    icon: Database,
    title: 'Information We Collect',
    content: `**Information You Provide**

CColorPalette does not require you to create an account or provide any personal information to use our service. We do not collect:
- Names or email addresses
- Payment information
- User accounts or passwords
- Personal identifiers

**Automatically Collected Information**

When you visit CColorPalette, we may automatically collect certain technical information:
- Browser type and version
- Operating system
- Device type (desktop, mobile, tablet)
- Referring website (if applicable)
- Pages visited and features used
- Approximate geographic location (country/region level only)

This information is collected in aggregate form and cannot be used to identify individual users.

**URL Data**

Your color palettes are encoded in the URL (e.g., /E63946-F1FAEE-A8DADC). This allows you to bookmark and share palettes. We do not store or track which palettes individual users create or view.`,
  },
  {
    id: 'how-we-use-information',
    icon: Eye,
    title: 'How We Use Information',
    content: `We use the limited information we collect for the following purposes:

**Service Improvement**
- Understanding which features are most popular
- Identifying and fixing bugs or performance issues
- Optimizing the user experience across different devices and browsers

**Analytics**
- Measuring overall website traffic and usage patterns
- Understanding how users interact with our tool
- Making data-driven decisions about new features

**Security**
- Protecting against malicious activity
- Maintaining the integrity of our service

We do NOT use your information to:
- Build individual user profiles
- Target advertising
- Sell or share data with third parties for marketing
- Track you across other websites`,
  },
  {
    id: 'cookies',
    icon: Cookie,
    title: 'Cookies and Local Storage',
    content: `**Cookies**

CColorPalette uses minimal cookies. We may use:
- Essential cookies required for the website to function
- Analytics cookies to understand aggregate usage (if applicable)

We do not use:
- Advertising or tracking cookies
- Third-party marketing cookies
- Cross-site tracking cookies

**Local Storage**

CColorPalette may use your browser's local storage to:
- Remember your session preferences (like panel states)
- Store your palette history temporarily for the undo/redo feature

This data is stored only in your browser and is not transmitted to our servers. You can clear this data at any time through your browser settings.

**Managing Cookies**

You can control cookies through your browser settings. Note that disabling cookies may affect some functionality of the website.`,
  },
  {
    id: 'data-sharing',
    icon: Share2,
    title: 'Data Sharing and Third Parties',
    content: `**We Do Not Sell Your Data**

CColorPalette does not sell, rent, or trade any user information to third parties.

**Service Providers**

We may use third-party services to help operate our website:
- Hosting providers (to serve the website)
- Analytics services (to understand aggregate usage)
- Content delivery networks (to improve performance)

These providers only have access to aggregate, non-personally identifiable information and are contractually obligated to protect any data they process.

**Legal Requirements**

We may disclose information if required by law or if we believe disclosure is necessary to:
- Comply with legal obligations
- Protect our rights or property
- Prevent fraud or security issues
- Protect the safety of users or the public`,
  },
  {
    id: 'data-security',
    icon: Lock,
    title: 'Data Security',
    content: `We take reasonable measures to protect the limited information we collect:

- Our website uses HTTPS encryption for all connections
- We regularly update our software and dependencies
- We follow security best practices in our development process
- We limit access to any collected data to authorized personnel only

Since CColorPalette doesn't collect personal information or require user accounts, the risk of data breaches affecting individual users is minimal.

**Your Responsibility**

When you share a palette URL, anyone with that URL can view the palette. Be mindful of this when sharing links that may contain color schemes for confidential projects.`,
  },
  {
    id: 'your-rights',
    icon: Shield,
    title: 'Your Rights',
    content: `Depending on your location, you may have certain rights regarding your data:

**General Rights**
- Access: Request information about data we collect
- Deletion: Request deletion of any data we may have
- Opt-out: Decline non-essential cookies and analytics

**For EU/EEA Residents (GDPR)**
- Right to access, rectify, or erase personal data
- Right to restrict or object to processing
- Right to data portability
- Right to withdraw consent

**For California Residents (CCPA)**
- Right to know what personal information is collected
- Right to delete personal information
- Right to opt-out of sale of personal information
- Right to non-discrimination for exercising rights

Since CColorPalette doesn't collect personal information, most of these rights are automatically satisfied. If you have any concerns, please contact us.`,
  },
  {
    id: 'childrens-privacy',
    icon: Shield,
    title: "Children's Privacy",
    content: `CColorPalette is a general-audience tool and is not directed at children under 13 years of age. We do not knowingly collect personal information from children.

Since we don't collect personal information from any users, there is no special risk to children using our service. However, parents and guardians should supervise their children's internet use as a general practice.

If you believe we have inadvertently collected information from a child, please contact us immediately.`,
  },
  {
    id: 'changes',
    icon: Calendar,
    title: 'Changes to This Policy',
    content: `We may update this Privacy Policy from time to time to reflect changes in our practices or for legal, operational, or regulatory reasons.

When we make changes:
- We will update the "Last Updated" date at the top of this policy
- For significant changes, we may provide additional notice on our website
- Continued use of CColorPalette after changes constitutes acceptance of the updated policy

We encourage you to review this Privacy Policy periodically to stay informed about how we protect your information.`,
  },
  {
    id: 'contact',
    icon: Mail,
    title: 'Contact Us',
    content: `If you have questions, concerns, or requests regarding this Privacy Policy or our privacy practices, please contact us:

**Email:** privacy@ccolorpalette.com

**Response Time:** We aim to respond to all privacy-related inquiries within 30 days.

For general questions about using CColorPalette, please visit our FAQ section on the homepage.`,
  },
];

function PrivacyPolicy() {
  return (
    <div className="legal-page">
      <Helmet>
        <title>Privacy Policy | CColorPalette</title>
        <meta
          name="description"
          content="Privacy Policy for CColorPalette - Learn how we protect your privacy and handle data on our free color palette generator."
        />
        <link rel="canonical" href="https://ccolorpalette.com/privacy" />
      </Helmet>

      {/* Header */}
      <header className="legal-header">
        <div className="legal-header-container">
            <Link to="/home" className="header-logo">
                <img src={logo} alt="CColorPalette" className="header-logo-img" />
                <span className="header-logo-text">CColorPalette</span>
            </Link>

          <Link to="/home" className="legal-back-link">
            <ArrowLeft size={18} />
            <span>Back to Home</span>
          </Link>
        </div>
      </header>

      {/* Hero */}
      <section className="legal-hero">
        <div className="legal-hero-container">
          <div className="legal-hero-icon">
            <Shield size={32} />
          </div>
          <h1 className="legal-hero-title">Privacy Policy</h1>
          <p className="legal-hero-subtitle">
            Your privacy matters to us. Learn how CColorPalette handles your data.
          </p>
          <div className="legal-hero-meta">
            <Calendar size={14} />
            <span>Last updated: {LAST_UPDATED}</span>
          </div>
        </div>
      </section>

      {/* Table of Contents */}
      <nav className="legal-toc">
        <div className="legal-toc-container">
          <h2 className="legal-toc-title">Contents</h2>
          <ul className="legal-toc-list">
            {SECTIONS.map((section) => (
              <li key={section.id}>
                <a href={`#${section.id}`} className="legal-toc-link">
                  <section.icon size={14} />
                  <span>{section.title}</span>
                </a>
              </li>
            ))}
          </ul>
        </div>
      </nav>

      {/* Content */}
      <main className="legal-content">
        <div className="legal-content-container">
          {SECTIONS.map((section) => (
            <section key={section.id} id={section.id} className="legal-section">
              <div className="legal-section-header">
                <div className="legal-section-icon">
                  <section.icon size={20} />
                </div>
                <h2 className="legal-section-title">{section.title}</h2>
              </div>
              <div className="legal-section-content">
                {section.content.split('\n\n').map((paragraph, index) => {
                  if (paragraph.startsWith('**') && paragraph.endsWith('**')) {
                    return (
                      <h3 key={index} className="legal-subsection-title">
                        {paragraph.replace(/\*\*/g, '')}
                      </h3>
                    );
                  }
                  if (paragraph.startsWith('**')) {
                    const [title, ...rest] = paragraph.split('**').filter(Boolean);
                    return (
                      <div key={index}>
                        <h3 className="legal-subsection-title">{title}</h3>
                        <p>{rest.join('')}</p>
                      </div>
                    );
                  }
                  if (paragraph.startsWith('- ')) {
                    const items = paragraph.split('\n').filter((line) => line.startsWith('- '));
                    return (
                      <ul key={index} className="legal-list">
                        {items.map((item, i) => (
                          <li key={i}>{item.replace('- ', '')}</li>
                        ))}
                      </ul>
                    );
                  }
                  return <p key={index}>{paragraph}</p>;
                })}
              </div>
            </section>
          ))}
        </div>
      </main>

      {/* Footer */}
      <footer className="legal-footer">
        <div className="legal-footer-container">
          <div className="legal-footer-links">
            <Link to="/home">Home</Link>
            <Link to="/">Generator</Link>
            <Link to="/terms">Terms of Service</Link>
          </div>
          <p className="legal-footer-copyright">
            &copy; {new Date().getFullYear()} CColorPalette. All rights reserved.
          </p>
        </div>
      </footer>
    </div>
  );
}

export default PrivacyPolicy;
/* =========================================
   FILE: src/pages/Legal/TermsOfService.jsx
   ========================================= */

import React from 'react';
import { Helmet } from 'react-helmet-async';
import { Link } from 'react-router-dom';
import logo from '../../assets/Frame4ico.png';
import {
  FileText,
  CheckCircle,
  XCircle,
  Scale,
  AlertTriangle,
  Globe,
  RefreshCw,
  Mail,
  Calendar,
  ArrowLeft,
  Palette,
  Shield,
  Users,
  Copyright,
  Gavel,
} from 'lucide-react';
import './Legal.css';

const LAST_UPDATED = 'January 5, 2026';

const SECTIONS = [
  {
    id: 'acceptance',
    icon: CheckCircle,
    title: 'Acceptance of Terms',
    content: `By accessing or using CColorPalette ("the Service"), you agree to be bound by these Terms of Service ("Terms"). If you do not agree to these Terms, please do not use the Service.

These Terms constitute a legally binding agreement between you and CColorPalette. We may update these Terms from time to time, and your continued use of the Service after any changes constitutes acceptance of the new Terms.

The Service is intended for users who are at least 13 years of age. By using the Service, you represent that you meet this age requirement.`,
  },
  {
    id: 'description',
    icon: Palette,
    title: 'Description of Service',
    content: `CColorPalette is a free online color palette generator that allows users to:

- Generate random color palettes using various harmony modes
- Customize and adjust colors within palettes
- Lock specific colors while regenerating others
- Check color accessibility and contrast ratios
- Simulate color blindness to test palette accessibility
- Export palettes in various formats (CSS, Tailwind, JSON, PNG, SVG, etc.)
- Share palettes via unique URLs
- Access palette history during a session

The Service is provided "as is" and "as available" without warranties of any kind. We reserve the right to modify, suspend, or discontinue any aspect of the Service at any time without notice.`,
  },
  {
    id: 'permitted-use',
    icon: CheckCircle,
    title: 'Permitted Use',
    content: `You are granted a limited, non-exclusive, non-transferable license to use CColorPalette for lawful purposes. You MAY:

**Personal Use**
- Generate unlimited color palettes for personal projects
- Save and bookmark palette URLs for future reference
- Share palette URLs with others

**Commercial Use**
- Use generated palettes in commercial projects
- Incorporate colors into products, websites, apps, or designs
- Use exported code (CSS, Tailwind, etc.) in commercial software
- Create designs for clients using palettes from CColorPalette

**Educational Use**
- Use the Service for learning about color theory
- Include screenshots in educational materials with attribution
- Demonstrate the tool in workshops or presentations

All palettes generated are free to use without attribution, though we appreciate credit when possible.`,
  },
  {
    id: 'prohibited-use',
    icon: XCircle,
    title: 'Prohibited Use',
    content: `You agree NOT to use CColorPalette to:

**Technical Abuse**
- Attempt to gain unauthorized access to our systems or servers
- Use automated scripts, bots, or scrapers to access the Service excessively
- Interfere with or disrupt the Service or servers
- Attempt to reverse engineer, decompile, or disassemble the Service
- Circumvent any security measures or access restrictions

**Harmful Activities**
- Transmit malware, viruses, or other harmful code
- Engage in any activity that could damage, disable, or impair the Service
- Use the Service in any way that violates applicable laws or regulations

**Misrepresentation**
- Claim ownership of or take credit for the CColorPalette tool itself
- Misrepresent your affiliation with CColorPalette
- Create derivative services that could be confused with CColorPalette

**Commercial Restrictions**
- Resell access to the Service
- Create a competing service by directly copying our interface or code
- Use our branding, logos, or trademarks without permission

Violation of these terms may result in termination of access to the Service.`,
  },
  {
    id: 'intellectual-property',
    icon: Copyright,
    title: 'Intellectual Property',
    content: `**Our Intellectual Property**

The CColorPalette name, logo, website design, and underlying code are owned by us and protected by intellectual property laws. You may not use our branding without written permission.

**Your Generated Content**

Color palettes you generate using CColorPalette are not owned by us. You retain full rights to use any color combinations you create for any purpose.

However, please note:
- Colors themselves cannot be copyrighted
- The same or similar palettes may be generated by other users
- We make no claims of uniqueness or exclusivity for any generated palette

**Open Standards**

Color values (hex codes, RGB, HSL, etc.) are mathematical representations and are not proprietary. Export formats like CSS and JSON are open standards.

**Third-Party Content**

Any third-party libraries, fonts, or icons used in the Service are subject to their respective licenses. Our use of such content does not transfer any rights to you beyond what is permitted by those licenses.`,
  },
  {
    id: 'disclaimer',
    icon: AlertTriangle,
    title: 'Disclaimer of Warranties',
    content: `THE SERVICE IS PROVIDED "AS IS" AND "AS AVAILABLE" WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**We Do Not Warrant That:**
- The Service will be uninterrupted, error-free, or secure
- Any defects will be corrected
- The Service will meet your specific requirements
- Results obtained from the Service will be accurate or reliable
- Generated palettes will be suitable for any particular purpose

**Color Accuracy**

Colors may appear differently on different devices, monitors, and in different lighting conditions. We cannot guarantee color accuracy across all displays. For critical color work, always verify colors using calibrated equipment.

**Accessibility Claims**

While we provide WCAG contrast checking tools, we do not guarantee that palettes will meet all accessibility requirements for your specific use case. You are responsible for ensuring your designs meet applicable accessibility standards.

**Professional Advice**

CColorPalette is a tool, not professional design advice. For important projects, consider consulting with professional designers or color specialists.`,
  },
  {
    id: 'limitation-liability',
    icon: Scale,
    title: 'Limitation of Liability',
    content: `TO THE MAXIMUM EXTENT PERMITTED BY LAW, CCOLORPALETTE AND ITS OWNERS, OPERATORS, EMPLOYEES, AND AGENTS SHALL NOT BE LIABLE FOR:

**Direct Damages**
- Any direct damages arising from your use of or inability to use the Service

**Indirect Damages**
- Lost profits, revenue, or business opportunities
- Loss of data or data corruption
- Consequential, incidental, special, or punitive damages
- Any damages arising from third-party claims

**Specific Exclusions**
- Damages resulting from reliance on any information obtained through the Service
- Damages resulting from unauthorized access to your data
- Damages arising from any interruption or cessation of the Service

This limitation applies regardless of the legal theory (contract, tort, strict liability, or otherwise) and even if we have been advised of the possibility of such damages.

Some jurisdictions do not allow certain limitations of liability, so some of these limitations may not apply to you.`,
  },
  {
    id: 'indemnification',
    icon: Shield,
    title: 'Indemnification',
    content: `You agree to indemnify, defend, and hold harmless CColorPalette, its owners, operators, employees, agents, and affiliates from and against any claims, damages, losses, liabilities, costs, and expenses (including reasonable attorneys' fees) arising from:

- Your use of the Service
- Your violation of these Terms
- Your violation of any rights of another party
- Your violation of any applicable laws or regulations
- Any content you create using the Service that infringes on third-party rights

This indemnification obligation will survive termination of these Terms and your use of the Service.`,
  },
  {
    id: 'modifications',
    icon: RefreshCw,
    title: 'Modifications to Service and Terms',
    content: `**Service Modifications**

We reserve the right to modify, suspend, or discontinue any part of the Service at any time, with or without notice. This includes:
- Adding or removing features
- Changing the user interface
- Updating export formats
- Modifying accessibility tools

We will not be liable to you or any third party for any modification, suspension, or discontinuation of the Service.

**Terms Modifications**

We may revise these Terms at any time by updating this page. Changes become effective immediately upon posting. Your continued use of the Service after changes are posted constitutes acceptance of the modified Terms.

For significant changes, we may provide additional notice on our website. We encourage you to review these Terms periodically.

The "Last Updated" date at the top of this page indicates when these Terms were last revised.`,
  },
  {
    id: 'governing-law',
    icon: Gavel,
    title: 'Governing Law and Disputes',
    content: `**Governing Law**

These Terms shall be governed by and construed in accordance with the laws of the jurisdiction in which CColorPalette operates, without regard to conflict of law principles.

**Dispute Resolution**

Any disputes arising from these Terms or your use of the Service shall be resolved through:

1. **Informal Resolution:** We encourage you to contact us first to resolve any issues informally.

2. **Binding Arbitration:** If informal resolution fails, disputes shall be resolved through binding arbitration rather than in court, except where prohibited by law.

3. **Class Action Waiver:** You agree to resolve disputes on an individual basis and waive any right to participate in class action lawsuits or class-wide arbitration.

**Exceptions**

Nothing in this section prevents either party from seeking injunctive relief in court for intellectual property infringement or other urgent matters.

**Severability**

If any provision of these Terms is found to be unenforceable, the remaining provisions will continue in full force and effect.`,
  },
  {
    id: 'general',
    icon: Globe,
    title: 'General Provisions',
    content: `**Entire Agreement**

These Terms, together with our Privacy Policy, constitute the entire agreement between you and CColorPalette regarding the Service and supersede any prior agreements.

**Waiver**

Our failure to enforce any right or provision of these Terms shall not constitute a waiver of such right or provision.

**Assignment**

You may not assign or transfer these Terms or your rights hereunder without our prior written consent. We may assign these Terms without restriction.

**No Third-Party Beneficiaries**

These Terms do not create any third-party beneficiary rights.

**Headings**

Section headings are for convenience only and do not affect the interpretation of these Terms.

**Survival**

Provisions that by their nature should survive termination shall survive, including intellectual property, disclaimer, limitation of liability, and indemnification sections.`,
  },
  {
    id: 'contact',
    icon: Mail,
    title: 'Contact Information',
    content: `If you have questions about these Terms of Service, please contact us:

**Email:** legal@ccolorpalette.com

**Response Time:** We aim to respond to all inquiries within 14 business days.

For privacy-related questions, please see our Privacy Policy or contact privacy@ccolorpalette.com.

For general questions about using CColorPalette, please visit our FAQ section on the homepage.`,
  },
];

function TermsOfService() {
  return (
    <div className="legal-page">
      <Helmet>
        <title>Terms of Service | CColorPalette</title>
        <meta
          name="description"
          content="Terms of Service for CColorPalette - Understand the terms and conditions for using our free color palette generator."
        />
        <link rel="canonical" href="https://ccolorpalette.com/terms" />
      </Helmet>

      {/* Header */}
      <header className="legal-header">
        <div className="legal-header-container">
            <Link to="/home" className="header-logo">
                <img src={logo} alt="CColorPalette" className="header-logo-img" />
                <span className="header-logo-text">CColorPalette</span>
            </Link>

          <Link to="/home" className="legal-back-link">
            <ArrowLeft size={18} />
            <span>Back to Home</span>
          </Link>
        </div>
      </header>

      {/* Hero */}
      <section className="legal-hero">
        <div className="legal-hero-container">
          <div className="legal-hero-icon">
            <FileText size={32} />
          </div>
          <h1 className="legal-hero-title">Terms of Service</h1>
          <p className="legal-hero-subtitle">
            Please read these terms carefully before using CColorPalette.
          </p>
          <div className="legal-hero-meta">
            <Calendar size={14} />
            <span>Last updated: {LAST_UPDATED}</span>
          </div>
        </div>
      </section>

      {/* Table of Contents */}
      <nav className="legal-toc">
        <div className="legal-toc-container">
          <h2 className="legal-toc-title">Contents</h2>
          <ul className="legal-toc-list">
            {SECTIONS.map((section) => (
              <li key={section.id}>
                <a href={`#${section.id}`} className="legal-toc-link">
                  <section.icon size={14} />
                  <span>{section.title}</span>
                </a>
              </li>
            ))}
          </ul>
        </div>
      </nav>

      {/* Content */}
      <main className="legal-content">
        <div className="legal-content-container">
          {SECTIONS.map((section) => (
            <section key={section.id} id={section.id} className="legal-section">
              <div className="legal-section-header">
                <div className="legal-section-icon">
                  <section.icon size={20} />
                </div>
                <h2 className="legal-section-title">{section.title}</h2>
              </div>
              <div className="legal-section-content">
                {section.content.split('\n\n').map((paragraph, index) => {
                  if (paragraph.startsWith('**') && paragraph.endsWith('**')) {
                    return (
                      <h3 key={index} className="legal-subsection-title">
                        {paragraph.replace(/\*\*/g, '')}
                      </h3>
                    );
                  }
                  if (paragraph.startsWith('**')) {
                    const parts = paragraph.split('**').filter(Boolean);
                    return (
                      <div key={index}>
                        <h3 className="legal-subsection-title">{parts[0]}</h3>
                        {parts[1] && <p>{parts[1]}</p>}
                      </div>
                    );
                  }
                  if (paragraph.startsWith('- ')) {
                    const items = paragraph.split('\n').filter((line) => line.startsWith('- '));
                    return (
                      <ul key={index} className="legal-list">
                        {items.map((item, i) => (
                          <li key={i}>{item.replace('- ', '')}</li>
                        ))}
                      </ul>
                    );
                  }
                  if (paragraph.match(/^\d+\./)) {
                    const items = paragraph.split('\n').filter((line) => line.match(/^\d+\./));
                    return (
                      <ol key={index} className="legal-list legal-list-ordered">
                        {items.map((item, i) => (
                          <li key={i}>{item.replace(/^\d+\.\s*/, '')}</li>
                        ))}
                      </ol>
                    );
                  }
                  if (paragraph === paragraph.toUpperCase() && paragraph.length > 50) {
                    return (
                      <p key={index} className="legal-emphasis">
                        {paragraph}
                      </p>
                    );
                  }
                  return <p key={index}>{paragraph}</p>;
                })}
              </div>
            </section>
          ))}
        </div>
      </main>

      {/* Footer */}
      <footer className="legal-footer">
        <div className="legal-footer-container">
          <div className="legal-footer-links">
            <Link to="/home">Home</Link>
            <Link to="/">Generator</Link>
            <Link to="/privacy">Privacy Policy</Link>
          </div>
          <p className="legal-footer-copyright">
            &copy; {new Date().getFullYear()} CColorPalette. All rights reserved.
          </p>
        </div>
      </footer>
    </div>
  );
}

export default TermsOfService;
/* =========================================
   FILE: src/utils/analytics.js
   ========================================= */

export const trackEvent = (eventName, params = {}) => {
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', eventName, params);
    }
  };
/* =========================================
   FILE: src/utils/colorUtils.js
   ========================================= */

// src/utils/colorUtils.js

// ============================================
// 1. COLOR SPACE CONVERSION UTILITIES
// ============================================

// HSL <-> HEX (kept for display compatibility)
export const hslToHex = (h, s, l) => {
  l /= 100;
  const a = (s * Math.min(l, 1 - l)) / 100;
  const f = (n) => {
    const k = (n + h / 30) % 12;
    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * color)
      .toString(16)
      .padStart(2, '0');
  };
  return `#${f(0)}${f(8)}${f(4)}`.toUpperCase();
};

export const hexToHsl = (hex) => {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s;
  const l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
      case g: h = ((b - r) / d + 2) / 6; break;
      case b: h = ((r - g) / d + 4) / 6; break;
      default: h = 0;
    }
    h *= 360;
  }

  return { h, s: s * 100, l: l * 100 };
};

// ============================================
// OKLCH COLOR SPACE CONVERSION
// ============================================

const srgbToLinear = (c) => {
  return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
};

const linearToSrgb = (c) => {
  return c <= 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
};

const linearRgbToOklab = (r, g, b) => {
  const l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
  const m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
  const s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

  const l_ = Math.cbrt(l);
  const m_ = Math.cbrt(m);
  const s_ = Math.cbrt(s);

  return {
    L: 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,
    a: 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,
    b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_
  };
};

const oklabToLinearRgb = (L, a, b) => {
  const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
  const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
  const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

  const l = l_ * l_ * l_;
  const m = m_ * m_ * m_;
  const s = s_ * s_ * s_;

  return {
    r: +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,
    g: -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,
    b: -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s
  };
};

const oklabToOklch = (L, a, b) => {
  const C = Math.sqrt(a * a + b * b);
  let h = Math.atan2(b, a) * 180 / Math.PI;
  if (h < 0) h += 360;
  return { L, C, h };
};

const oklchToOklab = (L, C, h) => {
  const hRad = h * Math.PI / 180;
  return {
    L,
    a: C * Math.cos(hRad),
    b: C * Math.sin(hRad)
  };
};

export const hexToOklch = (hex) => {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;

  const lr = srgbToLinear(r);
  const lg = srgbToLinear(g);
  const lb = srgbToLinear(b);

  const lab = linearRgbToOklab(lr, lg, lb);
  return oklabToOklch(lab.L, lab.a, lab.b);
};

const isInGamut = (r, g, b) => {
  const epsilon = 0.0001;
  return r >= -epsilon && r <= 1 + epsilon &&
         g >= -epsilon && g <= 1 + epsilon &&
         b >= -epsilon && b <= 1 + epsilon;
};

const gamutMapOklch = (L, C, h) => {
  if (C === 0) return { L, C, h };
  
  const lab = oklchToOklab(L, C, h);
  const rgb = oklabToLinearRgb(lab.L, lab.a, lab.b);

  if (isInGamut(rgb.r, rgb.g, rgb.b)) {
    return { L, C, h };
  }

  let lo = 0;
  let hi = C;

  for (let i = 0; i < 20; i++) {
    const mid = (lo + hi) / 2;
    const testLab = oklchToOklab(L, mid, h);
    const testRgb = oklabToLinearRgb(testLab.L, testLab.a, testLab.b);

    if (isInGamut(testRgb.r, testRgb.g, testRgb.b)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  return { L, C: lo, h };
};

export const oklchToHex = (L, C, h) => {
  const mapped = gamutMapOklch(L, C, h);

  const lab = oklchToOklab(mapped.L, mapped.C, mapped.h);
  const rgb = oklabToLinearRgb(lab.L, lab.a, lab.b);

  const r = Math.round(Math.max(0, Math.min(255, linearToSrgb(rgb.r) * 255)));
  const g = Math.round(Math.max(0, Math.min(255, linearToSrgb(rgb.g) * 255)));
  const b = Math.round(Math.max(0, Math.min(255, linearToSrgb(rgb.b) * 255)));

  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`.toUpperCase();
};

const random = (min, max, rng) => rng() * (max - min) + min;

// ============================================
// 2. OKLCH VIBRANCY & HARMONY LOGIC
// ============================================

const adjustForVibrancyOklch = (L, C, h) => {
  let newL = L;
  let newC = C;
  let newH = h;

  // OKLCH is perceptually uniform, so fewer hue-specific fixes needed
  // Slight boost for yellow-green region which can handle more chroma
  if (h > 110 && h < 160) {
    newC = Math.min(newC * 1.1, 0.32);
  }

  // Blues at high lightness can look washed out
  if (h > 250 && h < 290 && newL > 0.75) {
    newC = Math.max(newC, 0.08);
  }

  // Ensure minimum chroma for chromatic colors
  if (C > 0.01) {
    newC = Math.max(newC, 0.025);
  }

  // Cap extremes
  newC = Math.max(0, Math.min(0.37, newC));
  newL = Math.max(0.07, Math.min(0.97, newL));

  return { L: newL, C: newC, h: newH };
};

// ============================================
// MOOD-BASED HUE GENERATION
// ============================================

const getMoodBaseHue = (mood, rng) => {
  switch (mood) {
    case 'warm':
      // Warm hues: reds, oranges, yellows (330-60, wrapping around 0)
      return rng() < 0.7 ? random(0, 65, rng) : random(330, 360, rng);
    
    case 'cool':
      // Cool hues: cyans, blues, cool purples
      return random(180, 280, rng);
    
    case 'earthy':
      // Earthy: browns, olive greens, muted oranges, terracotta
      return random(25, 120, rng);
    
    case 'neon':
      // Neon can be any hue but favors magentas, cyans, greens
      const neonRoll = rng();
      if (neonRoll < 0.33) return random(300, 330, rng); // Magenta/pink
      if (neonRoll < 0.66) return random(160, 200, rng); // Cyan/teal
      return random(90, 130, rng); // Green
    
    default:
      return random(0, 360, rng);
  }
};

const generateHarmoniousHues = (mode, count, constraints, rng) => {
  let base;
  const mood = constraints?.mood;

  if (constraints && typeof constraints.baseHue === 'number') {
    base = constraints.baseHue;
  } else if (mood === 'warm' || mood === 'cool' || mood === 'earthy' || mood === 'neon') {
    base = getMoodBaseHue(mood, rng);
  } else {
    base = random(0, 360, rng);
  }

  const hues = [];
  const jitter = (amount = 15) => random(-amount, amount, rng);

  // For warm/cool/earthy moods, reduce jitter to maintain temperature consistency
  const moodJitterMultiplier = (mood === 'warm' || mood === 'cool' || mood === 'earthy') ? 0.5 : 1;

  switch (mode) {
    case 'mono':
      for (let i = 0; i < count; i++) hues.push((base + jitter(5 * moodJitterMultiplier) + 360) % 360);
      break;
    case 'analogous':
      const range = mood === 'warm' || mood === 'cool' ? 35 : 50;
      for (let i = 0; i < count; i++) {
        const progress = count > 1 ? i / (count - 1) : 0.5;
        const offset = progress * range - (range / 2);
        hues.push((base + offset + jitter(8 * moodJitterMultiplier) + 360) % 360);
      }
      break;
    case 'complementary':
      for (let i = 0; i < count; i++) {
        if (i < Math.ceil(count / 2)) hues.push((base + jitter(15 * moodJitterMultiplier) + 360) % 360);
        else hues.push((base + 180 + jitter(15 * moodJitterMultiplier) + 360) % 360);
      }
      break;
    case 'splitComplementary':
    case 'triadic':
      const anchors = mode === 'triadic' ? [0, 120, 240] : [0, 150, 210];
      for (let i = 0; i < count; i++) {
        const anchor = anchors[i % anchors.length];
        hues.push((base + anchor + jitter(10 * moodJitterMultiplier) + 360) % 360);
      }
      break;
    default:
      for (let i = 0; i < count; i++) hues.push((base + (i * 30) + 360) % 360);
  }
  return hues;
};

// ============================================
// MOOD-BASED CHROMA/LIGHTNESS GENERATION
// ============================================

const generateCohesiveVariationsOklch = (hues, mood, count, rng) => {
  const result = [];
  const strategy = rng();

  for (let i = 0; i < count; i++) {
    const t = count > 1 ? i / (count - 1) : 0.5;
    let C, L;

    switch (mood) {
      // === SATURATION-BASED MOODS ===
      case 'pastel':
        // Soft, light, low-medium saturation
        C = random(0.04, 0.10, rng);
        L = random(0.84, 0.94, rng);
        break;

      case 'vibrant':
        // Bold, saturated, punchy
        C = random(0.15, 0.28, rng);
        L = random(0.48, 0.72, rng);
        break;

      case 'muted':
        // Desaturated, subtle, sophisticated
        C = random(0.02, 0.07, rng);
        L = random(0.38, 0.72, rng);
        break;

      // === LIGHTNESS-BASED MOODS ===
      case 'dark':
        // Deep, rich, dramatic darks
        C = random(0.06, 0.18, rng);
        L = random(0.15, 0.38, rng);
        break;

      case 'bright':
        // High luminosity, energetic
        C = random(0.10, 0.22, rng);
        L = random(0.72, 0.92, rng);
        break;

      case 'moody':
        // Dramatic, emotional, medium-dark with presence
        C = random(0.08, 0.18, rng);
        L = random(0.20, 0.50, rng);
        break;

      // === FEELING-BASED MOODS ===
      case 'soft':
        // Gentle, calming, approachable
        C = random(0.03, 0.09, rng);
        L = random(0.68, 0.88, rng);
        break;

      case 'elegant':
        // Sophisticated, refined, balanced
        C = random(0.04, 0.12, rng);
        L = random(0.32, 0.68, rng);
        break;

      case 'playful':
        // Fun, varied, colorful energy
        C = random(0.14, 0.26, rng);
        L = random(0.52, 0.82, rng);
        break;

      // === TEMPERATURE-BASED MOODS ===
      case 'warm':
        // Inviting, cozy warmth
        C = random(0.08, 0.18, rng);
        L = random(0.42, 0.78, rng);
        break;

      case 'cool':
        // Calm, serene, professional
        C = random(0.06, 0.15, rng);
        L = random(0.42, 0.78, rng);
        break;

      // === STYLE-BASED MOODS ===
      case 'earthy':
        // Natural, organic, grounded
        C = random(0.04, 0.14, rng);
        L = random(0.28, 0.62, rng);
        break;

      case 'retro':
        // Vintage-inspired, slightly desaturated with character
        C = random(0.08, 0.16, rng);
        L = random(0.42, 0.72, rng);
        break;

      case 'neon':
        // Electric, high-energy, maximum saturation
        C = random(0.22, 0.35, rng);
        L = random(0.55, 0.78, rng);
        break;

      // === DEFAULT / ANY ===
      default:
        // Original behavior with natural light-to-dark gradient variation
        C = 0.07 + (Math.sin(t * Math.PI) * 0.07) + random(-0.02, 0.02, rng);

        if (strategy < 0.40) {
          // Light to dark gradient
          L = 0.22 + (t * 0.62) + random(-0.05, 0.05, rng);
        } else if (strategy < 0.80) {
          // Dark to light gradient
          L = 0.84 - (t * 0.62) + random(-0.05, 0.05, rng);
        } else {
          // Anchored extremes with varied midtones
          if (i === 0) L = random(0.20, 0.35, rng);
          else if (i === count - 1) L = random(0.78, 0.92, rng);
          else L = random(0.38, 0.72, rng);
        }
        break;
    }

    result.push({ C, L });
  }
  return result;
};

// NEW: Sorts colors to maximize adjacent contrast (Zig-Zag: Dark, Light, Dark, Light)
const optimizeForContrast = (colors, targetRatio) => {
  // 1. Sort by Luminance first (Darkest to Lightest)
  const sortedByLum = colors.map(hex => ({
    hex,
    lum: relativeLuminance(hex),
    oklch: hexToOklch(hex)
  })).sort((a, b) => a.lum - b.lum);

  // 2. Zipper Merge to maximize difference
  const result = [];
  let left = 0;
  let right = sortedByLum.length - 1;

  while (left <= right) {
    if (left === right) {
      result.push(sortedByLum[left]);
    } else {
      result.push(sortedByLum[left]); // Add Dark
      result.push(sortedByLum[right]); // Add Light
    }
    left++;
    right--;
  }

  // 3. Enforce Minimum Contrast (Nudge values if sorting isn't enough)
  if (targetRatio > 1.5) {
    for (let i = 0; i < result.length - 1; i++) {
      const c1 = result[i];
      let c2 = result[i + 1];

      const currentRatio = wcagContrastRatio(c1.hex, c2.hex);

      if (currentRatio < targetRatio) {
        let { L, C, h } = c2.oklch;
        
        const step = 0.05; 
        const maxAttempts = 10;
        let attempts = 0;

        let bestHex = c2.hex;
        let bestRatio = currentRatio;

        while (attempts < maxAttempts && bestRatio < targetRatio) {
          if (c1.lum < 0.5) {
            L = Math.min(0.98, L + step);
          } else {
            L = Math.max(0.02, L - step);
          }
          
          const newHex = oklchToHex(L, C, h);
          const newRatio = wcagContrastRatio(c1.hex, newHex);
          
          if (newRatio > bestRatio) {
            bestRatio = newRatio;
            bestHex = newHex;
          }
          
          if (L >= 0.98 || L <= 0.02) break;
          attempts++;
        }
        
        result[i + 1] = { ...c2, hex: bestHex, oklch: { L, C, h }, lum: relativeLuminance(bestHex) };
      }
    }
  }

  return result.map(c => c.hex);
};

// ============================================
// 3. MAIN PALETTE GENERATOR (OKLCH-based)
// ============================================

export const generateRandomPalette = (mode = 'auto', count = 5, constraints = {}, rng = Math.random) => {
  let harmonyMode = mode;

  if (mode === 'auto') {
    const roll = rng();

    if (count <= 2) {
      if (roll < 0.50) harmonyMode = 'complementary';
      else if (roll < 0.80) harmonyMode = 'mono';
      else harmonyMode = 'analogous';
    } else if (count === 3) {
      if (roll < 0.40) harmonyMode = 'splitComplementary';
      else if (roll < 0.70) harmonyMode = 'triadic';
      else if (roll < 0.90) harmonyMode = 'analogous';
      else harmonyMode = 'mono';
    } else if (count >= 6) {
      if (roll < 0.60) harmonyMode = 'analogous';
      else if (roll < 0.85) harmonyMode = 'mono';
      else harmonyMode = 'splitComplementary';
    } else {
      if (roll < 0.45) harmonyMode = 'analogous';
      else if (roll < 0.65) harmonyMode = 'mono';
      else if (roll < 0.85) harmonyMode = 'complementary';
      else if (roll < 0.95) harmonyMode = 'splitComplementary';
      else harmonyMode = 'triadic';
    }
  }

  const hues = generateHarmoniousHues(harmonyMode, count, constraints, rng);
  const clValues = generateCohesiveVariationsOklch(hues, constraints.mood || 'any', count, rng);

  let palette = [];
  for (let i = 0; i < count; i++) {
    const h = hues[i];
    let { C, L } = clValues[i];

    // If High Contrast is requested, force wider spread of Lightness
    if (constraints.minContrast && constraints.minContrast > 2.5) {
      if (i % 2 === 0) L = Math.max(0.15, Math.min(0.4, L));
      else L = Math.max(0.6, Math.min(0.95, L));
    }

    const polished = adjustForVibrancyOklch(L, C, h);

    if (constraints.darkModeFriendly && polished.L > 0.85) polished.L = 0.85;

    palette.push(oklchToHex(polished.L, polished.C, polished.h));
  }

  if (constraints.minContrast && constraints.minContrast > 1.5) {
    return optimizeForContrast(palette, constraints.minContrast);
  } else {
    return optimizeColorOrder(palette);
  }
};

// ============================================
// 4. UTILITIES (Sorting, Contrast, Shades)
// ============================================

const getHueDistance = (h1, h2) => {
  let diff = Math.abs(h1 - h2);
  return diff > 180 ? 360 - diff : diff;
};

const getColorDistanceOklch = (c1, c2) => {
  const hDist = getHueDistance(c1.h, c2.h);
  const cDist = Math.abs(c1.C - c2.C) * 500;
  const lDist = Math.abs(c1.L - c2.L) * 100;
  return Math.sqrt((hDist * hDist * 0.3) + (cDist * cDist) + (lDist * lDist * 2));
};

const optimizeColorOrder = (colors) => {
  const colorData = colors.map((hex) => ({
    hex,
    hsl: hexToHsl(hex),
    oklch: hexToOklch(hex)
  }));

  const hues = colorData.map(c => c.oklch.h);
  const minHue = Math.min(...hues);
  const maxHue = Math.max(...hues);
  let hueSpread = maxHue - minHue;
  if (hueSpread > 180) hueSpread = 360 - hueSpread;

  if (hueSpread < 40) {
    return colorData.sort((a, b) => a.oklch.L - b.oklch.L).map(c => c.hex);
  }

  let current = colorData.reduce((prev, curr) => (curr.oklch.L < prev.oklch.L ? curr : prev));
  const sorted = [current];
  let remaining = colorData.filter(c => c !== current);

  while (remaining.length > 0) {
    let nearest = null;
    let minDist = Infinity;
    for (const candidate of remaining) {
      const dist = getColorDistanceOklch(current.oklch, candidate.oklch);
      if (dist < minDist) {
        minDist = dist;
        nearest = candidate;
      }
    }
    if (nearest) {
      sorted.push(nearest);
      current = nearest;
      remaining = remaining.filter(c => c !== nearest);
    } else break;
  }
  return sorted.map(c => c.hex);
};

const relativeLuminance = (hex) => {
  const r = srgbToLinear(parseInt(hex.slice(1, 3), 16) / 255);
  const g = srgbToLinear(parseInt(hex.slice(3, 5), 16) / 255);
  const b = srgbToLinear(parseInt(hex.slice(5, 7), 16) / 255);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
};

const wcagContrastRatio = (hexA, hexB) => {
  const lA = relativeLuminance(hexA);
  const lB = relativeLuminance(hexB);
  const lighter = Math.max(lA, lB);
  const darker = Math.min(lA, lB);
  return (lighter + 0.05) / (darker + 0.05);
};

export const getContrastColor = (hex) => {
  const contrastWithBlack = wcagContrastRatio(hex, '#000000');
  const contrastWithWhite = wcagContrastRatio(hex, '#FFFFFF');
  return contrastWithBlack > contrastWithWhite ? '#000000' : '#FFFFFF';
};

export const generateBridgeColor = (colorBefore, colorAfter) => {
  const c1 = hexToOklch(colorBefore);
  const c2 = hexToOklch(colorAfter);

  let h1 = c1.h;
  let h2 = c2.h;
  let diff = h2 - h1;
  if (diff > 180) h2 -= 360;
  if (diff < -180) h2 += 360;

  let h = (h1 + h2) / 2;
  if (h < 0) h += 360;
  if (h >= 360) h -= 360;

  const C = (c1.C + c2.C) / 2;
  const L = (c1.L + c2.L) / 2;

  const polished = adjustForVibrancyOklch(L, C, h);
  return oklchToHex(polished.L, polished.C, polished.h);
};

export const generateShades = (hex, totalSteps = 20) => {
  const { L, C, h } = hexToOklch(hex);
  const shades = [];
  const maxLight = 0.97;
  const minLight = 0.08;

  const currentIndex = Math.round((1 - ((L - minLight) / (maxLight - minLight))) * (totalSteps - 1));
  const clampedIndex = Math.max(0, Math.min(totalSteps - 1, currentIndex));

  if (clampedIndex > 0) {
    const stepSize = (maxLight - L) / clampedIndex;
    for (let i = 0; i < clampedIndex; i++) {
      const newL = maxLight - (stepSize * i);
      const newC = C * (0.5 + 0.5 * (1 - (newL - L) / (maxLight - L)));
      shades.push(oklchToHex(newL, Math.max(0.01, newC), h));
    }
  }

  shades.push(hex);

  const remainingSteps = totalSteps - 1 - clampedIndex;
  if (remainingSteps > 0) {
    const stepSize = (L - minLight) / remainingSteps;
    for (let i = 1; i <= remainingSteps; i++) {
      const newL = L - (stepSize * i);
      const newC = C * (0.6 + 0.4 * ((newL - minLight) / (L - minLight)));
      shades.push(oklchToHex(newL, Math.max(0.01, newC), h));
    }
  }

  return shades;
};

const colorBlindnessMatrices = {
  protanopia: [[0.567, 0.433, 0], [0.558, 0.442, 0], [0, 0.242, 0.758]],
  deuteranopia: [[0.625, 0.375, 0], [0.7, 0.3, 0], [0, 0.3, 0.7]],
  tritanopia: [[0.95, 0.05, 0], [0, 0.433, 0.567], [0, 0.475, 0.525]],
  achromatopsia: [[0.299, 0.587, 0.114], [0.299, 0.587, 0.114], [0.299, 0.587, 0.114]],
};

export const simulateColorBlindness = (hex, type) => {
  if (type === 'normal' || !colorBlindnessMatrices[type]) return hex;
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  const matrix = colorBlindnessMatrices[type];
  const newR = Math.round(matrix[0][0] * r + matrix[0][1] * g + matrix[0][2] * b);
  const newG = Math.round(matrix[1][0] * r + matrix[1][1] * g + matrix[1][2] * b);
  const newB = Math.round(matrix[2][0] * r + matrix[2][1] * g + matrix[2][2] * b);
  const clamp = (v) => Math.max(0, Math.min(255, v));
  return `#${clamp(newR).toString(16).padStart(2, '0')}${clamp(newG).toString(16).padStart(2, '0')}${clamp(newB).toString(16).padStart(2, '0')}`.toUpperCase();
};

// ============================================
// 5. DETERMINISTIC SEED SYSTEM
// ============================================

const createSeededRandom = (seed) => {
  let state = seed;
  return () => {
    state = (state * 1664525 + 1013904223) % 4294967296;
    return state / 4294967296;
  };
};

const hashString = (str) => {
  let hash = 5381;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) + hash) ^ str.charCodeAt(i);
  }
  return Math.abs(hash);
};

const pickFromArray = (arr, rng) => arr[Math.floor(rng() * arr.length)];

const shuffleArray = (arr, rng) => {
  const result = [...arr];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
};

// ============================================
// 6. PRECISE COLOR NAMING SYSTEM
// ============================================

const getColorName = (h, s, l, C) => {
  // Normalize values
  h = ((h % 360) + 360) % 360;
  
  // Handle achromatic colors (very low saturation)
  if (s < 8 || C < 0.02) {
    if (l < 8) return { name: 'black', family: 'neutral', descriptor: 'deep', mood: 'dramatic' };
    if (l < 18) return { name: 'charcoal', family: 'neutral', descriptor: 'dark', mood: 'sophisticated' };
    if (l < 30) return { name: 'dark gray', family: 'neutral', descriptor: 'deep', mood: 'grounded' };
    if (l < 45) return { name: 'gray', family: 'neutral', descriptor: 'medium', mood: 'balanced' };
    if (l < 60) return { name: 'silver', family: 'neutral', descriptor: 'cool', mood: 'refined' };
    if (l < 75) return { name: 'light gray', family: 'neutral', descriptor: 'soft', mood: 'gentle' };
    if (l < 88) return { name: 'pale gray', family: 'neutral', descriptor: 'airy', mood: 'minimal' };
    if (l < 96) return { name: 'off-white', family: 'neutral', descriptor: 'warm', mood: 'clean' };
    return { name: 'white', family: 'neutral', descriptor: 'pure', mood: 'fresh' };
  }

  // Near-neutral warm tones (low saturation, warm hue)
  if (s < 20 && ((h >= 20 && h <= 50) || l < 40)) {
    if (l < 25) return { name: 'espresso', family: 'brown', descriptor: 'rich', mood: 'grounded' };
    if (l < 40) return { name: 'taupe', family: 'brown', descriptor: 'earthy', mood: 'natural' };
    if (l < 55) return { name: 'mushroom', family: 'brown', descriptor: 'muted', mood: 'organic' };
    if (l < 70) return { name: 'greige', family: 'neutral', descriptor: 'warm', mood: 'sophisticated' };
    if (l < 85) return { name: 'cream', family: 'neutral', descriptor: 'soft', mood: 'inviting' };
    return { name: 'ivory', family: 'neutral', descriptor: 'delicate', mood: 'elegant' };
  }

  // Chromatic color naming with saturation and lightness modifiers
  const getModifier = (sat, light) => {
    if (light < 20) return { prefix: 'dark', mood: 'dramatic' };
    if (light < 35) return { prefix: 'deep', mood: 'rich' };
    if (light > 85) return { prefix: 'pale', mood: 'gentle' };
    if (light > 75) return { prefix: 'light', mood: 'airy' };
    if (sat < 30) return { prefix: 'muted', mood: 'subtle' };
    if (sat < 50) return { prefix: 'soft', mood: 'calm' };
    if (sat > 80) return { prefix: 'vivid', mood: 'energetic' };
    if (sat > 65) return { prefix: 'bright', mood: 'vibrant' };
    return { prefix: '', mood: 'balanced' };
  };

  const mod = getModifier(s, l);

  // Detailed hue-based naming
  let baseColor;
  
  // Reds (345-360, 0-10)
  if (h >= 345 || h < 10) {
    if (l < 30) baseColor = { name: 'burgundy', family: 'red', descriptor: 'wine-toned' };
    else if (l < 45 && s > 50) baseColor = { name: 'crimson', family: 'red', descriptor: 'bold' };
    else if (l > 70 && s < 50) baseColor = { name: 'rose', family: 'red', descriptor: 'romantic' };
    else if (l > 75) baseColor = { name: 'blush', family: 'red', descriptor: 'delicate' };
    else if (s > 70) baseColor = { name: 'scarlet', family: 'red', descriptor: 'striking' };
    else baseColor = { name: 'red', family: 'red', descriptor: 'classic' };
  }
  // Red-orange (10-20)
  else if (h >= 10 && h < 20) {
    if (l < 35) baseColor = { name: 'rust', family: 'orange', descriptor: 'earthy' };
    else if (l < 50) baseColor = { name: 'terracotta', family: 'orange', descriptor: 'warm' };
    else if (s > 70) baseColor = { name: 'vermilion', family: 'orange', descriptor: 'fiery' };
    else if (l > 70) baseColor = { name: 'peach', family: 'orange', descriptor: 'soft' };
    else baseColor = { name: 'burnt orange', family: 'orange', descriptor: 'rich' };
  }
  // Orange (20-35)
  else if (h >= 20 && h < 35) {
    if (l < 35) baseColor = { name: 'brown', family: 'brown', descriptor: 'grounded' };
    else if (l < 50 && s < 50) baseColor = { name: 'caramel', family: 'brown', descriptor: 'warm' };
    else if (l > 75) baseColor = { name: 'apricot', family: 'orange', descriptor: 'gentle' };
    else if (s > 70) baseColor = { name: 'tangerine', family: 'orange', descriptor: 'energetic' };
    else baseColor = { name: 'orange', family: 'orange', descriptor: 'warm' };
  }
  // Orange-yellow (35-48)
  else if (h >= 35 && h < 48) {
    if (l < 40) baseColor = { name: 'bronze', family: 'brown', descriptor: 'metallic' };
    else if (l > 75) baseColor = { name: 'champagne', family: 'yellow', descriptor: 'elegant' };
    else if (s > 70) baseColor = { name: 'amber', family: 'orange', descriptor: 'golden' };
    else if (s < 40) baseColor = { name: 'sand', family: 'neutral', descriptor: 'natural' };
    else baseColor = { name: 'gold', family: 'yellow', descriptor: 'luxurious' };
  }
  // Yellow (48-65)
  else if (h >= 48 && h < 65) {
    if (l < 45) baseColor = { name: 'olive', family: 'green', descriptor: 'earthy' };
    else if (l > 80 && s < 50) baseColor = { name: 'cream', family: 'yellow', descriptor: 'soft' };
    else if (l > 75) baseColor = { name: 'lemon', family: 'yellow', descriptor: 'fresh' };
    else if (s > 70) baseColor = { name: 'canary', family: 'yellow', descriptor: 'bright' };
    else if (s < 40) baseColor = { name: 'khaki', family: 'yellow', descriptor: 'muted' };
    else baseColor = { name: 'yellow', family: 'yellow', descriptor: 'sunny' };
  }
  // Yellow-green (65-80)
  else if (h >= 65 && h < 80) {
    if (l < 40) baseColor = { name: 'moss', family: 'green', descriptor: 'organic' };
    else if (l > 75) baseColor = { name: 'honeydew', family: 'green', descriptor: 'fresh' };
    else if (s > 60) baseColor = { name: 'chartreuse', family: 'green', descriptor: 'electric' };
    else baseColor = { name: 'lime', family: 'green', descriptor: 'zesty' };
  }
  // Green (80-150)
  else if (h >= 80 && h < 150) {
    if (h < 100) {
      if (l < 35) baseColor = { name: 'forest', family: 'green', descriptor: 'deep' };
      else if (s > 60) baseColor = { name: 'grass', family: 'green', descriptor: 'natural' };
      else baseColor = { name: 'green', family: 'green', descriptor: 'fresh' };
    } else if (h < 130) {
      if (l < 30) baseColor = { name: 'hunter', family: 'green', descriptor: 'classic' };
      else if (l > 70) baseColor = { name: 'mint', family: 'green', descriptor: 'cool' };
      else if (s > 50) baseColor = { name: 'emerald', family: 'green', descriptor: 'jewel-toned' };
      else baseColor = { name: 'sage', family: 'green', descriptor: 'muted' };
    } else {
      if (l < 35) baseColor = { name: 'pine', family: 'green', descriptor: 'deep' };
      else if (l > 70) baseColor = { name: 'seafoam', family: 'green', descriptor: 'soft' };
      else baseColor = { name: 'jade', family: 'green', descriptor: 'rich' };
    }
  }
  // Cyan-green (150-170)
  else if (h >= 150 && h < 170) {
    if (l < 35) baseColor = { name: 'dark teal', family: 'teal', descriptor: 'sophisticated' };
    else if (l > 70) baseColor = { name: 'aquamarine', family: 'teal', descriptor: 'refreshing' };
    else if (s > 50) baseColor = { name: 'teal', family: 'teal', descriptor: 'balanced' };
    else baseColor = { name: 'sea green', family: 'teal', descriptor: 'oceanic' };
  }
  // Cyan (170-195)
  else if (h >= 170 && h < 195) {
    if (l < 35) baseColor = { name: 'dark cyan', family: 'cyan', descriptor: 'deep' };
    else if (l > 75) baseColor = { name: 'pale cyan', family: 'cyan', descriptor: 'icy' };
    else if (s > 60) baseColor = { name: 'cyan', family: 'cyan', descriptor: 'electric' };
    else baseColor = { name: 'aqua', family: 'cyan', descriptor: 'fresh' };
  }
  // Sky blue (195-215)
  else if (h >= 195 && h < 215) {
    if (l < 35) baseColor = { name: 'prussian', family: 'blue', descriptor: 'historic' };
    else if (l > 75) baseColor = { name: 'sky', family: 'blue', descriptor: 'open' };
    else if (s > 50) baseColor = { name: 'cerulean', family: 'blue', descriptor: 'clear' };
    else baseColor = { name: 'steel blue', family: 'blue', descriptor: 'professional' };
  }
  // Blue (215-250)
  else if (h >= 215 && h < 250) {
    if (h < 230) {
      if (l < 30) baseColor = { name: 'navy', family: 'blue', descriptor: 'classic' };
      else if (l > 70) baseColor = { name: 'periwinkle', family: 'blue', descriptor: 'soft' };
      else if (s > 60) baseColor = { name: 'royal blue', family: 'blue', descriptor: 'regal' };
      else baseColor = { name: 'blue', family: 'blue', descriptor: 'trustworthy' };
    } else {
      if (l < 30) baseColor = { name: 'midnight', family: 'blue', descriptor: 'dramatic' };
      else if (l > 70) baseColor = { name: 'lavender blue', family: 'blue', descriptor: 'dreamy' };
      else if (s > 60) baseColor = { name: 'cobalt', family: 'blue', descriptor: 'bold' };
      else baseColor = { name: 'slate blue', family: 'blue', descriptor: 'sophisticated' };
    }
  }
  // Blue-violet (250-270)
  else if (h >= 250 && h < 270) {
    if (l < 30) baseColor = { name: 'indigo', family: 'purple', descriptor: 'deep' };
    else if (l > 75) baseColor = { name: 'lavender', family: 'purple', descriptor: 'gentle' };
    else if (s > 50) baseColor = { name: 'violet', family: 'purple', descriptor: 'vivid' };
    else baseColor = { name: 'purple', family: 'purple', descriptor: 'creative' };
  }
  // Purple (270-295)
  else if (h >= 270 && h < 295) {
    if (l < 30) baseColor = { name: 'eggplant', family: 'purple', descriptor: 'rich' };
    else if (l > 75) baseColor = { name: 'lilac', family: 'purple', descriptor: 'delicate' };
    else if (s > 60) baseColor = { name: 'purple', family: 'purple', descriptor: 'royal' };
    else baseColor = { name: 'plum', family: 'purple', descriptor: 'muted' };
  }
  // Magenta (295-320)
  else if (h >= 295 && h < 320) {
    if (l < 35) baseColor = { name: 'dark magenta', family: 'magenta', descriptor: 'intense' };
    else if (l > 75) baseColor = { name: 'orchid', family: 'magenta', descriptor: 'exotic' };
    else if (s > 60) baseColor = { name: 'magenta', family: 'magenta', descriptor: 'bold' };
    else baseColor = { name: 'mauve', family: 'magenta', descriptor: 'vintage' };
  }
  // Pink (320-345)
  else {
    if (l < 40) baseColor = { name: 'maroon', family: 'red', descriptor: 'deep' };
    else if (l > 80 && s < 40) baseColor = { name: 'blush', family: 'pink', descriptor: 'subtle' };
    else if (l > 75) baseColor = { name: 'pink', family: 'pink', descriptor: 'soft' };
    else if (s > 60) baseColor = { name: 'hot pink', family: 'pink', descriptor: 'energetic' };
    else if (s > 40) baseColor = { name: 'rose', family: 'pink', descriptor: 'romantic' };
    else baseColor = { name: 'dusty rose', family: 'pink', descriptor: 'muted' };
  }

  // Combine modifier with base color
  const fullName = mod.prefix ? `${mod.prefix} ${baseColor.name}` : baseColor.name;
  
  return {
    name: fullName,
    baseName: baseColor.name,
    family: baseColor.family,
    descriptor: baseColor.descriptor,
    mood: mod.mood,
    prefix: mod.prefix
  };
};

// ============================================
// 7. DEEP COLOR ANALYSIS
// ============================================

const analyzeColorDeeply = (hex) => {
  const hsl = hexToHsl(hex);
  const oklch = hexToOklch(hex);
  const rgb = {
    r: parseInt(hex.slice(1, 3), 16),
    g: parseInt(hex.slice(3, 5), 16),
    b: parseInt(hex.slice(5, 7), 16)
  };
  
  const naming = getColorName(hsl.h, hsl.s, hsl.l, oklch.C);
  
  // Determine temperature
  let temperature;
  const h = hsl.h;
  if (hsl.s < 10) {
    temperature = 'neutral';
  } else if ((h >= 0 && h < 70) || h >= 320) {
    temperature = 'warm';
  } else if (h >= 170 && h < 280) {
    temperature = 'cool';
  } else {
    temperature = 'neutral-leaning';
  }

  // Determine visual weight
  let weight;
  if (hsl.l < 30) weight = 'heavy';
  else if (hsl.l < 50) weight = 'substantial';
  else if (hsl.l < 70) weight = 'medium';
  else if (hsl.l < 85) weight = 'light';
  else weight = 'airy';

  // Determine energy level
  let energy;
  if (hsl.s > 70 && hsl.l > 40 && hsl.l < 70) energy = 'high';
  else if (hsl.s > 50 || (hsl.l > 70 && hsl.s > 30)) energy = 'medium';
  else if (hsl.s < 20 || hsl.l < 25) energy = 'low';
  else energy = 'moderate';

  return {
    hex,
    hsl,
    oklch,
    rgb,
    naming,
    temperature,
    weight,
    energy,
    isNeutral: hsl.s < 15,
    isDark: hsl.l < 35,
    isLight: hsl.l > 70,
    isPastel: hsl.s < 50 && hsl.l > 70,
    isVivid: hsl.s > 65 && hsl.l > 35 && hsl.l < 75,
    isMuted: hsl.s < 40 && hsl.l > 25 && hsl.l < 75
  };
};

const analyzePaletteRelationships = (colorAnalyses) => {
  const relationships = [];
  
  for (let i = 0; i < colorAnalyses.length - 1; i++) {
    const c1 = colorAnalyses[i];
    const c2 = colorAnalyses[i + 1];
    
    // Calculate hue difference
    let hueDiff = Math.abs(c1.hsl.h - c2.hsl.h);
    if (hueDiff > 180) hueDiff = 360 - hueDiff;
    
    // Calculate contrast
    const contrast = wcagContrastRatio(c1.hex, c2.hex);
    
    // Determine relationship type
    let relationshipType;
    if (c1.isNeutral || c2.isNeutral) {
      relationshipType = 'neutral-chromatic';
    } else if (hueDiff < 20) {
      relationshipType = 'tonal';
    } else if (hueDiff < 45) {
      relationshipType = 'analogous';
    } else if (hueDiff > 150 && hueDiff < 210) {
      relationshipType = 'complementary';
    } else if (hueDiff > 90 && hueDiff < 150) {
      relationshipType = 'triadic-adjacent';
    } else {
      relationshipType = 'contrasting';
    }

    // Temperature transition
    let tempTransition;
    if (c1.temperature === c2.temperature) {
      tempTransition = `maintains ${c1.temperature} temperature`;
    } else {
      tempTransition = `transitions from ${c1.temperature} to ${c2.temperature}`;
    }

    relationships.push({
      from: c1,
      to: c2,
      hueDifference: hueDiff,
      contrast: contrast,
      relationshipType,
      tempTransition,
      isHighContrast: contrast >= 4.5,
      isLowContrast: contrast < 2
    });
  }
  
  return relationships;
};

const identifyPaletteRoles = (colorAnalyses) => {
  const roles = {
    dominant: null,
    accents: [],
    neutrals: [],
    backgrounds: [],
    text: []
  };
  
  // Sort by visual prominence (saturation * middle-lightness factor)
  const prominence = colorAnalyses.map((c, i) => {
    const middleness = 1 - Math.abs(c.hsl.l - 50) / 50;
    const score = c.hsl.s * middleness;
    return { color: c, score, index: i };
  }).sort((a, b) => b.score - a.score);
  
  colorAnalyses.forEach((c, i) => {
    if (c.isNeutral) {
      roles.neutrals.push({ color: c, index: i });
      if (c.hsl.l > 85) roles.backgrounds.push({ color: c, index: i });
      if (c.hsl.l < 25) roles.text.push({ color: c, index: i });
    } else if (c.hsl.l > 80) {
      roles.backgrounds.push({ color: c, index: i });
    } else if (c.hsl.l < 20) {
      roles.text.push({ color: c, index: i });
    }
  });
  
  // Most prominent chromatic color is dominant
  const dominantCandidate = prominence.find(p => !p.color.isNeutral);
  if (dominantCandidate) {
    roles.dominant = { color: dominantCandidate.color, index: dominantCandidate.index };
  }
  
  // Other chromatic colors are accents
  prominence.forEach(p => {
    if (!p.color.isNeutral && p !== dominantCandidate) {
      roles.accents.push({ color: p.color, index: p.index });
    }
  });
  
  return roles;
};

// ============================================
// 8. CONTENT TEMPLATES & VARIATION SYSTEM
// ============================================

const templates = {  
  // Opening sentence variations
  openings: {
    vibrant: [
      "This ${count}-color palette delivers bold visual impact through carefully balanced saturation levels.",
      "A striking collection of ${count} colors designed to command attention and create memorable impressions.",
      "These ${count} vibrant hues work together to produce energetic, eye-catching compositions.",
      "Built around high-saturation values, this ${count}-color scheme brings dynamic energy to any project."
    ],
    muted: [
      "This sophisticated ${count}-color palette employs restrained saturation for refined elegance.",
      "A thoughtfully desaturated collection of ${count} tones that prioritizes subtlety over boldness.",
      "These ${count} muted colors create understated harmony suitable for content-focused design.",
      "With carefully reduced chroma, this ${count}-color scheme delivers quiet sophistication."
    ],
    pastel: [
      "This gentle ${count}-color palette combines soft saturation with high luminosity for an airy aesthetic.",
      "A delicate collection of ${count} pastel tones that creates approachable, welcoming visuals.",
      "These ${count} light-touched colors balance chromatic interest with visual softness.",
      "Built on pale values, this ${count}-color scheme offers calm, non-aggressive visual presence."
    ],
    dark: [
      "This dramatic ${count}-color palette leverages deep values for substantial visual weight.",
      "A rich collection of ${count} dark tones that establishes authority and sophistication.",
      "These ${count} low-lightness colors create moody atmospheres with inherent depth.",
      "Anchored in shadow, this ${count}-color scheme provides grounding visual foundation."
    ],
    balanced: [
      "This versatile ${count}-color palette balances chromatic variety with cohesive harmony.",
      "A well-structured collection of ${count} colors offering both contrast and unity.",
      "These ${count} thoughtfully selected hues provide flexibility across diverse applications.",
      "With measured variety, this ${count}-color scheme adapts to multiple design contexts."
    ]
  },

  // Individual color descriptions
  colorDescriptions: {
    dominant: [
      "${colorName} (${hex}) serves as the palette's visual anchor, ${descriptor} character drawing the eye and establishing chromatic identity.",
      "The ${descriptor} ${colorName} at ${hex} provides the palette's primary visual weight, commanding attention as the dominant element.",
      "At ${hex}, ${colorName} functions as the palette's focal point, its ${descriptor} quality creating a clear visual hierarchy."
    ],
    accent: [
      "${colorName} (${hex}) acts as an accent tone, its ${descriptor} nature providing contrast without competing for dominance.",
      "The ${descriptor} ${colorName} at ${hex} offers supporting visual interest, complementing the dominant hue.",
      "At ${hex}, this ${colorName} contributes ${descriptor} energy as a secondary element in the composition."
    ],
    neutral: [
      "${colorName} (${hex}) provides essential breathing room, its ${descriptor} presence allowing chromatic colors to shine.",
      "The ${descriptor} ${colorName} at ${hex} offers visual rest, balancing the palette's more saturated elements.",
      "At ${hex}, ${colorName} functions as a grounding element, its ${descriptor} quality supporting overall harmony."
    ],
    background: [
      "${colorName} (${hex}) works effectively as a background tone, its ${descriptor} lightness creating spatial depth.",
      "The ${descriptor} ${colorName} at ${hex} provides excellent canvas potential for overlaid elements.",
      "At ${hex}, this ${colorName} offers ${descriptor} foundation suitable for text and graphic placement."
    ]
  },

  // Relationship descriptions
  transitions: {
    tonal: [
      "The shift from ${color1} to ${color2} creates tonal continuity, maintaining hue consistency while varying lightness.",
      "Moving between ${color1} and ${color2} produces a smooth tonal gradient within the same color family.",
      "${color1} flows naturally into ${color2}, the tonal relationship creating seamless visual connection."
    ],
    analogous: [
      "The progression from ${color1} to ${color2} follows analogous harmony, adjacent hues creating natural flow.",
      "${color1} and ${color2} share the comfortable relationship of neighboring wheel positions.",
      "Moving from ${color1} into ${color2} demonstrates analogous color theory's inherent visual comfort."
    ],
    complementary: [
      "The jump from ${color1} to ${color2} introduces complementary tension, opposite hues generating visual energy.",
      "${color1} and ${color2} create dynamic contrast through their complementary relationship.",
      "The opposition between ${color1} and ${color2} follows complementary principles for maximum chromatic contrast."
    ],
    contrasting: [
      "${color1} and ${color2} create deliberate visual contrast, their difference adding compositional interest.",
      "The distinction between ${color1} and ${color2} provides clear visual separation.",
      "Moving from ${color1} to ${color2} introduces intentional variety into the palette's flow."
    ],
    'neutral-chromatic': [
      "The pairing of ${color1} with ${color2} balances chromatic and neutral elements.",
      "${color1} alongside ${color2} demonstrates effective use of neutrals to frame color.",
      "The contrast between ${color1} and ${color2} leverages neutral space to enhance chromatic impact."
    ]
  },

  // Application contexts
  applications: {
    webUI: {
      light: [
        "The palette's light values excel in interface design, providing comfortable backgrounds for extended screen time.",
        "High luminosity supports readability, making these colors suitable for content-heavy web applications.",
        "Light backgrounds from this palette reduce eye strain during prolonged digital interaction."
      ],
      dark: [
        "These deep values support modern dark mode interfaces, reducing light emission while maintaining visual hierarchy.",
        "The palette's dark foundation provides immersive experiences for media-focused applications.",
        "Low-lightness colors here create sophisticated UI aesthetics popular in professional software."
      ],
      contrast: [
        "With ${contrastRatio}:1 maximum contrast, the palette ${contrastAssessment} WCAG accessibility guidelines.",
        "The ${contrastRatio}:1 contrast ratio between lightest and darkest values ${contrastAdvice}.",
        "Accessibility testing shows ${contrastRatio}:1 internal contrast, ${contrastRecommendation}."
      ]
    },
    branding: {
      warm: [
        "Warm tones here communicate approachability and energy, suitable for hospitality, food service, and lifestyle brands.",
        "The palette's warm character creates emotional resonance appropriate for personal and community-focused branding.",
        "These inviting warm hues support brands seeking friendly, accessible market positioning."
      ],
      cool: [
        "Cool tones establish professionalism and clarity, appropriate for technology, healthcare, and financial services.",
        "The palette's cool character projects competence and trustworthiness in corporate applications.",
        "These measured cool hues support brands requiring professional credibility."
      ],
      vibrant: [
        "High saturation creates brand recognition through chromatic distinctiveness in competitive markets.",
        "Bold color values here support attention-demanding marketing and youth-oriented positioning.",
        "The palette's vibrancy enables memorable brand presence across physical and digital touchpoints."
      ],
      muted: [
        "Restrained saturation projects sophistication appropriate for luxury, professional services, and heritage brands.",
        "Muted tones here support premium positioning where aggressive color would undermine brand values.",
        "The palette's subtlety communicates maturity and established credibility."
      ]
    },
    print: {
      vivid: [
        "High saturation requires attention during RGB-to-CMYK conversion. Request press proofs for critical applications.",
        "Vivid values may shift in print; consider Pantone matching for brand-critical color reproduction.",
        "Allow for substrate influence on saturated colors; uncoated papers will absorb more ink, reducing intensity."
      ],
      muted: [
        "Desaturated colors reproduce more predictably across printing methods and paper stocks.",
        "These muted values maintain consistency between screen preview and printed output.",
        "Lower saturation reduces registration sensitivity in multi-color process printing."
      ],
      contrast: [
        "The palette's tonal range supports clear reproduction in both color and grayscale printing scenarios.",
        "Strong value differentiation ensures readability when printed on various paper qualities.",
        "Internal contrast levels maintain hierarchy whether printed digitally or via offset methods."
      ]
    },
    interior: {
      light: [
        "High-lightness colors maximize perceived space, ideal for compact rooms and apartments.",
        "Light values reflect ambient illumination, brightening spaces with limited natural light.",
        "These airy tones create gallery-like neutrality, allowing furnishings and art to command attention."
      ],
      dark: [
        "Deep values add drama suitable for feature walls, libraries, and entertainment spaces.",
        "Dark tones create intimate atmospheres in social spaces where conversation is prioritized.",
        "These grounding colors anchor open-plan spaces when applied to architectural elements."
      ],
      warm: [
        "Warm colors compensate for north-facing orientation and create psychological comfort.",
        "These inviting tones support residential spaces prioritizing relaxation and social gathering.",
        "Warm palettes photograph well under typical interior lighting conditions."
      ],
      cool: [
        "Cool values provide visual relief in sun-drenched south-facing spaces.",
        "These calming tones suit bedrooms, bathrooms, and spaces dedicated to rest or focus.",
        "Cool colors support professional environments where measured atmosphere is appropriate."
      ]
    }
  },

  // Technical accuracy statements
  technical: {
    harmony: {
      monochromatic: "The palette follows monochromatic harmony, deriving all colors from variations of a single hue at ${baseHue}° on the color wheel.",
      analogous: "Analogous harmony structures the palette, with hues spanning ${hueRange}° of adjacent color wheel territory.",
      complementary: "Complementary opposition drives the palette's energy, with hues separated by approximately ${hueSeparation}° across the wheel.",
      triadic: "Triadic structure distributes hues across three color wheel regions, creating balanced chromatic variety.",
      'split-complementary': "Split-complementary relationships provide contrast with less tension than direct opposition.",
      custom: "The palette follows a custom color relationship tailored to specific aesthetic requirements."
    },
    temperature: {
      warm: "Color temperature leans warm, with ${warmPercent}% of palette hues falling in the red-orange-yellow spectrum.",
      cool: "Color temperature trends cool, with ${coolPercent}% of palette colors in the blue-cyan-green range.",
      balanced: "Color temperature balances between warm and cool, providing thermal neutrality.",
      mixed: "Mixed temperature creates dynamic contrast between warm and cool elements."
    },
    saturation: {
      high: "Average saturation of ${avgSat}% places the palette in high-chroma territory, maximizing color intensity.",
      medium: "Moderate ${avgSat}% average saturation balances chromatic interest with visual comfort.",
      low: "With ${avgSat}% average saturation, the palette prioritizes subtlety over chromatic intensity."
    },
    lightness: {
      light: "Averaging ${avgLight}% lightness, the palette occupies the high-value end of the tonal spectrum.",
      dark: "At ${avgLight}% average lightness, the palette establishes deep, grounding visual presence.",
      balanced: "The ${avgLight}% average lightness positions the palette in the middle tonal range.",
      varied: "Lightness values spanning ${lightRange}% provide strong internal contrast."
    }
  }
};

// ============================================
// 9. CONTENT GENERATION ENGINE
// ============================================

const generateColorSection = (colorAnalysis, role, position, totalColors, rng) => {
  const { naming, hex, hsl, temperature, weight, energy } = colorAnalysis;
  
  // Position-aware descriptors
  const positionDescriptors = {
    first: ['opens', 'begins', 'leads', 'anchors the start of'],
    last: ['concludes', 'closes', 'completes', 'anchors the end of'],
    middle: ['continues', 'bridges', 'extends', 'develops']
  };
  
  const positionType = position === 0 ? 'first' : 
                       position === totalColors - 1 ? 'last' : 'middle';
  const positionVerb = pickFromArray(positionDescriptors[positionType], rng);
  
  // Role-specific templates with position awareness
  const roleTemplates = {
    dominant: [
      `Position ${position + 1}: ${naming.name} (${hex}) serves as the palette's visual anchor. This ${naming.descriptor} ${naming.family} tone ${positionVerb} the sequence with ${weight} visual weight and ${energy} energy. At HSL(${Math.round(hsl.h)}°, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%), it establishes the palette's ${temperature} character.`,
      `Position ${position + 1}: The ${naming.descriptor} ${naming.name} at ${hex} functions as the dominant color, its ${temperature} presence commanding attention. With ${Math.round(hsl.s)}% saturation and ${Math.round(hsl.l)}% lightness, this ${naming.family} provides the primary chromatic identity.`,
      `Position ${position + 1}: ${naming.name} (${hex}) anchors the composition as the dominant hue. This ${naming.descriptor} shade carries ${weight} visual weight, its ${naming.family} character ${positionVerb} the palette with ${energy} energy and ${temperature} temperature.`
    ],
    accent: [
      `Position ${position + 1}: ${naming.name} (${hex}) contributes as an accent tone, its ${naming.descriptor} quality adding chromatic interest without overwhelming. This ${temperature} ${naming.family} at ${Math.round(hsl.s)}% saturation ${positionVerb} the palette with ${energy} energy.`,
      `Position ${position + 1}: The ${naming.descriptor} ${naming.name} at ${hex} provides supporting visual interest. At HSL(${Math.round(hsl.h)}°, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%), this ${naming.family} accent ${positionVerb} the sequence with ${weight} presence.`,
      `Position ${position + 1}: ${naming.name} (${hex}) functions as an accent element, ${positionVerb} the palette with its ${naming.descriptor} ${naming.family} character. The ${temperature} tone carries ${energy} energy at ${Math.round(hsl.l)}% lightness.`
    ],
    neutral: [
      `Position ${position + 1}: ${naming.name} (${hex}) provides essential neutral balance. This ${naming.descriptor} tone ${positionVerb} the palette with visual breathing room, its ${Math.round(hsl.s)}% saturation allowing chromatic colors to resonate without competition.`,
      `Position ${position + 1}: The ${naming.descriptor} ${naming.name} at ${hex} serves as a grounding neutral element. At ${Math.round(hsl.l)}% lightness, it ${positionVerb} the sequence with ${weight} but unobtrusive presence.`,
      `Position ${position + 1}: ${naming.name} (${hex}) functions as neutral infrastructure, its ${naming.descriptor} character ${positionVerb} the palette while supporting more saturated companions.`
    ],
    background: [
      `Position ${position + 1}: ${naming.name} (${hex}) offers excellent background potential. This ${naming.descriptor} ${naming.family} at ${Math.round(hsl.l)}% lightness ${positionVerb} the palette with ${weight} foundation suitable for text and graphic overlay.`,
      `Position ${position + 1}: The ${naming.descriptor} ${naming.name} at ${hex} provides canvas-ready lightness. At HSL(${Math.round(hsl.h)}°, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%), it ${positionVerb} the sequence with spatial depth.`,
      `Position ${position + 1}: ${naming.name} (${hex}) serves as a background-capable tone, its ${naming.descriptor} ${Math.round(hsl.l)}% lightness ${positionVerb} the palette with airy foundation.`
    ],
    dark: [
      `Position ${position + 1}: ${naming.name} (${hex}) provides deep anchor weight. This ${naming.descriptor} ${naming.family} at ${Math.round(hsl.l)}% lightness ${positionVerb} the palette with ${weight} presence suitable for text or grounding elements.`,
      `Position ${position + 1}: The ${naming.descriptor} ${naming.name} at ${hex} contributes substantial darkness. At HSL(${Math.round(hsl.h)}°, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%), it ${positionVerb} the sequence with dramatic depth.`,
      `Position ${position + 1}: ${naming.name} (${hex}) anchors with ${weight} darkness, its ${naming.descriptor} ${naming.family} character ${positionVerb} the palette with grounding intensity.`
    ]
  };

  // Select appropriate role
  let effectiveRole = role;
  if (colorAnalysis.isNeutral) {
    effectiveRole = 'neutral';
  } else if (colorAnalysis.hsl.l > 80) {
    effectiveRole = 'background';
  } else if (colorAnalysis.hsl.l < 25) {
    effectiveRole = 'dark';
  }
  
  const templates = roleTemplates[effectiveRole] || roleTemplates.accent;
  return pickFromArray(templates, rng);
};

const generateTransitionSection = (relationship, index, rng) => {
  const { from, to, contrast, relationshipType, hueDifference } = relationship;
  
  const transitionTemplates = {
    tonal: [
      `Transition ${index + 1}-${index + 2}: The shift from ${from.naming.name} to ${to.naming.name} (${contrast.toFixed(2)}:1 contrast) creates tonal continuity within the ${from.naming.family} family, varying lightness while maintaining hue consistency across ${Math.round(hueDifference)}° of separation.`,
      `Transition ${index + 1}-${index + 2}: Moving from ${from.naming.name} (${from.hex}) to ${to.naming.name} (${to.hex}) produces smooth tonal progression. The ${contrast.toFixed(2)}:1 contrast ratio maintains readability while the ${Math.round(hueDifference)}° hue shift preserves family cohesion.`,
      `Transition ${index + 1}-${index + 2}: ${from.naming.name} flows into ${to.naming.name} with ${contrast.toFixed(2)}:1 contrast, the tonal relationship creating seamless ${from.naming.family}-to-${to.naming.family} connection.`
    ],
    analogous: [
      `Transition ${index + 1}-${index + 2}: The progression from ${from.naming.name} to ${to.naming.name} follows analogous harmony across ${Math.round(hueDifference)}° of hue rotation. At ${contrast.toFixed(2)}:1 contrast, adjacent wheel positions create natural visual flow.`,
      `Transition ${index + 1}-${index + 2}: ${from.naming.name} (${from.hex}) and ${to.naming.name} (${to.hex}) share analogous relationship, their ${Math.round(hueDifference)}° separation producing comfortable chromatic transition with ${contrast.toFixed(2)}:1 contrast.`,
      `Transition ${index + 1}-${index + 2}: Moving from ${from.naming.family} into ${to.naming.family} demonstrates analogous color theory, the ${Math.round(hueDifference)}° shift maintaining visual comfort at ${contrast.toFixed(2)}:1 contrast.`
    ],
    complementary: [
      `Transition ${index + 1}-${index + 2}: The jump from ${from.naming.name} to ${to.naming.name} introduces complementary tension across ${Math.round(hueDifference)}° of wheel opposition. The ${contrast.toFixed(2)}:1 contrast ratio amplifies this chromatic energy.`,
      `Transition ${index + 1}-${index + 2}: ${from.naming.name} (${from.hex}) and ${to.naming.name} (${to.hex}) create dynamic complementary contrast, their ${Math.round(hueDifference)}° separation generating ${contrast.toFixed(2)}:1 visual tension.`,
      `Transition ${index + 1}-${index + 2}: The opposition between ${from.naming.family} and ${to.naming.family} follows complementary principles, ${Math.round(hueDifference)}° of hue distance producing ${contrast.toFixed(2)}:1 maximum chromatic contrast.`
    ],
    contrasting: [
      `Transition ${index + 1}-${index + 2}: ${from.naming.name} and ${to.naming.name} create deliberate visual contrast at ${contrast.toFixed(2)}:1, their ${Math.round(hueDifference)}° hue difference adding compositional interest.`,
      `Transition ${index + 1}-${index + 2}: The distinction between ${from.naming.name} (${from.hex}) and ${to.naming.name} (${to.hex}) provides ${contrast.toFixed(2)}:1 separation across ${Math.round(hueDifference)}° of hue space.`,
      `Transition ${index + 1}-${index + 2}: Moving from ${from.naming.family} to ${to.naming.family} introduces ${Math.round(hueDifference)}° of intentional variety with ${contrast.toFixed(2)}:1 contrast supporting visual hierarchy.`
    ],
    'neutral-chromatic': [
      `Transition ${index + 1}-${index + 2}: The pairing of ${from.naming.name} with ${to.naming.name} balances ${from.isNeutral ? 'neutral' : 'chromatic'} and ${to.isNeutral ? 'neutral' : 'chromatic'} elements at ${contrast.toFixed(2)}:1 contrast.`,
      `Transition ${index + 1}-${index + 2}: ${from.naming.name} (${from.hex}) alongside ${to.naming.name} (${to.hex}) demonstrates effective neutral-chromatic framing with ${contrast.toFixed(2)}:1 separation.`,
      `Transition ${index + 1}-${index + 2}: The ${contrast.toFixed(2)}:1 contrast between ${from.naming.name} and ${to.naming.name} leverages neutral space to enhance chromatic impact.`
    ],
    'triadic-adjacent': [
      `Transition ${index + 1}-${index + 2}: ${from.naming.name} to ${to.naming.name} spans ${Math.round(hueDifference)}° suggesting triadic relationship. The ${contrast.toFixed(2)}:1 contrast maintains balance across this structural color jump.`,
      `Transition ${index + 1}-${index + 2}: The ${Math.round(hueDifference)}° separation between ${from.naming.name} (${from.hex}) and ${to.naming.name} (${to.hex}) reflects triadic harmony principles at ${contrast.toFixed(2)}:1 contrast.`,
      `Transition ${index + 1}-${index + 2}: Moving from ${from.naming.family} to ${to.naming.family} across ${Math.round(hueDifference)}° creates triadic-adjacent relationship with ${contrast.toFixed(2)}:1 visual distinction.`
    ]
  };

  const templates = transitionTemplates[relationshipType] || transitionTemplates.contrasting;
  return pickFromArray(templates, rng);
};

// Small palettes need different handling
const generateSmallPaletteNarrative = (colorAnalyses, relationships, roles, rng) => {
  const count = colorAnalyses.length;
  
  if (count === 2) {
    const c1 = colorAnalyses[0];
    const c2 = colorAnalyses[1];
    const rel = relationships[0];
    
    const twoColorTemplates = [
      `This minimalist two-color palette pairs ${c1.naming.name} (${c1.hex}) with ${c2.naming.name} (${c2.hex}). The ${rel.relationshipType} relationship creates ${rel.contrast.toFixed(2)}:1 contrast, ${rel.isHighContrast ? 'sufficient for text applications' : 'suitable for decorative use'}. ${c1.naming.name} brings ${c1.naming.descriptor} ${c1.temperature} energy while ${c2.naming.name} contributes ${c2.naming.descriptor} ${c2.temperature} balance.`,
      `Two colors in ${rel.relationshipType} harmony: ${c1.naming.name} (${c1.hex}) and ${c2.naming.name} (${c2.hex}) achieve ${rel.contrast.toFixed(2)}:1 contrast across ${Math.round(rel.hueDifference)}° of hue separation. The ${c1.naming.family}-${c2.naming.family} combination balances ${c1.weight} and ${c2.weight} visual weights.`,
      `This focused duo combines ${c1.naming.descriptor} ${c1.naming.name} with ${c2.naming.descriptor} ${c2.naming.name}. At ${c1.hex} and ${c2.hex} respectively, they produce ${rel.contrast.toFixed(2)}:1 contrast through ${rel.relationshipType} color relationship.`
    ];
    
    return pickFromArray(twoColorTemplates, rng);
  }
  
  if (count === 3) {
    const [c1, c2, c3] = colorAnalyses;
    
    const threeColorTemplates = [
      `This triad palette balances ${c1.naming.name} (${c1.hex}), ${c2.naming.name} (${c2.hex}), and ${c3.naming.name} (${c3.hex}). The three-color structure provides ${roles.dominant ? `${roles.dominant.color.naming.name} as focal point` : 'balanced visual weight'} with supporting tones for compositional flexibility.`,
      `Three colors in harmony: ${c1.naming.descriptor} ${c1.naming.name} opens, ${c2.naming.descriptor} ${c2.naming.name} bridges, and ${c3.naming.descriptor} ${c3.naming.name} closes the sequence. This ${c1.naming.family}-${c2.naming.family}-${c3.naming.family} combination spans ${c1.temperature} to ${c3.temperature} temperature.`,
      `The palette's three elements, ${c1.naming.name}, ${c2.naming.name}, and ${c3.naming.name}, create complete yet focused color story. Each contributes distinct character: ${c1.naming.descriptor} opening, ${c2.naming.descriptor} middle, ${c3.naming.descriptor} conclusion.`
    ];
    
    return pickFromArray(threeColorTemplates, rng);
  }
  
  return null; // Use standard generation for 4+ colors
};

const generateApplicationSection = (context, subContext, data, rng) => {
  const contextTemplates = templates.applications[context]?.[subContext];
  if (!contextTemplates) return null;
  
  let text = pickFromArray(contextTemplates, rng);
  
  Object.entries(data).forEach(([key, value]) => {
    text = text.replace(new RegExp(`\\$\\{${key}\\}`, 'g'), value);
  });
  
  return text;
};

const generateTechnicalSection = (category, type, data, rng) => {
  let template = templates.technical[category]?.[type];
  if (!template) return null;
  
  Object.entries(data).forEach(([key, value]) => {
    template = template.replace(new RegExp(`\\$\\{${key}\\}`, 'g'), value);
  });
  
  return template;
};

// ============================================
// 10. MAIN SEO GENERATOR
// ============================================

export const generateRichSEO = (colors, mode = 'auto', mood = 'any') => {
  if (!colors || colors.length === 0) {
    return { title: "", meta: "", content: "", keywords: [], traits: null };
  }

  // Create deterministic RNG from colors
  const seed = hashString(colors.join(''));
  const rng = createSeededRandom(seed);
  
  // Deep analysis of each color
  const colorAnalyses = colors.map(hex => analyzeColorDeeply(hex));
  
  // Analyze relationships between adjacent colors
  const relationships = analyzePaletteRelationships(colorAnalyses);
  
  // Identify roles within the palette
  const roles = identifyPaletteRoles(colorAnalyses);
  
  // Calculate overall palette statistics
  const avgSaturation = colorAnalyses.reduce((sum, c) => sum + c.hsl.s, 0) / colorAnalyses.length;
  const avgLightness = colorAnalyses.reduce((sum, c) => sum + c.hsl.l, 0) / colorAnalyses.length;
  const lightnesses = colorAnalyses.map(c => c.hsl.l);
  const lightnessRange = Math.max(...lightnesses) - Math.min(...lightnesses);
  
  // Find extremes for contrast calculation
  const sortedByLuminance = [...colorAnalyses].sort((a, b) => a.hsl.l - b.hsl.l);
  const darkest = sortedByLuminance[0];
  const lightest = sortedByLuminance[sortedByLuminance.length - 1];
  const maxContrast = wcagContrastRatio(darkest.hex, lightest.hex);
  
  // Determine dominant hue family
  const chromatic = colorAnalyses.filter(c => !c.isNeutral);
  const hueFamilies = chromatic.map(c => c.naming.family);
  const familyCounts = {};
  hueFamilies.forEach(f => { familyCounts[f] = (familyCounts[f] || 0) + 1; });
  const dominantFamily = Object.entries(familyCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'neutral';
  
  // Temperature analysis
  const warmCount = colorAnalyses.filter(c => c.temperature === 'warm').length;
  const coolCount = colorAnalyses.filter(c => c.temperature === 'cool').length;
  const temperatureType = warmCount > coolCount * 1.5 ? 'warm' : 
                          coolCount > warmCount * 1.5 ? 'cool' : 'balanced';
  
  // Determine harmony type from actual hue distribution
  const hues = chromatic.map(c => c.hsl.h);
  let harmonyType = 'custom';
  if (hues.length >= 2) {
    const hueSpread = Math.max(...hues) - Math.min(...hues);
    const adjustedSpread = hueSpread > 180 ? 360 - hueSpread : hueSpread;
    
    if (adjustedSpread < 30) harmonyType = 'monochromatic';
    else if (adjustedSpread < 60) harmonyType = 'analogous';
    else if (adjustedSpread > 150 && adjustedSpread < 200) harmonyType = 'complementary';
    else if (adjustedSpread > 100 && adjustedSpread < 140) harmonyType = 'triadic';
    else if (adjustedSpread > 120 && adjustedSpread < 160) harmonyType = 'split-complementary';
  }

  // Character classification
  const character = avgSaturation > 60 ? 'vibrant' :
                    avgSaturation < 30 ? 'muted' :
                    avgLightness > 70 && avgSaturation < 50 ? 'pastel' :
                    avgLightness < 35 ? 'dark' : 'balanced';

  // === GENERATE TITLE ===
  const dominantColorName = roles.dominant?.color.naming.name || colorAnalyses[0].naming.name;
  const titleTemplates = [
    `${colors.length}-Color ${capitalize(dominantFamily)} Palette: ${capitalize(character)} ${capitalize(harmonyType)} Scheme`,
    `${capitalize(dominantColorName)} Color Palette with ${colors.length} ${capitalize(character)} Tones`,
    `${capitalize(character)} ${capitalize(dominantFamily)} Color Scheme: ${colors.length} Coordinated Hues`,
    `${colors.length} ${capitalize(character)} ${capitalize(dominantFamily)} Colors in ${capitalize(harmonyType)} Harmony`
  ];
  const title = pickFromArray(titleTemplates, rng);

  // === GENERATE META DESCRIPTION ===
  const hexList = colors.slice(0, 3).map(c => c.replace('#', '')).join(', ');
  const metaTemplates = [
    `A ${character} ${colors.length}-color ${dominantFamily} palette featuring ${hexList} and more. ${capitalize(harmonyType)} harmony with ${maxContrast.toFixed(1)}:1 contrast ratio for web design, branding, and UI projects.`,
    `${capitalize(harmonyType)} ${dominantFamily} color scheme with ${colors.length} ${character} tones including ${hexList}. Export to HEX, RGB, HSL for design projects with ${maxContrast.toFixed(1)}:1 accessibility contrast.`,
    `Curated ${dominantFamily} palette: ${colors.length} ${character} colors (${hexList}) in ${harmonyType} harmony. Professional color scheme with ${temperatureType} temperature and ${maxContrast.toFixed(1)}:1 contrast.`
  ];
  const meta = pickFromArray(metaTemplates, rng);

  // === GENERATE MAIN CONTENT ===
  const contentSections = [];

  // 1. Opening paragraph
  const openingTemplate = pickFromArray(templates.openings[character] || templates.openings.balanced, rng);
  const opening = openingTemplate.replace(/\${count}/g, colors.length);
  contentSections.push(`Overview: ${opening}`);

  // 2. Palette narrative (special handling for 2-3 colors)
  const smallPaletteNarrative = generateSmallPaletteNarrative(colorAnalyses, relationships, roles, rng);
  if (smallPaletteNarrative) {
    contentSections.push(`Palette Composition: ${smallPaletteNarrative}`);
  }

  // 3. Color-by-color analysis (EXPLICIT for every color)
  const colorDescriptions = colorAnalyses.map((analysis, index) => {
    // Determine role for this specific color
    let role = 'accent';
    if (roles.dominant?.index === index) {
      role = 'dominant';
    } else if (roles.neutrals.some(n => n.index === index)) {
      role = 'neutral';
    } else if (roles.backgrounds.some(b => b.index === index)) {
      role = 'background';
    } else if (roles.text.some(t => t.index === index)) {
      role = 'dark';
    }
    
    return generateColorSection(analysis, role, index, colorAnalyses.length, rng);
  });
  
  contentSections.push(`Individual Color Analysis: ${colorDescriptions.join(' ')}`);

  // 4. Color relationships / flow (for 3+ colors)
  if (relationships.length > 0 && colorAnalyses.length >= 3) {
    const flowDescriptions = relationships.map((rel, idx) => 
      generateTransitionSection(rel, idx, rng)
    );
    contentSections.push(`Color Transitions: ${flowDescriptions.join(' ')}`);
  }

  // 5. Pairwise contrast matrix for larger palettes (5+ colors)
  if (colorAnalyses.length >= 5) {
    const contrastPairs = [];
    for (let i = 0; i < colorAnalyses.length; i++) {
      for (let j = i + 1; j < colorAnalyses.length; j++) {
        const c1 = colorAnalyses[i];
        const c2 = colorAnalyses[j];
        const ratio = wcagContrastRatio(c1.hex, c2.hex);
        if (ratio >= 4.5) {
          contrastPairs.push(`${c1.naming.name}/${c2.naming.name} (${ratio.toFixed(1)}:1)`);
        }
      }
    }
    
    if (contrastPairs.length > 0) {
      contentSections.push(`High-Contrast Pairings: The following color combinations achieve WCAG AA contrast (4.5:1+): ${contrastPairs.slice(0, 8).join(', ')}. These pairings support accessible text placement and clear visual hierarchy.`);
    } else {
      contentSections.push(`Contrast Note: No internal color pairings achieve WCAG AA contrast (4.5:1). Consider supplementing with pure black (#000000) or white (#FFFFFF) for text applications.`);
    }
  }

  // 6. Accessibility summary
  const a11yLevel = maxContrast >= 7 ? 'AAA' : maxContrast >= 4.5 ? 'AA' : maxContrast >= 3 ? 'AA-large' : 'decorative';
  const a11ySummary = `Accessibility: The palette achieves ${maxContrast.toFixed(2)}:1 maximum internal contrast between ${darkest.naming.name} (${darkest.hex}) and ${lightest.naming.name} (${lightest.hex}). This ${a11yLevel === 'decorative' ? 'limits text applications without supplementary colors' : `supports WCAG 2.1 Level ${a11yLevel} compliance for ${a11yLevel === 'AA-large' ? 'large text (18pt+)' : 'standard body text'}`}. ${colorAnalyses.filter(c => c.naming.family === 'red' || c.naming.family === 'green').length > 1 ? 'Note: Red-green combinations present should be validated with color blindness simulation.' : 'The palette avoids problematic red-green combinations.'}`;
  contentSections.push(a11ySummary);

  // 7. Color values reference
  const colorValues = colorAnalyses.map(c => 
    `${c.naming.name} (${c.hex}): RGB(${c.rgb.r}, ${c.rgb.g}, ${c.rgb.b}), HSL(${Math.round(c.hsl.h)}°, ${Math.round(c.hsl.s)}%, ${Math.round(c.hsl.l)}%), OKLCH(${(c.oklch.L * 100).toFixed(1)}%, ${c.oklch.C.toFixed(3)}, ${Math.round(c.oklch.h)}°)`
  ).join('. ');
  contentSections.push(`Color Values Reference: ${colorValues}.`);

  // 8. Export formats note
  contentSections.push(`Export Formats: This palette exports to HEX, RGB, HSL, OKLCH, and CMYK formats. CSS custom properties, Tailwind configuration, SCSS variables, and design token JSON support systematic implementation across development workflows.`);

  // === GENERATE KEYWORDS ===
  const keywords = [
    `${dominantFamily} color palette`,
    `${colors.length} color palette`,
    `${character} color scheme`,
    `${harmonyType} colors`,
    `${temperatureType} palette`,
    `${dominantColorName} palette`,
    `${dominantFamily} hex codes`,
    `${character} ${dominantFamily}`,
    `${dominantFamily} color combinations`,
    `${dominantFamily} design colors`,
    `${colors.length} color scheme`,
    `${harmonyType} harmony palette`,
    ...colorAnalyses.slice(0, 3).map(c => `${c.naming.name} color`),
    ...colorAnalyses.slice(0, 3).map(c => c.hex.toLowerCase())
  ];

  return {
    title,
    meta,
    content: contentSections.join('\n\n'),
    keywords: [...new Set(keywords)], // Remove duplicates
    traits: {
      harmony: harmonyType,
      temperature: temperatureType,
      saturation: character === 'vibrant' ? 'vibrant' : character === 'muted' ? 'muted' : 'moderate',
      lightness: avgLightness > 65 ? 'light' : avgLightness < 35 ? 'dark' : 'balanced',
      character,
      primaryHue: dominantFamily,
      dominantColor: dominantColorName,
      contrastRatio: maxContrast.toFixed(2),
      accessibilityLevel: a11yLevel,
      colorCount: colors.length,
      neutralCount: colorAnalyses.filter(c => c.isNeutral).length,
      warmCount,
      coolCount
    },
    // Expose detailed analysis for potential UI use
    analysis: {
      colors: colorAnalyses,
      relationships,
      roles
    }
  };
};

// Capitalize helper
const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : '';
/* =========================================
   FILE: src/utils/seo.js
   ========================================= */

// src/utils/seo.js
export const submitToIndexNow = async (urls) => {
    try {
      await fetch('/.netlify/functions/indexnow-submit', {
        method: 'POST',
        body: JSON.stringify({ urls: Array.isArray(urls) ? urls : [urls] }),
      });
    } catch (err) {
      console.error('IndexNow submission failed', err);
    }
  };